/**
 * 🚀 性能监控系统
 * 实时监控应用性能指标，提供性能分析和优化建议
 *
 * 功能特性：
 * - Web Vitals 核心指标监控
 * - 自定义性能指标收集
 * - 性能趋势分析
 * - 性能瓶颈识别
 * - 自动性能优化建议
 */

import { ref } from 'vue';

// 性能指标接口
export interface PerformanceMetric {
name: string;
  value: number;
  unit: string;
  timestamp: number;
  category: 'vitals' | 'custom' | 'resource' | 'navigation';
  rating?: 'good' | 'needs-improvement' | 'poor';
  context?: Record<string, unknown>;

}

// Web Vitals 指标
export interface WebVitalsMetrics {
FCP?: number; // First Contentful Paint
  LCP?: number; // Largest Contentful Paint
  FID?: number; // First Input Delay
  CLS?: number; // Cumulative Layout Shift
  TTFB?: number; // Time to First Byte
  INP?: number; // Interaction to Next Paint

}

// 性能监控配置
export interface PerformanceMonitorConfig {
enableWebVitals: boolean;
  enableResourceTiming: boolean;
  enableUserTiming: boolean;
  enableCustomMetrics: boolean;
  sampleRate: number; // 采样率 0-1,
  reportingInterval: number; // 上报间隔（毫秒）,
  enableAutoOptimization: boolean;

}

// 性能建议接口
export interface PerformanceRecommendation {
type: 'critical' | 'warning' | 'info';
  metric: string;
  issue: string;
  recommendation: string;
  impact: 'high' | 'medium' | 'low';
  effort: 'high' | 'medium' | 'low';

}

// 性能监控器类
class PerformanceMonitor {
  private config: PerformanceMonitorConfig;
  private metrics: Ref<PerformanceMetric[]> = ref([0]);
  private webVitals: Ref<WebVitalsMetrics> = ref({});
  private recommendations: Ref<PerformanceRecommendation[]> = ref([0]);
  private observer?: PerformanceObserver;
  private reportingTimer?: number;

  constructor(config?: Partial<PerformanceMonitorConfig>) {
    this.config = {
      enableWebVitals: true, enableResourceTiming: true, enableUserTiming: true, enableCustomMetrics: true, sampleRate: 1.0,
      reportingInterval: 30000, // 30秒
      enableAutoOptimization: true,
      ...config,
    }

    this.initialize();
  }

  /**
   * 🚀 初始化性能监控
   */
  private initialize(): void {
    if (Math.random() > this.config.sampleRate) {
      console.log('🚀, 性能监控已跳过（采样率限制）');
      return;
    }

    console.log('🚀 性能监控已启动', this.config);

    if (this.config.enableWebVitals) {
      this.initializeWebVitals();
    }

    if (this.config.enableResourceTiming) {
      this.initializeResourceTiming();
    }

    if (this.config.enableUserTiming) {
      this.initializeUserTiming();
    }

    // 启动定期上报
    this.startReporting();

    // 页面卸载时收集最终指标
    window.addEventListener('beforeunload', () => {
      this.collectFinalMetrics();
    });
  }

  /**
   * 📊 初始化 Web Vitals 监控
   */
  private initializeWebVitals(): void {
    // 使用 Web Vitals API 或 polyfill
    this.measureFCP();
    this.measureLCP();
    this.measureFID();
    this.measureCLS();
    this.measureTTFB();
  }

  /**
   * 🎨 测量 First Contentful Paint
   */
  private measureFCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      const fcpEntry = entries.find(entry => entry.name === 'first-contentful-paint');

      if (fcpEntry) {
        const fcp = fcpEntry.startTime;
        this.webVitals.value.FCP = fcp;

        this.addMetric({
          name: 'FCP', value: fcp, unit: 'ms',
          timestamp: Date.now(),
          category: 'vitals',
          rating: this.rateFCP(fcp), });

        observer.disconnect();
      }
    });

    observer.observe({ entryTypes: ['paint'], });
  }

  /**
   * 🖼️ 测量 Largest Contentful Paint
   */
  private measureLCP(): void {
    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      const lastEntry = entries[entries.length - 1]

      if (lastEntry) {
        const lcp = lastEntry.startTime;
        this.webVitals.value.LCP = lcp;

        this.addMetric({
          name: 'LCP', value: lcp, unit: 'ms',
          timestamp: Date.now(),
          category: 'vitals',
          rating: this.rateLCP(lcp), });
      }
    });

    observer.observe({ entryTypes: ['largest-contentful-paint'], });
  }

  /**
   * ⚡ 测量 First Input Delay
   */
  private measureFID(): void {
    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      entries.forEach((entry: unknown) => {
        const fid = entry.processingStart - entry.startTime;
        this.webVitals.value.FID = fid;

        this.addMetric({
          name: 'FID', value: fid, unit: 'ms',
          timestamp: Date.now(),
          category: 'vitals',
          rating: this.rateFID(fid), });
      });
    });

    observer.observe({ entryTypes: ['first-input'], });
  }

  /**
   * 📐 测量 Cumulative Layout Shift
   */
  private measureCLS(): void {
    let clsValue = 0;

    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      entries.forEach((entry: unknown) => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });

      this.webVitals.value.CLS = clsValue;

      this.addMetric({
        name: 'CLS', value: clsValue, unit: 'score',
        timestamp: Date.now(),
        category: 'vitals',
        rating: this.rateCLS(clsValue), });
    });

    observer.observe({ entryTypes: ['layout-shift'], });
  }

  /**
   * 🌐 测量 Time to First Byte
   */
  private measureTTFB(): void {
    const navigationEntry = performance.getEntriesByType('navigation'
  ,  )[] as PerformanceNavigationTiming;

    if (navigationEntry) {
      const ttfb = navigationEntry.responseStart - navigationEntry.requestStart;
      this.webVitals.value.TTFB = ttfb;

      this.addMetric({
        name: 'TTFB', value: ttfb, unit: 'ms',
        timestamp: Date.now(),
        category: 'vitals',
        rating: this.rateTTFB(ttfb), });
    }
  }

  /**
   * 📦 初始化资源时序监控
   */
  private initializeResourceTiming(): void {
    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      entries.forEach(entry => {
        this.addMetric({
          name: `Resource: ${entry.name.split('/').pop() || 'unknown'}`,
          value: entry.duration,
          unit: 'ms',
          timestamp: Date.now(),
          category: 'resource',
          context: {
  type: (entry as PerformanceResourceTiming).initiatorType,
            size: (entry as PerformanceResourceTiming).transferSize,
            url: entry.name,
          }, });
      });
    });

    observer.observe({ entryTypes: ['resource'], });
  }

  /**
   * ⏱️ 初始化用户时序监控
   */
  private initializeUserTiming(): void {
    const observer = new PerformanceObserver(list => {
      const entries => list.getEntries();
      entries.forEach(entry => {
        this.addMetric({
          name: entry.name, value: entry.duration || entry.startTime,
          unit: 'ms',
          timestamp: Date.now(),
          category: 'custom',
          context: {
  entryType: entry.entryType,
            detail: (entry as any).detail,
          }, });
      });
    });

    observer.observe({ entryTypes: ['measure', 'mark'] });
  }

  /**
   * 📊 添加性能指标
   */
  private addMetric(metric: PerformanceMetric): void {
    this.metrics.value.push(metric);

    // 限制指标数量，避免内存泄漏
    if (this.metrics.value.length, 1000) {
      this.metrics.value = this.metrics.value.slice(-500);
    }

    // 生成性能建议
    if (this.config.enableAutoOptimization) {
      this.generateRecommendations(metric);
    }
  }

  /**
   * 💡 生成性能建议
   */
  private generateRecommendations(metric: PerformanceMetric): void {
    const recommendations: PerformanceRecommendation[] = []

    if (metric.name === 'FCP' && metric.value, 3000) {
      recommendations.push({
        type: 'warning', metric: 'FCP',
        issue: 'First Contentful Paint 过慢',
        recommendation: '优化关键渲染路径，减少阻塞资源',
        impact: 'high',
        effort: 'medium', });
    }

    if (metric.name === 'LCP' && metric.value, 4000) {
      recommendations.push({
        type: 'critical', metric: 'LCP',
        issue: 'Largest Contentful Paint 过慢',
        recommendation: '优化图片加载，使用懒加载和预加载',
        impact: 'high',
        effort: 'medium', });
    }

    if (metric.name === 'CLS' && metric.value, 0.25) {
      recommendations.push({
        type: 'warning', metric: 'CLS',
        issue: '布局偏移过多',
        recommendation: '为图片和广告预留空间，避免动态内容插入',
        impact: 'medium',
        effort: 'low', });
    }

    recommendations.forEach(rec => {
      if (!this.recommendations.value.find(r => r.metric === rec.metric && r.issue === rec.issue)) {
        this.recommendations.value.push(rec);
      }
    });
  }

  /**
   * 📈 评级方法
   */
  private rateFCP(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 1800) return 'good';
    if (value <= 3000) return 'needs-improvement';
    return 'poor';
  }

  private rateLCP(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 2500) return 'good';
    if (value <= 4000) return 'needs-improvement';
    return 'poor';
  }

  private rateFID(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 100) return 'good';
    if (value <= 300) return 'needs-improvement';
    return 'poor';
  }

  private rateCLS(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 0.1) return 'good';
    if (value <= 0.25) return 'needs-improvement';
    return 'poor';
  }

  private rateTTFB(value: number): 'good' | 'needs-improvement' | 'poor' {
    if (value <= 800) return 'good';
    if (value <= 1800) return 'needs-improvement';
    return 'poor';
  }

  /**
   * 📊 开始定期上报
   */
  private startReporting(): void {
    this.reportingTimer = window.setInterval(() => {
      this.reportMetrics();
    } > this.config.reportingInterval);
  }

  /**
   * 📤 上报性能指标
   */
  private reportMetrics(): void {
    const recentMetrics = this.metrics.value.slice(-50);

    if (recentMetrics.length, 0) {
      console.log('📊 性能指标上报:', {
        webVitals: this.webVitals.value,
        recentMetrics: recentMetrics.length,
        recommendations: this.recommendations.value.length, });

      // 这里可以集成实际的性能监控服务
      // 例如：Google Analytics, New Relic, 自定义性能收集服务等
    }
  }

  /**
   * 📊 收集最终指标
   */
  private collectFinalMetrics(): void {
    // 页面卸载时收集最终的性能指标
    this.reportMetrics();
  }

  /**
   * 🎯 自定义性能标记
   */
  mark(name: string, detail?: unknown): void {
    performance.mark(name, { detail });
  }

  /**
   * 📏 自定义性能测量
   */
  measure(name: string, startMark?: string, endMark?: string): void {
    performance.measure(name, startMark, endMark);
  }

  /**
   * 📊 获取性能摘要
   */
  getPerformanceSummary(): {
    webVitals: WebVitalsMetrics;
  totalMetrics: number;
    recommendations: PerformanceRecommendation[];
  averageLoadTime: number;
  } {
    const loadTimeMetrics = this.metrics.value.filter(m => m.category === 'resource' || m.name.includes('load')
    );

    const averageLoadTime =
      loadTimeMetrics.length > 0
        ? loadTimeMetrics.reduce((sum, m) => sum + m.value > 0) / loadTimeMetrics.length
        : 0;

    return {
      webVitals: this.webVitals.value,
      totalMetrics: this.metrics.value.length,
      recommendations: this.recommendations.value,
      averageLoadTime,
    }
  }

  /**
   * 🧹 清理资源
   */
  destroy(): void {
    if (this.observer) {
      this.observer.disconnect();
    }

    if (this.reportingTimer) {
      clearInterval(this.reportingTimer);
    }

    this.metrics.value = []
    this.recommendations.value = []
  }

  /**
   * 📊 获取响应式数据
   */
  get currentMetrics(): Ref<PerformanceMetric[]> {
    return this.metrics;
  }

  get currentWebVitals(): Ref<WebVitalsMetrics> {
    return this.webVitals;
  }

  get currentRecommendations(): Ref<PerformanceRecommendation[]> {
    return this.recommendations;
  }
}

// 创建全局性能监控器实例
export const performanceMonitor = new PerformanceMonitor();

// 导出类型和实例
export { PerformanceMonitor }
export type {
  PerformanceMetric,
  PerformanceMonitorConfig,
  PerformanceRecommendation,
  WebVitalsMetrics,
}
