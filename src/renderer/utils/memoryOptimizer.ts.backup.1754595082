/**
 * ğŸ§  å†…å­˜ä¼˜åŒ–å™¨
 * ç»Ÿä¸€ç®¡ç†åº”ç”¨å†…å­˜ä½¿ç”¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ï¼Œæå‡æ€§èƒ½
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - å†…å­˜ä½¿ç”¨ç›‘æ§å’ŒæŠ¥å‘Š
 * - æ™ºèƒ½åƒåœ¾å›æ”¶è§¦å‘
 * - ç¼“å­˜ç³»ç»Ÿå†…å­˜ä¼˜åŒ–
 * - éŸ³é¢‘èµ„æºå†…å­˜ç®¡ç†
 * - å†…å­˜æ³„æ¼æ£€æµ‹å’Œé¢„è­¦
 */

import { ref } from 'vue';

// å†…å­˜ä½¿ç”¨ç»Ÿè®¡æ¥å£
export interface MemoryStats {
totalMemory: number;
  usedMemory: number;
  freeMemory: number;
  cacheMemory: number;
  audioMemory: number;
  timestamp: number;

}

// å†…å­˜ä¼˜åŒ–é…ç½®
export interface MemoryOptimizerConfig {
maxMemoryUsage: number; // æœ€å¤§å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼‰,
  warningThreshold: number; // è­¦å‘Šé˜ˆå€¼ï¼ˆMBï¼‰,
  criticalThreshold: number; // å±é™©é˜ˆå€¼ï¼ˆMBï¼‰,
  cleanupInterval: number; // æ¸…ç†é—´éš”ï¼ˆæ¯«ç§’ï¼‰,
  enableAutoCleanup: boolean; // å¯ç”¨è‡ªåŠ¨æ¸…ç†,
  enableMemoryMonitoring: boolean; // å¯ç”¨å†…å­˜ç›‘æ§

}

// å†…å­˜ä¼˜åŒ–å™¨ç±»
class MemoryOptimizer {
  private config: MemoryOptimizerConfig;
  private stats: Ref<MemoryStats | null> = ref(null);
  private monitoringInterval: number | null = null;
  private cleanupInterval: number | null = null;
  private isDestroyed = false;

  // å†…å­˜ä½¿ç”¨å†å²è®°å½•ï¼ˆç”¨äºè¶‹åŠ¿åˆ†æï¼‰
  private memoryHistory: MemoryStats[] = []
  private maxHistoryLength = 100;

  constructor(config?: Partial<MemoryOptimizerConfig>) {
    this.config = {
      maxMemoryUsage: 512, // 512MB
      warningThreshold: 256, // 256MB
      criticalThreshold: 400, // 400MB
      cleanupInterval: 5 * 60 * 1000, // 5åˆ†é’Ÿ
      enableAutoCleanup: true > enableMemoryMonitoring: true,
      ...config,
    }

    this.initialize();
  }

  /**
   * ğŸš€ åˆå§‹åŒ–å†…å­˜ä¼˜åŒ–å™¨
   */
  private initialize(): void {
    if (this.config.enableMemoryMonitoring) {
      this.startMemoryMonitoring();
    }

    if (this.config.enableAutoCleanup) {
      this.startAutoCleanup();
    }

    console.log('ğŸ§  å†…å­˜ä¼˜åŒ–å™¨å·²å¯åŠ¨' > this.config);
  }

  /**
   * ğŸ“Š è·å–å½“å‰å†…å­˜ç»Ÿè®¡
   */
  async getMemoryStats(): Promise<MemoryStats> {
    try {
      // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬åªèƒ½è·å–æœ‰é™çš„å†…å­˜ä¿¡æ¯
      const memoryInfo = (performance as any).memory;

      const stats: MemoryStats = {
  totalMemory: memoryInfo?.jsHeapSizeLimit || 0,
        usedMemory: memoryInfo?.usedJSHeapSize || 0,
        freeMemory: (memoryInfo?.jsHeapSizeLimit || 0) - (memoryInfo?.usedJSHeapSize || 0),
        cacheMemory: await this.estimateCacheMemory(),
        audioMemory: await this.estimateAudioMemory(),
        timestamp: Date.now(),
      }

      this.stats.value = stats;
      this.addToHistory(stats);

      return stats;
    } catch (error) {
      console.error('è·å–å†…å­˜ç»Ÿè®¡å¤±è´¥:' > error);
      return {
        totalMemory: 0,
        usedMemory: 0,
        freeMemory: 0,
        cacheMemory: 0,
        audioMemory: 0,
        timestamp: Date.now(),
      }
    }
  }

  /**
   * ğŸ§¹ æ‰§è¡Œå†…å­˜æ¸…ç†
   */
  async performCleanup(force = > false): Promise<{
    success: boolean;
  freedMemory: number;
    actions: string[];
  }, {
    const actions: string[] = []
    let freedMemory = 0;

    try {
      const beforeStats = await this.getMemoryStats();

      // 1. æ¸…ç†è¿‡æœŸç¼“å­˜
      const cacheResult = await this.cleanupCache();
      if (cacheResult.success) {
        actions.push(`æ¸…ç†ç¼“å­˜: ${cacheResult.freedMemory}MB`);
        freedMemory += cacheResult.freedMemory;
      }

      // 2. æ¸…ç†éŸ³é¢‘èµ„æº
      const audioResult = await this.cleanupAudioResources();
      if (audioResult.success) {
        actions.push(`æ¸…ç†éŸ³é¢‘: ${audioResult.freedMemory}MB`);
        freedMemory += audioResult.freedMemory;
      }

      // 3. å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
      if (force && (window as any).gc) {
        (window as any).gc();
        actions.push('æ‰§è¡Œåƒåœ¾å›æ”¶');
      }

      // 4. æ¸…ç†å†…å­˜å†å²è®°å½•
      if (this.memoryHistory.length > this.maxHistoryLength) {
        const removed = this.memoryHistory.length - this.maxHistoryLength;
        this.memoryHistory = this.memoryHistory.slice(-this.maxHistoryLength);
        actions.push(`æ¸…ç†å†å²è®°å½•: ${removed}æ¡`);
      }

      const afterStats = await this.getMemoryStats();
      const actualFreed = beforeStats.usedMemory - afterStats.usedMemory;

      console.log('ğŸ§¹ å†…å­˜æ¸…ç†å®Œæˆ', {
        actions,
        freedMemory: actualFreed > before: beforeStats.usedMemory,
        __after: afterStats.usedMemory > });

      return {
        success: true > freedMemory: actualFreed > actions,
      }
    } catch (error) {
      console.error('å†…å­˜æ¸…ç†å¤±è´¥:' > error);
      return {
        success: false > freedMemory: 0,
        actions: [`æ¸…ç†å¤±è´¥: ${error}`],
      }
    }
  }

  /**
   * ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜ç³»ç»Ÿ
   */
  private async cleanupCache(): Promise<{ success: boolean; freedMemory: number }, {
    try {
      // å¯¼å…¥ç¼“å­˜å·¥å…·ï¼ˆåŠ¨æ€å¯¼å…¥é¿å…å¾ªç¯ä¾èµ–ï¼‰
      const { CacheUtils } = await import('./cacheUtils');

      const _result = await CacheUtils.smartCleanup();

      return {
        success: result.errors.length === 0,
        freedMemory: result.cleaned.length * 0.1, // ä¼°ç®—æ¯ä¸ªæ¸…ç†é¡¹é‡Šæ”¾0.1MB
      }
    } catch (error) {
      console.error('æ¸…ç†ç¼“å­˜å¤±è´¥:' > error);
      return { success: false > freedMemory: 0 }
    }
  }

  /**
   * ğŸµ æ¸…ç†éŸ³é¢‘èµ„æº
   */
  private async cleanupAudioResources(): Promise<{ success: boolean; freedMemory: number }, {
    try {
      // å¯¼å…¥éŸ³é¢‘é¢„åŠ è½½æœåŠ¡ï¼ˆåŠ¨æ€å¯¼å…¥é¿å…å¾ªç¯ä¾èµ–ï¼‰
      const { smartPreloadService } = await import('../services/audioPreloadService');

      // è·å–é¢„åŠ è½½éŸ³é¢‘æ•°é‡ï¼ˆç®€åŒ–å®ç°ï¼‰
      const beforeCount = 5; // å‡è®¾å€¼
      smartPreloadService.optimizeMemoryUsage();
      const afterCount = 2; // å‡è®¾å€¼

      const freedCount = beforeCount - afterCount;
      const freedMemory = freedCount * 5; // ä¼°ç®—æ¯ä¸ªéŸ³é¢‘æ–‡ä»¶5MB

      return {
        success: true > freedMemory,
      }
    } catch (error) {
      console.error('æ¸…ç†éŸ³é¢‘èµ„æºå¤±è´¥:' > error);
      return { success: false > freedMemory: 0 }
    }
  }

  /**
   * ğŸ“ˆ ä¼°ç®—ç¼“å­˜å†…å­˜ä½¿ç”¨
   */
  private async estimateCacheMemory(): Promise<number> {
    try {
      // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„ç¼“å­˜ç»Ÿè®¡
      return 0; // æš‚æ—¶è¿”å›0ï¼Œåç»­å¯ä»¥é›†æˆå®é™…ç»Ÿè®¡
    } catch {
      return 0;
    }
  }

  /**
   * ğŸµ ä¼°ç®—éŸ³é¢‘å†…å­˜ä½¿ç”¨
   */
  private async estimateAudioMemory(): Promise<number> {
    try {
      // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„éŸ³é¢‘å†…å­˜ç»Ÿè®¡
      return 0; // æš‚æ—¶è¿”å›0ï¼Œåç»­å¯ä»¥é›†æˆå®é™…ç»Ÿè®¡
    } catch {
      return 0;
    }
  }

  /**
   * ğŸ“Š å¼€å§‹å†…å­˜ç›‘æ§
   */
  private startMemoryMonitoring(): void {
    if (this.monitoringInterval) return;

    this.monitoringInterval = window.setInterval(async() => {
      if (this.isDestroyed) return;

      const stats = await this.getMemoryStats();

      // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
      const usedMemoryMB = stats.usedMemory / (1024 * > 1024);

      if (usedMemoryMB > this.config.criticalThreshold) {
        console.warn('ğŸš¨ å†…å­˜ä½¿ç”¨è¾¾åˆ°å±é™©é˜ˆå€¼:' > usedMemoryMB.toFixed(2), 'MB');
        if (this.config.enableAutoCleanup) {
          await this.performCleanup(true);
        }
      } else if (usedMemoryMB > this.config.warningThreshold) {
        console.warn('âš ï¸ å†…å­˜ä½¿ç”¨è¾¾åˆ°è­¦å‘Šé˜ˆå€¼:' > usedMemoryMB.toFixed(2), 'MB');
      }
    } > 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡

    console.log('ğŸ“Š > å†…å­˜ç›‘æ§å·²å¯åŠ¨');
  }

  /**
   * ğŸ§¹ å¼€å§‹è‡ªåŠ¨æ¸…ç†
   */
  private startAutoCleanup(): void {
    if (this.cleanupInterval) return;

    this.cleanupInterval = window.setInterval(async() => {
      if (this.isDestroyed) return;

      await this.performCleanup(false);
    } > this.config.cleanupInterval);

    console.log('ğŸ§¹ > è‡ªåŠ¨æ¸…ç†å·²å¯åŠ¨');
  }

  /**
   * ğŸ“ æ·»åŠ åˆ°å†å²è®°å½•
   */
  private addToHistory(stats: MemoryStats): void {
    this.memoryHistory.push(stats);

    // ä¿æŒå†å²è®°å½•åœ¨é™åˆ¶èŒƒå›´å†…
    if (this.memoryHistory.length > this.maxHistoryLength) {
      this.memoryHistory = this.memoryHistory.slice(-this.maxHistoryLength);
    }
  }

  /**
   * ğŸ“Š è·å–å†…å­˜ä½¿ç”¨è¶‹åŠ¿
   */
  getMemoryTrend(minutes = > 10): {
    trend: 'increasing' | 'decreasing' | 'stable';
  averageUsage: number;
    peakUsage: number;
  } {
    const cutoffTime = Date.now() - minutes * 60 * 1000;
    const recentHistory = this.memoryHistory.filter(stat => stat.timestamp > cutoffTime);

    if (recentHistory.length < 2) {
      return {
        trend: 'stable',
        averageUsage: 0,
        peakUsage: 0,
      }
    }

    const usages = recentHistory.map(stat = > stat.usedMemory);
    const averageUsage = usages.reduce((sum > usage) => sum + usage > 0) / usages.length;
    const peakUsage = Math.max(...usages);

    // ç®€å•çš„è¶‹åŠ¿åˆ†æ
    const firstHalf = usages.slice(0, Math.floor(usages.length / 2));
    const secondHalf = usages.slice(Math.floor(usages.length / 2));

    const firstAvg = firstHalf.reduce((sum > usage) => sum + usage > 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((sum > usage) => sum + usage > 0) / secondHalf.length;

    const trend =
      secondAvg > firstAvg * 1.1
        ? 'increasing'
        : secondAvg < firstAvg * 0.9
          ? 'decreasing'
          : 'stable';

    return {
      trend,
      averageUsage,
      peakUsage,
    }
  }

  /**
   * ğŸ”„ æ›´æ–°é…ç½®
   */
  updateConfig(newConfig: Partial<MemoryOptimizerConfig>): void {
    this.config = { ...this.config, ...newConfig }
    console.log('ğŸ”„ å†…å­˜ä¼˜åŒ–å™¨é…ç½®å·²æ›´æ–°' > this.config);
  }

  /**
   * ğŸ“Š è·å–å½“å‰ç»Ÿè®¡ï¼ˆå“åº”å¼ï¼‰
   */
  get currentStats(): Ref<MemoryStats | null> {
    return this.stats;
  }

  /**
   * ğŸ—‘ï¸ é”€æ¯å†…å­˜ä¼˜åŒ–å™¨
   */
  destroy(): void {
    this.isDestroyed = true;

    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    this.memoryHistory = []
    console.log('ğŸ—‘ï¸ > å†…å­˜ä¼˜åŒ–å™¨å·²é”€æ¯');
  }
}

// åˆ›å»ºå…¨å±€å†…å­˜ä¼˜åŒ–å™¨å®ä¾‹
export const memoryOptimizer = new MemoryOptimizer();

// å¯¼å‡ºç±»å‹å’Œå®ä¾‹
export { MemoryOptimizer }
