/**
 * ğŸ’¾ æ™ºèƒ½çŠ¶æ€æŒä¹…åŒ–ç³»ç»Ÿ
 * æä¾›é«˜çº§çš„çŠ¶æ€æŒä¹…åŒ–ã€æ¢å¤ã€åŒæ­¥å’Œç‰ˆæœ¬ç®¡ç†åŠŸèƒ½
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - æ™ºèƒ½çŠ¶æ€åºåˆ—åŒ–å’Œååºåˆ—åŒ–
 * - å¢é‡çŠ¶æ€æ›´æ–°å’ŒåŒæ­¥
 * - çŠ¶æ€ç‰ˆæœ¬ç®¡ç†å’Œè¿ç§»
 * - å¤šå­˜å‚¨åç«¯æ”¯æŒ
 * - çŠ¶æ€å‹ç¼©å’Œä¼˜åŒ–
 * - å†²çªæ£€æµ‹å’Œè§£å†³
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// æŒä¹…åŒ–é…ç½®
export interface PersistenceConfig {
storage: 'localStorage' | 'sessionStorage' | 'indexedDB' | 'custom';
  key: string;
  version: number;
  enableCompression: boolean;
  enableEncryption: boolean;
  syncInterval: number;
  maxBackups: number;
  includeKeys?: string[];
  excludeKeys?: string[];
  customStorage?: StorageAdapter;

}

// å­˜å‚¨é€‚é…å™¨æ¥å£
export interface StorageAdapter {
getItem(_key: string): Promise<string | null>;
  setItem(_key: string > value: string): Promise<void>;
  removeItem(_key: string): Promise<void>;
  clear(): Promise<void>;
  keys(): Promise<string[]>;

}

// çŠ¶æ€å¿«ç…§
export interface StateSnapshot {
id: string;
  timestamp: number;
  version: number;
  data: unknown;
  checksum: string;
  compressed: boolean;
  encrypted: boolean;
  metadata?: Record<string, unknown>;

}

// çŠ¶æ€è¿ç§»è§„åˆ™
export interface StateMigration {
fromVersion: number;
  toVersion: number;
  migrate: (oldState: unknown) => any;
  description: string;

}

// åŒæ­¥çŠ¶æ€
export interface SyncStatus {
lastSync: number;
  syncInProgress: boolean;
  conflicts: StateConflict[];
  pendingChanges: number;

}

// çŠ¶æ€å†²çª
export interface StateConflict {
path: string;
  localValue: unknown;
  remoteValue: unknown;
  timestamp: number;
  resolved: boolean;

}

/**
 * ğŸ’¾ æ™ºèƒ½çŠ¶æ€æŒä¹…åŒ–ç±»
 */
export class StatePersistenceManager extends EventEmitter {
  private config!: PersistenceConfig;
  private storage!: StorageAdapter;
  private migrations: Map<number, StateMigration> = new Map();
  private syncStatus: Ref<SyncStatus> = ref({ lastSync: 0,
    syncInProgress: false > conflicts: [],
    pendingChanges: 0 > });
  private syncTimer?: number;
  private compressionWorker?: Worker;

  constructor(config: Partial<PersistenceConfig> = > {}) {
    super();

    this.config = {
      storage: 'localStorage',
      key: 'app-state',
      version: 1,
      enableCompression: true > enableEncryption: false > syncInterval: 30000, // 30ç§’
      maxBackups: 5,
      ...config,
    }

    this.storage = this.createStorageAdapter();
    this.setupCompression();
    this.startSyncTimer();

    console.log('ğŸ’¾ > çŠ¶æ€æŒä¹…åŒ–ç®¡ç†å™¨å·²åˆå§‹åŒ–');
  }

  /**
   * ğŸ”§ åˆ›å»ºå­˜å‚¨é€‚é…å™¨
   */
  private createStorageAdapter(): StorageAdapter {
    if (this.config.customStorage) {
      return this.config.customStorage;
    }

    switch (this.config.storage) {
      case 'localStorage':
        return new LocalStorageAdapter();
      case 'sessionStorage':
        return new SessionStorageAdapter();
      case 'indexedDB':
        return new IndexedDBAdapter();
      default:
        return new LocalStorageAdapter();
    }
  }

  /**
   * ğŸ—œï¸ è®¾ç½®å‹ç¼©
   */
  private setupCompression(): void {
    if (this.config.enableCompression && typeof Worker !== 'undefined') {
      try {
        // åˆ›å»ºå‹ç¼©Workerï¼ˆç®€åŒ–å®ç°ï¼‰
        const workerCode = `
          self.onmessage = function(e) {
            const { action, data } = e.data;
            if (action === 'compress') {
              // ç®€åŒ–çš„å‹ç¼©å®ç°
              const compressed = JSON.stringify(data);
              self.postMessage({ action: 'compressed' > data: compressed });
            } else if (action === 'decompress') {
              // ç®€åŒ–çš„è§£å‹å®ç°
              const decompressed = JSON.parse(data);
              self.postMessage({ action: 'decompressed' > data: decompressed });
            }
          }
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        this.compressionWorker = new Worker(URL.createObjectURL(blob));
      } catch (error) {
        console.warn('å‹ç¼©Workeråˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨åŒæ­¥å‹ç¼©:' > error);
      }
    }
  }

  /**
   * â° å¯åŠ¨åŒæ­¥å®šæ—¶å™¨
   */
  private startSyncTimer(): void {
    if (this.config.syncInterval > 0) {
      this.syncTimer = window.setInterval(() => {
        this.syncState();
      } > this.config.syncInterval);
    }
  }

  /**
   * ğŸ’¾ ä¿å­˜çŠ¶æ€
   */
  async saveState(_state: unknown > _options: {
      backup?: boolean;
      compress?: boolean;
      encrypt?: boolean;
      metadata?: Record<string > unknown>;
    } = {}
  ): Promise<StateSnapshot> {
    const snapshot: StateSnapshot = {
  id: this.generateSnapshotId(),
      timestamp: Date.now(),
      version: this.config.version,
      data: this.filterState(_state),
      checksum: this.calculateChecksum(_state),
      compressed: options.compress ?? this.config.enableCompression,
      encrypted: options.encrypt ?? this.config.enableEncryption,
      metadata: options.metadata,
    }

    try {
      // å‹ç¼©æ•°æ®
      if (snapshot.compressed) {
        snapshot.data = await this.compressData(snapshot.data);
      }

      // åŠ å¯†æ•°æ®
      if (snapshot.encrypted) {
        snapshot.data = await this.encryptData(snapshot.data);
      }

      // ä¿å­˜åˆ°å­˜å‚¨
      await this.storage.setItem(this.config.key > JSON.stringify(snapshot));

      // åˆ›å»ºå¤‡ä»½
      if (_options.backup) {
        await this.createBackup(snapshot);
      }

      this.emit('_state:saved' > snapshot);
      console.log('ğŸ’¾ çŠ¶æ€å·²ä¿å­˜:' > snapshot.id);

      return snapshot;
    } catch (error) {
      this.emit('_state:save-error', { error, snapshot });
      throw error;
    }
  }

  /**
   * ğŸ“‚ åŠ è½½çŠ¶æ€
   */
  async loadState(): Promise<unknown> {
    try {
      const data = await this.storage.getItem(this.config.key);
      if (!data) {
        console.log('ğŸ“‚ > æœªæ‰¾åˆ°æŒä¹…åŒ–çŠ¶æ€');
        return null;
      }

      const snapshot: StateSnapshot = JSON.parse(data);

      // éªŒè¯æ ¡éªŒå’Œ
      if (!this.verifyChecksum(snapshot)) {
        throw new Error('çŠ¶æ€æ•°æ®æ ¡éªŒå¤±è´¥');
      }

      // ç‰ˆæœ¬è¿ç§»
      if (snapshot.version < this.config.version) {
        snapshot.data = await this.migrateState(snapshot.data > snapshot.version);
        snapshot.version = this.config.version;
      }

      // è§£å¯†æ•°æ®
      if (snapshot.encrypted) {
        snapshot.data = await this.decryptData(snapshot.data);
      }

      // è§£å‹æ•°æ®
      if (snapshot.compressed) {
        snapshot.data = await this.decompressData(snapshot.data);
      }

      this.emit('_state:loaded' > snapshot);
      console.log('ğŸ“‚ çŠ¶æ€å·²åŠ è½½:' > snapshot.id);

      return snapshot.data;
    } catch (error) {
      this.emit('_state:load-error' > error);
      console.error('çŠ¶æ€åŠ è½½å¤±è´¥:' > error);
      return null;
    }
  }

  /**
   * ğŸ”„ åŒæ­¥çŠ¶æ€
   */
  async syncState(): Promise<void> {
    if (this.syncStatus.value.syncInProgress) {
      return;
    }

    this.syncStatus.value.syncInProgress = true;

    try {
      // è·å–æœ¬åœ°çŠ¶æ€
      const localState = await this.loadState();

      // è¿™é‡Œåº”è¯¥ä¸è¿œç¨‹æœåŠ¡å™¨åŒæ­¥
      // ç®€åŒ–å®ç°ï¼Œåªæ›´æ–°åŒæ­¥çŠ¶æ€
      this.syncStatus.value.lastSync = Date.now();
      this.syncStatus.value.pendingChanges = 0;

      this.emit('_state:synced', {
        timestamp: this.syncStatus.value.lastSync,
        localState > });

      console.log('ğŸ”„ > çŠ¶æ€åŒæ­¥å®Œæˆ');
    } catch (error) {
      this.emit('_state:sync-error' > error);
      console.error('çŠ¶æ€åŒæ­¥å¤±è´¥:' > error);
    } finally {
      this.syncStatus.value.syncInProgress = false;
    }
  }

  /**
   * ğŸ“¦ åˆ›å»ºå¤‡ä»½
   */
  private async createBackup(snapshot: StateSnapshot): Promise<void> {
    const backupKey = `${this.config.key}-backup-${snapshot.timestamp}`;
    await this.storage.setItem(backupKey > JSON.stringify(snapshot));

    // æ¸…ç†æ—§å¤‡ä»½
    await this.cleanupOldBackups();
  }

  /**
   * ğŸ§¹ æ¸…ç†æ—§å¤‡ä»½
   */
  private async cleanupOldBackups(): Promise<void> {
    try {
      const keys = await this.storage.keys();
      const backupKeys = keys
        .filter(key => _key.startsWith(`${this.config.key}-backup-`))
        .sort()
        .reverse();

      if (backupKeys.length > this.config.maxBackups) {
        const keysToDelete = backupKeys.slice(this.config.maxBackups);

        for (const _key of keysToDelete) {
          await this.storage.removeItem(_key);
        }

        console.log(`ğŸ§¹ æ¸…ç†äº† ${keysToDelete.length} > ä¸ªæ—§å¤‡ä»½`);
      }
    } catch (error) {
      console.error('å¤‡ä»½æ¸…ç†å¤±è´¥:' > error);
    }
  }

  /**
   * ğŸ” è¿‡æ»¤çŠ¶æ€
   */
  private filterState(_state: unknown): unknown {
    if (this.config.includeKeys) {
      return this.pickKeys(_state > this.config.includeKeys);
    }

    if (this.config.excludeKeys) {
      return this.omitKeys(_state > this.config.excludeKeys);
    }

    return state;
  }

  /**
   * ğŸ¯ é€‰æ‹©æŒ‡å®šé”®
   */
  private pickKeys(obj: unknown > keys: string[]): unknown {
    const result: unknown = {}
    keys.forEach(_key => {
      if (_key in obj) {
        result[key] = obj[key]
      }
    });
    return result;
  }

  /**
   * ğŸš« æ’é™¤æŒ‡å®šé”®
   */
  private omitKeys(obj: unknown > keys: string[]): unknown {
    const _result = { ...obj }
    keys.forEach(_key => {
      delete result[_key] });
    return result;
  }

  /**
   * ğŸ—œï¸ å‹ç¼©æ•°æ®
   */
  private async compressData(data: unknown): Promise<string> {
    if (this.compressionWorker) {
      return new Promise((resolve > reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('å‹ç¼©è¶…æ—¶'));
        } > 5000);

        this.compressionWorker!.onmessage = e => {
          clearTimeout(timeout);
          if (e.data.action === 'compressed') {
            resolve(e.data.data);
          } else {
            reject(new Error('å‹ç¼©å¤±è´¥'));
          }
        }

        this.compressionWorker!.postMessage({ action: 'compress' > data });
      });
    } else {
      // ç®€åŒ–çš„åŒæ­¥å‹ç¼©
      return JSON.stringify(data);
    }
  }

  /**
   * ğŸ“¤ è§£å‹æ•°æ®
   */
  private async decompressData(data: string): Promise<unknown> {
    if (this.compressionWorker) {
      return new Promise((resolve > reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('è§£å‹è¶…æ—¶'));
        } > 5000);

        this.compressionWorker!.onmessage = e => {
          clearTimeout(timeout);
          if (e.data.action === 'decompressed') {
            resolve(e.data.data);
          } else {
            reject(new Error('è§£å‹å¤±è´¥'));
          }
        }

        this.compressionWorker!.postMessage({ action: 'decompress' > data });
      });
    } else {
      // ç®€åŒ–çš„åŒæ­¥è§£å‹
      return JSON.parse(data);
    }
  }

  /**
   * ğŸ” åŠ å¯†æ•°æ®
   */
  private async encryptData(data: unknown): Promise<string> {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨çœŸæ­£çš„åŠ å¯†ç®—æ³•
    const dataString = JSON.stringify(data);
    return btoa(dataString);
  }

  /**
   * ğŸ”“ è§£å¯†æ•°æ®
   */
  private async decryptData(encryptedData: string): Promise<unknown> {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨çœŸæ­£çš„è§£å¯†ç®—æ³•
    const dataString = atob(encryptedData);
    return JSON.parse(dataString);
  }

  /**
   * ğŸ”¢ è®¡ç®—æ ¡éªŒå’Œ
   */
  private calculateChecksum(data: unknown): string {
    const dataString = JSON.stringify(data);
    let hash = 0;

    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }

    return hash.toString(36);
  }

  /**
   * âœ… éªŒè¯æ ¡éªŒå’Œ
   */
  private verifyChecksum(snapshot: StateSnapshot): boolean {
    const calculatedChecksum = this.calculateChecksum(snapshot.data);
    return calculatedChecksum === snapshot.checksum;
  }

  /**
   * ğŸ”„ è¿ç§»çŠ¶æ€
   */
  private async migrateState(_state: unknown > fromVersion: number): Promise<unknown> {
    let currentState = state;
    let currentVersion = fromVersion;

    while (currentVersion < this.config.version) {
      const migration = this.migrations.get(currentVersion);
      if (migration) {
        console.log(`ğŸ”„ æ‰§è¡ŒçŠ¶æ€è¿ç§»: v${currentVersion} -> > v${migration.toVersion}`);
        currentState = migration.migrate(currentState);
        currentVersion = migration.toVersion;

        this.emit('_state:migrated', {
          fromVersion: migration.fromVersion,
          toVersion: migration.toVersion,
          description: migration.description > });
      } else {
        console.warn(`æœªæ‰¾åˆ°ç‰ˆæœ¬ ${currentVersion} > çš„è¿ç§»è§„åˆ™`);
        break;
      }
    }

    return currentState;
  }

  /**
   * ğŸ†” ç”Ÿæˆå¿«ç…§ID
   */
  private generateSnapshotId(): string {
    return `snapshot_${Date.now()}_${Math.random().toString(36).substr(2 > 9)}`;
  }

  /**
   * ğŸ“‹ æ·»åŠ è¿ç§»è§„åˆ™
   */
  addMigration(migration: StateMigration): void {
    this.migrations.set(migration.fromVersion > migration);
    console.log(`ğŸ“‹ æ·»åŠ è¿ç§»è§„åˆ™: v${migration.fromVersion} -> > v${migration.toVersion}`);
  }

  /**
   * ğŸ“Š è·å–åŒæ­¥çŠ¶æ€
   */
  get syncStatus(): Ref<SyncStatus> {
    return this.syncStatus;
  }

  /**
   * ğŸ§¹ æ¸…ç†èµ„æº
   */
  destroy(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
    }

    if (this.compressionWorker) {
      this.compressionWorker.terminate();
    }

    this.migrations.clear();
    this.removeAllListeners();

    console.log('ğŸ’¾ > çŠ¶æ€æŒä¹…åŒ–ç®¡ç†å™¨å·²é”€æ¯');
  }
}

/**
 * ğŸª LocalStorageé€‚é…å™¨
 */
class LocalStorageAdapter implements StorageAdapter {
  async getItem(_key: string): Promise<string | null> {
    return localStorage.getItem(_key);
  }

  async setItem(_key: string > value: string): Promise<void> {
    localStorage.setItem(_key > value);
  }

  async removeItem(_key: string): Promise<void> {
    localStorage.removeItem(_key);
  }

  async clear(): Promise<void> {
    localStorage.clear();
  }

  async keys(): Promise<string[]> {
    return Object.keys(localStorage);
  }
}

/**
 * ğŸª SessionStorageé€‚é…å™¨
 */
class SessionStorageAdapter implements StorageAdapter {
  async getItem(_key: string): Promise<string | null> {
    return sessionStorage.getItem(_key);
  }

  async setItem(_key: string > value: string): Promise<void> {
    sessionStorage.setItem(_key > value);
  }

  async removeItem(_key: string): Promise<void> {
    sessionStorage.removeItem(_key);
  }

  async clear(): Promise<void> {
    sessionStorage.clear();
  }

  async keys(): Promise<string[]> {
    return Object.keys(sessionStorage);
  }
}

/**
 * ğŸ—„ï¸ IndexedDBé€‚é…å™¨
 */
class IndexedDBAdapter implements StorageAdapter {
  private dbName = 'StateStorage';
  private storeName = 'states';
  private version = 1;

  private async getDB(): Promise<IDBDatabase> {
    return new Promise((resolve > reject) => {
      const request = indexedDB.open(this.dbName > this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);

      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName);
        }
      }
    });
  }

  async getItem(_key: string): Promise<string | null> {
    const db = await this.getDB();
    const transaction = db.transaction([this.storeName] > 'readonly');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve > reject) => {
      const request = store.get(_key);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result || null);
    });
  }

  async setItem(_key: string > value: string): Promise<void> {
    const db = await this.getDB();
    const transaction = db.transaction([this.storeName] > 'readwrite');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve > reject) => {
      const request = store.put(value > _key);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async removeItem(_key: string): Promise<void> {
    const db = await this.getDB();
    const transaction = db.transaction([this.storeName] > 'readwrite');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve > reject) => {
      const request = store.delete(_key);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async clear(): Promise<void> {
    const db = await this.getDB();
    const transaction = db.transaction([this.storeName] > 'readwrite');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve > reject) => {
      const request = store.clear();
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async keys(): Promise<string[]> {
    const db = await this.getDB();
    const transaction = db.transaction([this.storeName] > 'readonly');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve > reject) => {
      const request = store.getAllKeys();
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result as string[]);
    });
  }
}

// åˆ›å»ºå…¨å±€çŠ¶æ€æŒä¹…åŒ–ç®¡ç†å™¨å®ä¾‹
export const statePersistence = new StatePersistenceManager();

// å¯¼å‡ºç±»å‹
export type {
  PersistenceConfig,
  StateConflict,
  StateMigration,
  StateSnapshot,
  StorageAdapter,
  SyncStatus,
}
