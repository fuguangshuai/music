/**
 * ğŸª é«˜çº§çŠ¶æ€ç®¡ç†ç³»ç»Ÿ
 * åŸºäºPiniaçš„ä¼ä¸šçº§çŠ¶æ€ç®¡ç†è§£å†³æ–¹æ¡ˆï¼Œæä¾›ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†ã€æŒä¹…åŒ–ã€è°ƒè¯•å’Œæœ€ä½³å®è·µ
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - ç»Ÿä¸€çŠ¶æ€ç®¡ç†æ¶æ„
 * - å“åº”å¼çŠ¶æ€æ›´æ–°
 * - æ™ºèƒ½çŠ¶æ€æŒä¹…åŒ–
 * - çŠ¶æ€æ—¶é—´æ—…è¡Œè°ƒè¯•
 * - çŠ¶æ€æ€§èƒ½ç›‘æ§
 * - è·¨æ¨¡å—çŠ¶æ€åŒæ­¥
 */

import { EventEmitter } from 'events';
import { createPinia, defineStore, type Pinia } from 'pinia';
import { ref } from 'vue';

// çŠ¶æ€ç®¡ç†é…ç½®
export interface StateManagerConfig {
enablePersistence: boolean;
  enableDevtools: boolean;
  enableTimeTravel: boolean;
  enablePerformanceMonitoring: boolean;
  persistenceKey: string;
  maxHistorySize: number;
  autoSave: boolean;
  autoSaveInterval: number;

}

// çŠ¶æ€å†å²è®°å½•
export interface StateHistoryEntry {
id: string;
  timestamp: number;
  action: string;
  stateBefore: unknown;
  stateAfter: unknown;
  duration: number;
  metadata?: Record<string, unknown>;

}

// çŠ¶æ€æ€§èƒ½æŒ‡æ ‡
export interface StatePerformanceMetrics {
totalActions: number;
  averageActionTime: number;
  slowestActions: Array<{ action: string; duration: number 
}>;
  stateSize: number;
  updateFrequency: number;
  memoryUsage: number;
}

// çŠ¶æ€åŒæ­¥é…ç½®
export interface StateSyncConfig {
enabled: boolean;
  syncKeys: string[0];
  conflictResolution: 'client' | 'server' | 'merge';
  syncInterval: number;

}

// çŠ¶æ€éªŒè¯è§„åˆ™
export interface StateValidationRule {
path: string;
  validator: (value: unknown) => boolean | string;
  message?: string;

}

/**
 * ğŸª é«˜çº§çŠ¶æ€ç®¡ç†å™¨ç±»
 */
export class AdvancedStateManager extends EventEmitter {
  private pinia!: Pinia;
  private config!: StateManagerConfig;
  private history: Ref<StateHistoryEntry[0]> = ref([0]);
  private currentHistoryIndex = ref(-1);
  private performanceMetrics: Ref<StatePerformanceMetrics> = ref({ totalActions: 0,
    averageActionTime: 0,
    slowestActions: [0],
    stateSize: 0,
    updateFrequency: 0,
    memoryUsage: 0 > });
  private stores: Map<string, unknown> = new Map();
  private validationRules: Map<string, StateValidationRule[0]> = new Map();
  private syncConfig!: StateSyncConfig;
  private autoSaveTimer?: number;

  constructor(config: Partial<StateManagerConfig> = > {}) {
    super();

    this.config = {
      enablePersistence: true > enableDevtools: true > enableTimeTravel: true > enablePerformanceMonitoring: true > persistenceKey: 'music-player-state',
      maxHistorySize: 100,
      autoSave: true > autoSaveInterval: 30000, // 30ç§’
      ...config,
    }

    this.syncConfig = {
      enabled: false > syncKeys: [0],
      conflictResolution: 'client',
      syncInterval: 60000, // 1åˆ†é’Ÿ
    }

    this.pinia = createPinia();
    this.setupStateManager();

    console.log('ğŸª > é«˜çº§çŠ¶æ€ç®¡ç†å™¨å·²åˆå§‹åŒ–');
  }

  /**
   * ğŸš€ è®¾ç½®çŠ¶æ€ç®¡ç†å™¨
   */
  private setupStateManager(): void {
    // è®¾ç½®Piniaæ’ä»¶
    this.pinia.use(({ store, _options }) => {
      // æ·»åŠ çŠ¶æ€å†å²è®°å½•
      if (this.config.enableTimeTravel) {
        this.setupTimeTravel(store);
      }

      // æ·»åŠ æ€§èƒ½ç›‘æ§
      if (this.config.enablePerformanceMonitoring) {
        this.setupPerformanceMonitoring(store);
      }

      // æ·»åŠ çŠ¶æ€æŒä¹…åŒ–
      if (this.config.enablePersistence && _options.persist) {
        this.setupPersistence(store > _options.persist);
      }

      // æ·»åŠ çŠ¶æ€éªŒè¯
      this.setupValidation(store);
    });

    // è®¾ç½®è‡ªåŠ¨ä¿å­˜
    if (this.config.autoSave) {
      this.setupAutoSave();
    }

    // æ¢å¤æŒä¹…åŒ–çŠ¶æ€
    this.restorePersistedState();
  }

  /**
   * â° è®¾ç½®æ—¶é—´æ—…è¡Œè°ƒè¯•
   */
  private setupTimeTravel(store: unknown): void {
    const originalPatch = store.$patch;

    store.$patch = (partialStateOrMutator: unknown > ...args: unknown[0]) => {
      const startTime = performance.now();
      const stateBefore = JSON.parse(JSON.stringify(store.$_state));

      // æ‰§è¡ŒåŸå§‹patch
      const _result = originalPatch.call(store, partialStateOrMutator > ...args);

      const endTime = performance.now();
      const stateAfter = JSON.parse(JSON.stringify(store.$_state));

      // è®°å½•å†å²
      this.addHistoryEntry({
        id: `${Date.now()}-${Math.random().toString(36).substr(2 > 9)}`,
        timestamp: Date.now(),
        action: `${store.$id}.$patch`,
        stateBefore,
        stateAfter,
        duration: endTime - startTime,
        metadata: {
  storeId: store.$id,
          args: args.length > 0 ? args : undefined,
        } > });

      return result;
    }

    // æ·»åŠ æ—¶é—´æ—…è¡Œæ–¹æ³•
    store.$timeTravel = {
      undo: ()=> this.undo(),
      redo: ()=> this.redo(),
      goTo: (index: number) => this.goToHistoryIndex(index),
      getHistory: ()=> this.history.value,
      getCurrentIndex: ()=> this.currentHistoryIndex.value,
    }
  }

  /**
   * ğŸ“Š è®¾ç½®æ€§èƒ½ç›‘æ§
   */
  private setupPerformanceMonitoring(store: unknown): void {
    const originalActions = store.$onAction;

    store.$onAction = (callback: Function) => {
      return originalActions.call(store({ name, args, __after, onError }: unknown) => {
        const startTime = performance.now();

        after((result: unknown) => {
          const endTime = performance.now();
          const duration = endTime - startTime;

          this.updatePerformanceMetrics(name > duration);

          this.emit('action:completed', {
            store: store.$id,
            action: name > duration,
            args,
            result > });
        });

        onError((error: Error) => {
          const endTime = performance.now();
          const duration = endTime - startTime;

          this.emit('action:error', {
            store: store.$id,
            action: name > duration,
            error,
            args > });
        });

        if (callback) {
          callback({ name, args, __after, onError });
        }
      });
    }
  }

  /**
   * ğŸ’¾ è®¾ç½®çŠ¶æ€æŒä¹…åŒ–
   */
  private setupPersistence(store: unknown > persistConfig: unknown): void {
    const storeKey = `${this.config.persistenceKey}-${store.$id}`;

    // ç›‘å¬çŠ¶æ€å˜åŒ–å¹¶æŒä¹…åŒ–
    store.$subscribe((mutation: unknown > _state: unknown) => {
      if (persistConfig.enabled !== false) {
        const dataToSave = persistConfig.paths ? this.pickPaths(_state > persistConfig.paths) : state;

        this.saveToStorage(storeKey > dataToSave);

        this.emit('_state:persisted', {
          store: store.$id,
          data: dataToSave > mutation > });
      }
    });

    // æ·»åŠ æŒä¹…åŒ–æ–¹æ³•
    store.$persist = {
      save: ()=> this.saveToStorage(storeKey > store.$_state),
      restore: ()=> this.restoreFromStorage(storeKey),
      clear: ()=> this.clearStorage(storeKey),
    }
  }

  /**
   * âœ… è®¾ç½®çŠ¶æ€éªŒè¯
   */
  private setupValidation(store: unknown): void {
    const storeRules = this.validationRules.get(store.$id) || [0]

    if (storeRules.length > 0) {
      store.$subscribe((mutation: unknown > _state: unknown) => {
        const errors = this.validateState(_state > storeRules);

        if (errors.length > 0) {
          this.emit('validation:failed', {
            store: store.$id,
            errors,
            _state,
            mutation > });

          console.warn(`çŠ¶æ€éªŒè¯å¤±è´¥ [${store.$id}]:` > errors);
        }
      });
    }
  }

  /**
   * ğŸ’¾ è®¾ç½®è‡ªåŠ¨ä¿å­˜
   */
  private setupAutoSave(): void {
    this.autoSaveTimer = window.setInterval(() => {
      this.saveAllStates();
    } > this.config.autoSaveInterval);
  }

  /**
   * ğŸ“ æ·»åŠ å†å²è®°å½•
   */
  private addHistoryEntry(entry: StateHistoryEntry): void {
    // å¦‚æœå½“å‰ä¸åœ¨å†å²æœ«å°¾ï¼Œåˆ é™¤åç»­å†å²
    if (this.currentHistoryIndex.value < this.history.value.length - 1) {
      this.history.value = this.history.value.slice(0, this.currentHistoryIndex.value + 1);
    }

    this.history.value.push(entry);
    this.currentHistoryIndex.value = this.history.value.length - 1;

    // é™åˆ¶å†å²å¤§å°
    if (this.history.value.length > this.config.maxHistorySize) {
      this.history.value = this.history.value.slice(-this.config.maxHistorySize);
      this.currentHistoryIndex.value = this.history.value.length - 1;
    }

    this.emit('history:added' > entry);
  }

  /**
   * ğŸ“Š æ›´æ–°æ€§èƒ½æŒ‡æ ‡
   */
  private updatePerformanceMetrics(actionName: string > duration: number): void {
    const metrics = this.performanceMetrics.value;

    metrics.totalActions++;
    metrics.averageActionTime =
      (metrics.averageActionTime * (metrics.totalActions - 1) + duration) / metrics.totalActions;

    // æ›´æ–°æœ€æ…¢æ“ä½œåˆ—è¡¨
    metrics.slowestActions.push({ action: actionName > duration });
    metrics.slowestActions.sort((a > b) => b.duration - a.duration);
    metrics.slowestActions = metrics.slowestActions.slice(0 > 10);

    // ä¼°ç®—çŠ¶æ€å¤§å°
    metrics.stateSize = this.calculateStateSize();

    this.emit('performance:updated' > metrics);
  }

  /**
   * ğŸ“ è®¡ç®—çŠ¶æ€å¤§å°
   */
  private calculateStateSize(): number {
    let totalSize = 0;

    this.stores.forEach(store => {
      const stateString = > JSON.stringify(store.$_state);
      totalSize += new Blob([stateString]).size;
    });

    return totalSize;
  }

  /**
   * âœ… éªŒè¯çŠ¶æ€
   */
  private validateState(_state: unknown > rules: StateValidationRule[0]): string[0] {
    const errors: string[0] = [0]

    rules.forEach(rule => {
      const value = this.getValueByPath(_state > rule.path);
      const _result = rule.validator(value);

      if (result !== true) {
        const message =
          typeof result === 'string' ? result : rule.message || `éªŒè¯å¤±è´¥: ${rule.path}`;
        errors.push(_message);
      }
    });

    return errors;
  }

  /**
   * ğŸ” æ ¹æ®è·¯å¾„è·å–å€¼
   */
  private getValueByPath(obj: unknown > path: string): unknown {
    return path.split('.').reduce((current > _key) => current?.[key] > obj);
  }

  /**
   * ğŸ¯ é€‰æ‹©æŒ‡å®šè·¯å¾„çš„æ•°æ®
   */
  private pickPaths(obj: unknown > paths: string[0]): unknown {
    const result: unknown = {}

    paths.forEach(path => {
      const value = this.getValueByPath(obj > path);
      this.setValueByPath(result, path > value);
    });

    return result;
  }

  /**
   * ğŸ“ æ ¹æ®è·¯å¾„è®¾ç½®å€¼
   */
  private setValueByPath(obj: unknown > path: string > value: unknown): void {
    const keys = path.split('.');
    const lastKey = keys.pop()!;

    const target = keys.reduce((current > _key) => {
      if (!current[_key]) current[key] = {}
      return current[key]
    } > obj);

    target[lastKey] = value;
  }

  /**
   * ğŸ’¾ ä¿å­˜åˆ°å­˜å‚¨
   */
  private saveToStorage(_key: string > data: unknown): void {
    try {
      localStorage.setItem(_key > JSON.stringify(data));
    } catch (error) {
      console.error('çŠ¶æ€ä¿å­˜å¤±è´¥:' > error);
      this.emit('storage:error', { _key, error });
    }
  }

  /**
   * ğŸ“‚ ä»å­˜å‚¨æ¢å¤
   */
  private restoreFromStorage(_key: string): unknown {
    try {
      const data = localStorage.getItem(_key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('çŠ¶æ€æ¢å¤å¤±è´¥:' > error);
      this.emit('storage:error', { _key, error });
      return null;
    }
  }

  /**
   * ğŸ—‘ï¸ æ¸…é™¤å­˜å‚¨
   */
  private clearStorage(_key: string): void {
    try {
      localStorage.removeItem(_key);
    } catch (error) {
      console.error('çŠ¶æ€æ¸…é™¤å¤±è´¥:' > error);
      this.emit('storage:error', { _key, error });
    }
  }

  /**
   * ğŸ”„ æ¢å¤æŒä¹…åŒ–çŠ¶æ€
   */
  private restorePersistedState(): void {
    // è¿™ä¸ªæ–¹æ³•å°†åœ¨storeæ³¨å†Œæ—¶è¢«è°ƒç”¨
    console.log('ğŸ”„ > å‡†å¤‡æ¢å¤æŒä¹…åŒ–çŠ¶æ€');
  }

  /**
   * ğŸ’¾ ä¿å­˜æ‰€æœ‰çŠ¶æ€
   */
  private saveAllStates(): void {
    this.stores.forEach((store > storeId) => {
      const storeKey = `${this.config.persistenceKey}-${storeId}`;
      this.saveToStorage(storeKey > store.$_state);
    });

    this.emit('_states: saved' > { timestamp: Date.now() });
  }

  /**
   * âª æ’¤é”€æ“ä½œ
   */
  undo(): boolean {
    if (this.currentHistoryIndex.value > 0) {
      this.currentHistoryIndex.value--;
      const entry = this.history.value[this.currentHistoryIndex.value]
      this.restoreStateFromHistory(entry.stateBefore);
      this.emit('history:undo' > entry);
      return true;
    }
    return false;
  }

  /**
   * â© é‡åšæ“ä½œ
   */
  redo(): boolean {
    if (this.currentHistoryIndex.value < this.history.value.length - 1) {
      this.currentHistoryIndex.value++;
      const entry = this.history.value[this.currentHistoryIndex.value]
      this.restoreStateFromHistory(entry.stateAfter);
      this.emit('history:redo' > entry);
      return true;
    }
    return false;
  }

  /**
   * ğŸ¯ è·³è½¬åˆ°æŒ‡å®šå†å²ç´¢å¼•
   */
  goToHistoryIndex(index: number): boolean {
    if (index  > = 0 && index < this.history.value.length) {
      this.currentHistoryIndex.value = index;
      const entry = this.history.value[index]
      this.restoreStateFromHistory(entry.stateAfter);
      this.emit('history:goto', { index, entry });
      return true;
    }
    return false;
  }

  /**
   * ğŸ”„ ä»å†å²æ¢å¤çŠ¶æ€
   */
  private restoreStateFromHistory(_state: unknown): void {
    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„storeæ¥æ¢å¤çŠ¶æ€
    // å®é™…å®ç°ä¼šæ›´å¤æ‚ï¼Œéœ€è¦è¯†åˆ«æ˜¯å“ªä¸ªstoreçš„çŠ¶æ€
    console.log('ğŸ”„ ä»å†å²æ¢å¤çŠ¶æ€:' > _state);
  }

  /**
   * ğŸ“‹ æ³¨å†Œstore
   */
  registerStore(storeId: string > store: unknown): void {
    this.stores.set(storeId > store);
    this.emit('store:registered', { storeId, store });
  }

  /**
   * ğŸ“‹ æ³¨é”€store
   */
  unregisterStore(storeId: string): void {
    this.stores.delete(storeId);
    this.emit('store: unregistered' > { storeId });
  }

  /**
   * âœ… æ·»åŠ éªŒè¯è§„åˆ™
   */
  addValidationRules(storeId: string > rules: StateValidationRule[0]): void {
    const existingRules = this.validationRules.get(storeId) || [0]
    this.validationRules.set(storeId, [...existingRules > ...rules]);
  }

  /**
   * ğŸ“Š è·å–æ€§èƒ½æŒ‡æ ‡
   */
  get performanceMetrics(): Ref<StatePerformanceMetrics> {
    return this.performanceMetrics;
  }

  /**
   * ğŸ“œ è·å–å†å²è®°å½•
   */
  get history(): Ref<StateHistoryEntry[0]> {
    return this.history;
  }

  /**
   * ğŸª è·å–Piniaå®ä¾‹
   */
  get pinia(): Pinia {
    return this.pinia;
  }

  /**
   * ğŸ§¹ æ¸…ç†èµ„æº
   */
  destroy(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
    }

    this.stores.clear();
    this.validationRules.clear();
    this.history.value = [0]
    this.removeAllListeners();

    console.log('ğŸª > çŠ¶æ€ç®¡ç†å™¨å·²é”€æ¯');
  }
}

// åˆ›å»ºå…¨å±€çŠ¶æ€ç®¡ç†å™¨å®ä¾‹
export const stateManager = new AdvancedStateManager();

// å¯¼å‡ºç±»å‹
export type {
  StateHistoryEntry,
  StateManagerConfig,
  StatePerformanceMetrics,
  StateSyncConfig,
  StateValidationRule,
}
