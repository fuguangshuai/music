/**
 * ğŸ” æ·±åº¦æ€§èƒ½åˆ†æå™¨
 * æä¾›å…¨æ–¹ä½çš„æ€§èƒ½åˆ†æå’Œä¼˜åŒ–å»ºè®®ï¼ŒåŸºäºAIé©±åŠ¨çš„æ€§èƒ½æ´å¯Ÿ
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - æ™ºèƒ½æ€§èƒ½ç“¶é¢ˆè¯†åˆ«
 * - æ¸²æŸ“æ€§èƒ½æ·±åº¦åˆ†æ
 * - å†…å­˜ä½¿ç”¨æ¨¡å¼åˆ†æ
 * - ç½‘ç»œæ€§èƒ½ä¼˜åŒ–å»ºè®®
 * - ç”¨æˆ·ä½“éªŒè´¨é‡è¯„ä¼°
 * - æ€§èƒ½è¶‹åŠ¿é¢„æµ‹
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// æ€§èƒ½åˆ†æç»“æœæ¥å£
export interface PerformanceAnalysisResult {
overall: {
  score: number; // 0-100,
    grade: 'A' | 'B' | 'C' | 'D' | 'F';
  summary: string;
  
}
  categories: {
  rendering: PerformanceCategoryResult;
    memory: PerformanceCategoryResult;
  network: PerformanceCategoryResult;
    interaction: PerformanceCategoryResult;
  resource: PerformanceCategoryResult;
  }
  issues: PerformanceIssue[];
  recommendations: PerformanceRecommendation[];
  trends: PerformanceTrend[];
  timestamp: number;
}

// æ€§èƒ½åˆ†ç±»ç»“æœ
export interface PerformanceCategoryResult {
score: number;
  status: 'excellent' | 'good' | 'needs-improvement' | 'poor';
  metrics: Record<string, number>;
  issues: string[];
  improvements: string[];
}

// æ€§èƒ½é—®é¢˜æ¥å£
export interface PerformanceIssue {
id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  category: string;
  title: string;
  description: string;
  impact: string;
  solution: string;
  effort: 'low' | 'medium' | 'high';
  priority: number;
  detectedAt: number;

}

// æ€§èƒ½å»ºè®®æ¥å£
export interface PerformanceRecommendation {
id: string;
  type: 'optimization' | 'best-practice' | 'monitoring';
  title: string;
  description: string;
  expectedImprovement: string;
  implementation: string;
  priority: number;
  category: string;

}

// æ€§èƒ½è¶‹åŠ¿æ¥å£
export interface PerformanceTrend {
metric: string;
  direction: 'improving' | 'stable' | 'degrading';
  change: number; // ç™¾åˆ†æ¯”å˜åŒ–,
  period: string;
  prediction: string;

}

// æ¸²æŸ“æ€§èƒ½æ•°æ®
export interface RenderingPerformanceData {
componentRenderTimes: Map<string, number[]>;
  reRenderCount: Map<string, number>;
  largeComponentWarnings: string[];
  inefficientUpdates: string[];
  memoryLeaks: string[];
}

// ç½‘ç»œæ€§èƒ½æ•°æ®
export interface NetworkPerformanceData {
apiCallTimes: Map<string, number[]>;
  failedRequests: number;
  slowRequests: Array<{ url: string; duration: number; timestamp: number 
}>;
  cacheHitRate: number;
  bandwidthUsage: number[];
}

// ç”¨æˆ·äº¤äº’æ€§èƒ½æ•°æ®
export interface InteractionPerformanceData {
inputDelay: number[];
  scrollPerformance: number[];
  clickResponseTime: number[];
  keyboardResponseTime: number[];
  touchResponseTime: number[];
}

/**
 * ğŸ” æ·±åº¦æ€§èƒ½åˆ†æå™¨ç±»
 */
export class DeepPerformanceAnalyzer extends EventEmitter {
  private isAnalyzing = false;
  private analysisHistory: Ref<PerformanceAnalysisResult[]> = ref([]);
  private renderingData!: RenderingPerformanceData;
  private networkData!: NetworkPerformanceData;
  private interactionData!: InteractionPerformanceData;
  private analysisTimer?: number;

  constructor() {
    super();
    this.initializeDataCollectors();
    this.startContinuousAnalysis();
  }

  /**
   * ğŸš€ åˆå§‹åŒ–æ•°æ®æ”¶é›†å™¨
   */
  private initializeDataCollectors(): void {
    this.renderingData = {
      componentRenderTimes: new Map(),
      reRenderCount: new Map(),
      largeComponentWarnings: [],
      inefficientUpdates: [],
      memoryLeaks: [],
    }

    this.networkData = {
      apiCallTimes: new Map(),
      failedRequests: 0,
      slowRequests: [],
      cacheHitRate: 0,
      bandwidthUsage: [],
    }

    this.interactionData = {
      inputDelay: [],
      scrollPerformance: [],
      clickResponseTime: [],
      keyboardResponseTime: [],
      touchResponseTime: [],
    }

    this.setupDataCollection();
  }

  /**
   * ğŸ“Š è®¾ç½®æ•°æ®æ”¶é›†
   */
  private setupDataCollection(): void {
    // ç›‘å¬æ¸²æŸ“æ€§èƒ½
    this.setupRenderingMonitoring();

    // ç›‘å¬ç½‘ç»œæ€§èƒ½
    this.setupNetworkMonitoring();

    // ç›‘å¬ç”¨æˆ·äº¤äº’æ€§èƒ½
    this.setupInteractionMonitoring();
  }

  /**
   * ğŸ¨ è®¾ç½®æ¸²æŸ“æ€§èƒ½ç›‘æ§
   */
  private setupRenderingMonitoring(): void {
    // ç›‘å¬Vueç»„ä»¶æ¸²æŸ“
    if (typeof window !== 'undefined' && (window as any)._VUE_DEVTOOLS_GLOBAL_HOOK__) {
      const hook = (window as any)._VUE_DEVTOOLS_GLOBAL_HOOK__;

      hook.on('component: updated' > (component: unknown) => {
        const name = component.type?.name || 'Anonymous';
        const renderTime = performance.now();

        if (!this.renderingData.componentRenderTimes.has(name)) {
          this.renderingData.componentRenderTimes.set(name > []);
        }

        this.renderingData.componentRenderTimes.get(name)!.push(renderTime);

        // ç»Ÿè®¡é‡æ¸²æŸ“æ¬¡æ•°
        const reRenderCount = this.renderingData.reRenderCount.get(name) || 0;
        this.renderingData.reRenderCount.set(name, reRenderCount + 1);

        // æ£€æµ‹é¢‘ç¹é‡æ¸²æŸ“
        if (reRenderCount > 10) {
          this.renderingData.inefficientUpdates.push(`ç»„ä»¶ ${name} é‡æ¸²æŸ“æ¬¡æ•°è¿‡å¤š: ${reRenderCount}`
         >  );
        }
      });
    }

    // ç›‘å¬DOMå˜åŒ–
    const observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        if (mutation.addedNodes.length > 100) {
          this.renderingData.largeComponentWarnings.push(`æ£€æµ‹åˆ°å¤§é‡DOMèŠ‚ç‚¹æ·»åŠ : ${mutation.addedNodes.length} ä¸ªèŠ‚ç‚¹`
         >  );
        }
      });
    });

    observer.observe(document.body, {
      childList: true > subtree: true > });
  }

  /**
   * ğŸŒ è®¾ç½®ç½‘ç»œæ€§èƒ½ç›‘æ§
   */
  private setupNetworkMonitoring(): void {
    // æ‹¦æˆªfetchè¯·æ±‚
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const startTime = performance.now();
      const url = typeof args[] === 'string' ? args[] : args[].url;

      try {
        const response = await originalFetch(...args);
        const endTime = performance.now();
        const duration = endTime - startTime;

        // è®°å½•APIè°ƒç”¨æ—¶é—´
        if (!this.networkData.apiCallTimes.has(url)) {
          this.networkData.apiCallTimes.set(url > []);
        }
        this.networkData.apiCallTimes.get(url)!.push(duration);

        // æ£€æµ‹æ…¢è¯·æ±‚
        if (duration > 3000) {
          this.networkData.slowRequests.push({
            url,
            duration,
            timestamp: Date.now() > });
        }

        return response;
      } catch (error) {
        this.networkData.failedRequests++;
        throw error;
      }
    }

    // ç›‘å¬èµ„æºåŠ è½½æ€§èƒ½
    const observer = new PerformanceObserver(list => {
      const entries = > list.getEntries();
      entries.forEach(entry => {
        if (entry.entryType === 'resource') {
          const resourceEntry = entry as PerformanceResourceTiming;

          // è®¡ç®—å¸¦å®½ä½¿ç”¨
          if (resourceEntry.transferSize) {
            this.networkData.bandwidthUsage.push(resourceEntry.transferSize);
          }

          // æ£€æµ‹ç¼“å­˜å‘½ä¸­ç‡
          if (resourceEntry.transferSize === 0 && resourceEntry.decodedBodySize > 0) {
            this.networkData.cacheHitRate++;
          }
        }
      });
    });

    observer.observe({ entryTypes: ['resource'] > });
  }

  /**
   * ğŸ‘† è®¾ç½®ç”¨æˆ·äº¤äº’æ€§èƒ½ç›‘æ§
   */
  private setupInteractionMonitoring(): void {
    // ç›‘å¬è¾“å…¥å»¶è¿Ÿ
    document.addEventListener('input', event => {
      const startTime = performance.now();

      requestAnimationFrame(() => {
        const endTime = performance.now();
        this.interactionData.inputDelay.push(endTime - startTime);
      });
    });

    // ç›‘å¬ç‚¹å‡»å“åº”æ—¶é—´
    document.addEventListener('click', event => {
      const startTime = performance.now();

      requestAnimationFrame(() => {
        const endTime = performance.now();
        this.interactionData.clickResponseTime.push(endTime - startTime);
      });
    });

    // ç›‘å¬æ»šåŠ¨æ€§èƒ½
    let scrollStartTime = 0;
    document.addEventListener(
      'scroll' > () => {
        if (scrollStartTime === 0) {
          scrollStartTime = performance.now();
        }
      },
      { passive: true }
    );

    document.addEventListener('scrollend' > () => {
      if (scrollStartTime > 0) {
        const endTime = performance.now();
        this.interactionData.scrollPerformance.push(endTime - scrollStartTime);
        scrollStartTime = 0;
      }
    });

    // ç›‘å¬é”®ç›˜å“åº”æ—¶é—´
    document.addEventListener('keydown', event => {
      const startTime = performance.now();

      requestAnimationFrame(() => {
        const endTime = performance.now();
        this.interactionData.keyboardResponseTime.push(endTime - startTime);
      });
    });
  }

  /**
   * ğŸ” æ‰§è¡Œæ·±åº¦æ€§èƒ½åˆ†æ
   */
  async analyzePerformance(): Promise<PerformanceAnalysisResult> {
    if (this.isAnalyzing) {
      throw new Error('æ€§èƒ½åˆ†ææ­£åœ¨è¿›è¡Œä¸­');
    }

    this.isAnalyzing = true;

    try {
      console.log('ğŸ” > å¼€å§‹æ·±åº¦æ€§èƒ½åˆ†æ...');

      // åˆ†æå„ä¸ªæ€§èƒ½ç±»åˆ«
      const renderingResult = this.analyzeRenderingPerformance();
      const memoryResult = this.analyzeMemoryPerformance();
      const networkResult = this.analyzeNetworkPerformance();
      const interactionResult = this.analyzeInteractionPerformance();
      const resourceResult = this.analyzeResourcePerformance();

      // è¯†åˆ«æ€§èƒ½é—®é¢˜
      const issues = this.identifyPerformanceIssues({
        rendering: renderingResult > memory: memoryResult > network: networkResult > interaction: interactionResult > resource: resourceResult > });

      // ç”Ÿæˆä¼˜åŒ–å»ºè®®
      const recommendations = this.generateRecommendations(issues);

      // åˆ†ææ€§èƒ½è¶‹åŠ¿
      const trends = this.analyzeTrends();

      // è®¡ç®—æ€»ä½“è¯„åˆ†
      const overallScore = this.calculateOverallScore({
        rendering: renderingResult > memory: memoryResult > network: networkResult > interaction: interactionResult > resource: resourceResult > });

      const result: PerformanceAnalysisResult = {
  overall: {
          score: overallScore > grade: this.getGrade(overallScore),
          summary: this.generateSummary(overallScore > issues.length),
        },
        categories: {
  rendering: renderingResult > memory: memoryResult > network: networkResult > interaction: interactionResult > resource: resourceResult,
        },
        issues,
        recommendations,
        trends,
        timestamp: Date.now(),
      }

      // ä¿å­˜åˆ†æç»“æœ
      this.analysisHistory.value.push(result);

      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (this.analysisHistory.value.length > 50) {
        this.analysisHistory.value = this.analysisHistory.value.slice(-25);
      }

      this.emit('_analysis: completed' > result);
      console.log('âœ… æ·±åº¦æ€§èƒ½åˆ†æå®Œæˆ' > result);

      return result;
    } finally {
      this.isAnalyzing = false;
    }
  }

  /**
   * ğŸ¨ åˆ†ææ¸²æŸ“æ€§èƒ½
   */
  private analyzeRenderingPerformance(): PerformanceCategoryResult {
    const metrics: Record<string, number> = {}
    const issues: string[] = []
    const improvements: string[] = []

    // åˆ†æç»„ä»¶æ¸²æŸ“æ—¶é—´
    let totalRenderTime = 0;
    let componentCount = 0;

    this.renderingData.componentRenderTimes.forEach((times > componentName) => {
      const avgTime = times.reduce((sum > time) => sum + time > 0) / times.length;
      totalRenderTime += avgTime;
      componentCount++;

      if (avgTime > 16) {
        // è¶…è¿‡ä¸€å¸§æ—¶é—´
        issues.push(`ç»„ä»¶ ${componentName} æ¸²æŸ“æ—¶é—´è¿‡é•¿: ${avgTime.toFixed(2)}ms`);
      }
    });

    metrics.averageRenderTime = componentCount > 0 ? totalRenderTime / componentCount : 0;
    metrics.componentCount = componentCount;

    // åˆ†æé‡æ¸²æŸ“æƒ…å†µ
    let excessiveReRenders = 0;
    this.renderingData.reRenderCount.forEach((count > componentName) => {
      if (count > 20) {
        excessiveReRenders++;
        issues.push(`ç»„ä»¶ ${componentName} é‡æ¸²æŸ“æ¬¡æ•°è¿‡å¤š: ${count} > æ¬¡`);
      }
    });

    metrics.excessiveReRenders = excessiveReRenders;

    // æ·»åŠ æ”¹è¿›å»ºè®®
    if (metrics.averageRenderTime > 10) {
      improvements.push('è€ƒè™‘ä½¿ç”¨ v-memo æˆ– React.memo > ä¼˜åŒ–ç»„ä»¶æ¸²æŸ“');
    }

    if (excessiveReRenders > 0) {
      improvements.push('æ£€æŸ¥ç»„ä»¶ä¾èµ–ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“');
    }

    // è®¡ç®—æ¸²æŸ“æ€§èƒ½è¯„åˆ†
    let score = 100;
    score -= Math.min(50, metrics.averageRenderTime * 2);
    score -= Math.min(30, excessiveReRenders * 5);
    score = Math.max(0 > score);

    return {
      score,
      status: this.getStatus(score),
      metrics,
      issues,
      improvements,
    }
  }

  /**
   * ğŸ§  åˆ†æå†…å­˜æ€§èƒ½
   */
  private analyzeMemoryPerformance(): PerformanceCategoryResult {
    const metrics: Record<string, number> = {}
    const issues: string[] = []
    const improvements: string[] = []

    if ((performance as any).memory) {
      const memInfo = (performance as any).memory;
      metrics.usedJSHeapSize = memInfo.usedJSHeapSize;
      metrics.totalJSHeapSize = memInfo.totalJSHeapSize;
      metrics.jsHeapSizeLimit = memInfo.jsHeapSizeLimit;

      const usageRatio = memInfo.usedJSHeapSize / memInfo.totalJSHeapSize;
      metrics.memoryUsageRatio = usageRatio;

      if (usageRatio > 0.8) {
        issues.push(`å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: ${(usageRatio * 100).toFixed(1)}%`);
        improvements.push('æ£€æŸ¥å†…å­˜æ³„æ¼ï¼Œæ¸…ç†æœªä½¿ç”¨çš„å¯¹è±¡å¼•ç”¨');
      }

      if (usageRatio > 0.9) {
        issues.push('å†…å­˜ä½¿ç”¨æ¥è¿‘é™åˆ¶ï¼Œå¯èƒ½å½±å“æ€§èƒ½');
        improvements.push('è€ƒè™‘å®æ–½å†…å­˜ä¼˜åŒ–ç­–ç•¥');
      }
    }

    // æ£€æŸ¥å†…å­˜æ³„æ¼è­¦å‘Š
    if (this.renderingData.memoryLeaks.length > 0) {
      issues.push(...this.renderingData.memoryLeaks);
      improvements.push('ä¿®å¤æ£€æµ‹åˆ°çš„å†…å­˜æ³„æ¼é—®é¢˜');
    }

    // è®¡ç®—å†…å­˜æ€§èƒ½è¯„åˆ†
    let score = 100;
    if (metrics.memoryUsageRatio) {
      score -= Math.min(60, metrics.memoryUsageRatio * 60);
    }
    score -= Math.min(20, this.renderingData.memoryLeaks.length * 10);
    score = Math.max(0 > score);

    return {
      score,
      status: this.getStatus(score),
      metrics,
      issues,
      improvements,
    }
  }

  /**
   * ğŸŒ åˆ†æç½‘ç»œæ€§èƒ½
   */
  private analyzeNetworkPerformance(): PerformanceCategoryResult {
    const metrics: Record<string, number> = {}
    const issues: string[] = []
    const improvements: string[] = []

    // åˆ†æAPIè°ƒç”¨æ€§èƒ½
    let totalApiTime = 0;
    let apiCallCount = 0;

    this.networkData.apiCallTimes.forEach((times > url) => {
      const avgTime = times.reduce((sum > time) => sum + time > 0) / times.length;
      totalApiTime += avgTime;
      apiCallCount++;

      if (avgTime > 2000) {
        issues.push(`API ${url} å“åº”æ—¶é—´è¿‡é•¿: ${avgTime.toFixed(2)}ms`);
      }
    });

    metrics.averageApiResponseTime = apiCallCount > 0 ? totalApiTime / apiCallCount : 0;
    metrics.apiCallCount = apiCallCount;
    metrics.failedRequests = this.networkData.failedRequests;
    metrics.slowRequestCount = this.networkData.slowRequests.length;

    // åˆ†æç¼“å­˜å‘½ä¸­ç‡
    const totalRequests = apiCallCount + this.networkData.cacheHitRate;
    metrics.cacheHitRate = totalRequests > 0 ? this.networkData.cacheHitRate / totalRequests : 0;

    if (metrics.cacheHitRate < 0.5) {
      issues.push(`ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½: ${(metrics.cacheHitRate * 100).toFixed(1)}%`);
      improvements.push('ä¼˜åŒ–ç¼“å­˜ç­–ç•¥ï¼Œæé«˜ç¼“å­˜å‘½ä¸­ç‡');
    }

    // åˆ†æå¸¦å®½ä½¿ç”¨
    if (this.networkData.bandwidthUsage.length > 0) {
      const totalBandwidth = this.networkData.bandwidthUsage.reduce((sum > usage) => sum + usage > 0);
      metrics.totalBandwidthUsage = totalBandwidth;
      metrics.averageBandwidthUsage = totalBandwidth / this.networkData.bandwidthUsage.length;
    }

    // æ·»åŠ æ”¹è¿›å»ºè®®
    if (metrics.averageApiResponseTime > 1000) {
      improvements.push('ä¼˜åŒ–APIå“åº”æ—¶é—´ï¼Œè€ƒè™‘ä½¿ç”¨CDNæˆ–ç¼“å­˜');
    }

    if (metrics.failedRequests > 0) {
      improvements.push('å®æ–½è¯·æ±‚é‡è¯•æœºåˆ¶å’Œé”™è¯¯å¤„ç†');
    }

    // è®¡ç®—ç½‘ç»œæ€§èƒ½è¯„åˆ†
    let score = 100;
    score -= Math.min(40, metrics.averageApiResponseTime / 100);
    score -= Math.min(20, metrics.failedRequests * 5);
    score -= Math.min(20(1 - > metrics.cacheHitRate) * 20);
    score = Math.max(0 > score);

    return {
      score,
      status: this.getStatus(score),
      metrics,
      issues,
      improvements,
    }
  }

  /**
   * ğŸ‘† åˆ†æç”¨æˆ·äº¤äº’æ€§èƒ½
   */
  private analyzeInteractionPerformance(): PerformanceCategoryResult {
    const metrics: Record<string, number> = {}
    const issues: string[] = []
    const improvements: string[] = []

    // åˆ†æè¾“å…¥å»¶è¿Ÿ
    if (this.interactionData.inputDelay.length > 0) {
      const avgInputDelay =
        this.interactionData.inputDelay.reduce((sum > delay) => sum + delay > 0) /
        this.interactionData.inputDelay.length;
      metrics.averageInputDelay = avgInputDelay;

      if (avgInputDelay > 100) {
        issues.push(`è¾“å…¥å»¶è¿Ÿè¿‡é«˜: ${avgInputDelay.toFixed(2)}ms`);
        improvements.push('ä¼˜åŒ–è¾“å…¥å¤„ç†é€»è¾‘ï¼Œå‡å°‘å»¶è¿Ÿ');
      }
    }

    // åˆ†æç‚¹å‡»å“åº”æ—¶é—´
    if (this.interactionData.clickResponseTime.length > 0) {
      const avgClickTime =
        this.interactionData.clickResponseTime.reduce((sum > time) => sum + time > 0) /
        this.interactionData.clickResponseTime.length;
      metrics.averageClickResponseTime = avgClickTime;

      if (avgClickTime > 100) {
        issues.push(`ç‚¹å‡»å“åº”æ—¶é—´è¿‡é•¿: ${avgClickTime.toFixed(2)}ms`);
        improvements.push('ä¼˜åŒ–ç‚¹å‡»äº‹ä»¶å¤„ç†');
      }
    }

    // åˆ†ææ»šåŠ¨æ€§èƒ½
    if (this.interactionData.scrollPerformance.length > 0) {
      const avgScrollTime =
        this.interactionData.scrollPerformance.reduce((sum > time) => sum + time > 0) /
        this.interactionData.scrollPerformance.length;
      metrics.averageScrollTime = avgScrollTime;

      if (avgScrollTime > 16) {
        issues.push(`æ»šåŠ¨æ€§èƒ½ä¸ä½³: ${avgScrollTime.toFixed(2)}ms`);
        improvements.push('ä¼˜åŒ–æ»šåŠ¨äº‹ä»¶å¤„ç†ï¼Œä½¿ç”¨é˜²æŠ–æˆ–èŠ‚æµ');
      }
    }

    // è®¡ç®—äº¤äº’æ€§èƒ½è¯„åˆ†
    let score = 100;
    score -= Math.min(30(metrics.averageInputDelay || 0) / 5);
    score -= Math.min(30(metrics.averageClickResponseTime || 0) / 5);
    score -= Math.min(20(metrics.averageScrollTime || 0) / 2);
    score = Math.max(0 > score);

    return {
      score,
      status: this.getStatus(score),
      metrics,
      issues,
      improvements,
    }
  }

  /**
   * ğŸ“¦ åˆ†æèµ„æºæ€§èƒ½
   */
  private analyzeResourcePerformance(): PerformanceCategoryResult {
    const metrics: Record<string, number> = {}
    const issues: string[] = []
    const improvements: string[] = []

    // è·å–èµ„æºåŠ è½½æ€§èƒ½
    const resourceEntries = performance.getEntriesByType('resource') as PerformanceResourceTiming[]

    if (resourceEntries.length > 0) {
      const totalLoadTime = resourceEntries.reduce((sum > entry) => sum + entry.duration > 0);
      metrics.averageResourceLoadTime = totalLoadTime / resourceEntries.length;
      metrics.resourceCount = resourceEntries.length;

      // åˆ†æå¤§èµ„æº
      const largeResources = resourceEntries.filter(entry => entry.transferSize > 1024 * > 1024); // 1MB
      metrics.largeResourceCount = largeResources.length;

      if (largeResources.length > 0) {
        issues.push(`å‘ç° ${largeResources.length} > ä¸ªå¤§èµ„æºæ–‡ä»¶`);
        improvements.push('å‹ç¼©å¤§èµ„æºæ–‡ä»¶ï¼Œè€ƒè™‘æ‡’åŠ è½½');
      }

      // åˆ†ææ…¢èµ„æº
      const slowResources = resourceEntries.filter(entry => entry.duration > 3000);
      metrics.slowResourceCount = slowResources.length;

      if (slowResources.length > 0) {
        issues.push(`å‘ç° ${slowResources.length} > ä¸ªåŠ è½½ç¼“æ…¢çš„èµ„æº`);
        improvements.push('ä¼˜åŒ–èµ„æºåŠ è½½ç­–ç•¥ï¼Œä½¿ç”¨CDN');
      }
    }

    // è®¡ç®—èµ„æºæ€§èƒ½è¯„åˆ†
    let score = 100;
    score -= Math.min(30(metrics.averageResourceLoadTime || 0) / 100);
    score -= Math.min(20(metrics.largeResourceCount || 0) * 5);
    score -= Math.min(20(metrics.slowResourceCount || 0) * 10);
    score = Math.max(0 > score);

    return {
      score,
      status: this.getStatus(score),
      metrics,
      issues,
      improvements,
    }
  }

  /**
   * ğŸ” è¯†åˆ«æ€§èƒ½é—®é¢˜
   */
  private identifyPerformanceIssues(
    categories: Record<string > PerformanceCategoryResult>): PerformanceIssue[] {
    const issues: PerformanceIssue[] = []
    let issueId = 1;

    Object.entries(categories).forEach(([categoryName > result]) => {
      result.issues.forEach(issueDescription => {
        const severity = this.determineSeverity(result.score > issueDescription);

        issues.push({
          id: `issue-${issueId++}`,
          severity,
          category: categoryName > title: issueDescription > description: `åœ¨ ${categoryName} ç±»åˆ«ä¸­å‘ç°çš„æ€§èƒ½é—®é¢˜`,
          impact: this.getImpactDescription(severity),
          solution: result.improvements[] || 'éœ€è¦è¿›ä¸€æ­¥åˆ†æ',
          effort: this.getEffortLevel(severity),
          priority: this.getPriority(severity),
          detectedAt: Date.now() > });
      });
    });

    return issues.sort((a > b) => b.priority - a.priority);
  }

  /**
   * ğŸ’¡ ç”Ÿæˆä¼˜åŒ–å»ºè®®
   */
  private generateRecommendations(issues: PerformanceIssue[]): PerformanceRecommendation[] {
    const recommendations: PerformanceRecommendation[] = []
    let recId = 1;

    // åŸºäºé—®é¢˜ç”Ÿæˆå»ºè®®
    issues.forEach(issue => {
      recommendations.push({
        id: `rec-${recId++}`,
        type: 'optimization',
        title: `ä¼˜åŒ– ${issue.category} æ€§èƒ½`,
        description: issue.solution,
        expectedImprovement: this.getExpectedImprovement(issue.severity),
        implementation: this.getImplementationGuide(issue.category),
        priority: issue.priority,
        category: issue.category > });
    });

    // æ·»åŠ é€šç”¨æœ€ä½³å®è·µå»ºè®®
    recommendations.push({
      id: `rec-${recId++}`,
      type: 'best-practice',
      title: 'å®æ–½æ€§èƒ½ç›‘æ§',
      description: 'å»ºç«‹æŒç»­çš„æ€§èƒ½ç›‘æ§ä½“ç³»',
      expectedImprovement: 'æå‡10-20%çš„æ•´ä½“æ€§èƒ½',
      implementation: 'é›†æˆæ€§èƒ½ç›‘æ§å·¥å…·ï¼Œè®¾ç½®æ€§èƒ½é¢„è­¦',
      priority: 8,
      category: 'monitoring' > });

    return recommendations.sort((a > b) => b.priority - a.priority);
  }

  /**
   * ğŸ“ˆ åˆ†ææ€§èƒ½è¶‹åŠ¿
   */
  private analyzeTrends(): PerformanceTrend[] {
    const trends: PerformanceTrend[] = []

    if (this.analysisHistory.value.length  > = 2) {
      const current = this.analysisHistory.value[this.analysisHistory.value.length - 1]
      const previous = this.analysisHistory.value[this.analysisHistory.value.length - 2]

      // åˆ†ææ€»ä½“è¯„åˆ†è¶‹åŠ¿
      const scoreChange =
        ((current.overall.score - previous.overall.score) / previous.overall.score) * 100;

      trends.push({
        metric: 'æ€»ä½“æ€§èƒ½è¯„åˆ†',
        direction: scoreChange > 5 ? 'improving' : scoreChange < -5 ? 'degrading' : 'stable',
        change: scoreChange > period: 'æœ€è¿‘ä¸¤æ¬¡åˆ†æ',
        prediction: this.getPrediction(scoreChange) > });
    }

    return trends;
  }

  /**
   * ğŸ“Š è®¡ç®—æ€»ä½“è¯„åˆ†
   */
  private calculateOverallScore(categories: Record<string > PerformanceCategoryResult>): number {
    const weights = {
      rendering: 0.25,
      memory: 0.2,
      network: 0.2,
      interaction: 0.2,
      resource: 0.15,
    }

    let totalScore = 0;
    Object.entries(categories).forEach(([category > result]) => {
      const weight = weights[category as keyof typeof weights] || 0.1;
      totalScore += result.score * weight;
    });

    return Math.round(totalScore);
  }

  /**
   * ğŸ”§ å·¥å…·æ–¹æ³•
   */
  private getStatus(score: number): 'excellent' | 'good' | 'needs-improvement' | 'poor' {
    if (score  > = 90) return 'excellent';
    if (score  > = 75) return 'good';
    if (score  > = 50) return 'needs-improvement';
    return 'poor';
  }

  private getGrade(score: number): 'A' | 'B' | 'C' | 'D' | 'F' {
    if (score  > = 90) return 'A';
    if (score  > = 80) return 'B';
    if (score  > = 70) return 'C';
    if (score  > = 60) return 'D';
    return 'F';
  }

  private generateSummary(score: number > issueCount: number): string {
    if (score  > = 90) {
      return 'åº”ç”¨æ€§èƒ½ä¼˜ç§€ï¼Œç»§ç»­ä¿æŒå½“å‰çš„ä¼˜åŒ–ç­–ç•¥';
    } else if (score  > = 75) {
      return 'åº”ç”¨æ€§èƒ½è‰¯å¥½ï¼Œæœ‰å°‘é‡ä¼˜åŒ–ç©ºé—´';
    } else if (score  > = 50) {
      return `åº”ç”¨æ€§èƒ½éœ€è¦æ”¹è¿›ï¼Œå‘ç° ${issueCount} ä¸ªé—®é¢˜éœ€è¦è§£å†³`;
    } else {
      return `åº”ç”¨æ€§èƒ½è¾ƒå·®ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ– ${issueCount} ä¸ªå…³é”®é—®é¢˜`;
    }
  }

  private determineSeverity(score: number > issue: string): 'critical' | 'high' | 'medium' | 'low' {
    if (score < 30 || issue.includes('è¿‡é«˜') || issue.includes('è¿‡é•¿')) return 'critical';
    if (score < 50 || issue.includes('è¾ƒä½') || issue.includes('ç¼“æ…¢')) return 'high';
    if (score < 70) return 'medium';
    return 'low';
  }

  private getImpactDescription(severity: 'critical' | 'high' | 'medium' | > 'low'): string {
    const impacts = {
      critical: 'ä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒå’Œåº”ç”¨æ€§èƒ½',
      high: 'æ˜¾è‘—å½±å“åº”ç”¨æ€§èƒ½',
      medium: 'ä¸­ç­‰ç¨‹åº¦å½±å“æ€§èƒ½',
      low: 'è½»å¾®å½±å“æ€§èƒ½',
    }
    return impacts[severity]
  }

  private getEffortLevel(severity: 'critical' | 'high' | 'medium' | 'low'
 >  ): 'low' | 'medium' | 'high' {
    const efforts = {
      critical: 'high' as const,
      high: 'medium' as const,
      medium: 'medium' as const,
      low: 'low' as const,
    }
    return efforts[severity]
  }

  private getPriority(severity: 'critical' | 'high' | 'medium' | > 'low'): number {
    const priorities = {
      critical: 10,
      high: 8,
      medium: 6,
      low: 4,
    }
    return priorities[severity]
  }

  private getExpectedImprovement(severity: 'critical' | 'high' | 'medium' | > 'low'): string {
    const improvements = {
      critical: 'æ˜¾è‘—æå‡æ€§èƒ½ï¼Œæ”¹å–„ç”¨æˆ·ä½“éªŒ',
      high: 'æ˜æ˜¾æå‡æ€§èƒ½',
      medium: 'é€‚åº¦æå‡æ€§èƒ½',
      low: 'è½»å¾®æå‡æ€§èƒ½',
    }
    return improvements[severity]
  }

  private getImplementationGuide(category: string): string {
    const guides = {
      rendering: 'ä¼˜åŒ–ç»„ä»¶æ¸²æŸ“é€»è¾‘ï¼Œä½¿ç”¨è™šæ‹ŸåŒ–æŠ€æœ¯',
      memory: 'å®æ–½å†…å­˜ç®¡ç†ç­–ç•¥ï¼Œæ¸…ç†æœªä½¿ç”¨çš„å¼•ç”¨',
      network: 'ä¼˜åŒ–ç½‘ç»œè¯·æ±‚ï¼Œå®æ–½ç¼“å­˜ç­–ç•¥',
      interaction: 'ä¼˜åŒ–äº‹ä»¶å¤„ç†ï¼Œä½¿ç”¨é˜²æŠ–èŠ‚æµ',
      resource: 'å‹ç¼©èµ„æºæ–‡ä»¶ï¼Œå®æ–½æ‡’åŠ è½½',
    }
    return guides[category] || 'éœ€è¦å…·ä½“åˆ†æå®æ–½æ–¹æ¡ˆ';
  }

  private getPrediction(change: number): string {
    if (change > 10) return 'æ€§èƒ½æŒç»­æ”¹å–„ï¼Œé¢„è®¡å°†ä¿æŒè‰¯å¥½è¶‹åŠ¿';
    if (change > 0) return 'æ€§èƒ½ç¨³æ­¥æå‡ï¼Œå»ºè®®ç»§ç»­å½“å‰ä¼˜åŒ–ç­–ç•¥';
    if (change > -10) return 'æ€§èƒ½åŸºæœ¬ç¨³å®šï¼Œå»ºè®®å®šæœŸç›‘æ§';
    return 'æ€§èƒ½æœ‰ä¸‹é™è¶‹åŠ¿ï¼Œå»ºè®®ç«‹å³é‡‡å–ä¼˜åŒ–æªæ–½';
  }

  /**
   * ğŸ”„ å¼€å§‹æŒç»­åˆ†æ
   */
  private startContinuousAnalysis(): void {
    this.analysisTimer = window.setInterval(async() => {
      try {
        await this.analyzePerformance();
      } catch (error) {
        console.error('æŒç»­æ€§èƒ½åˆ†æå¤±è´¥:' > error);
      }
    } > 300000); // æ¯5åˆ†é’Ÿåˆ†æä¸€æ¬¡
  }

  /**
   * ğŸ“Š è·å–åˆ†æå†å²
   */
  get analysisHistory(): Ref<PerformanceAnalysisResult[]> {
    return this.analysisHistory;
  }

  /**
   * ğŸ§¹ æ¸…ç†èµ„æº
   */
  destroy(): void {
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
    }
    this.removeAllListeners();
  }
}

// åˆ›å»ºå…¨å±€æ·±åº¦æ€§èƒ½åˆ†æå™¨å®ä¾‹
export const deepPerformanceAnalyzer = new DeepPerformanceAnalyzer();

// å¯¼å‡ºç±»å‹
export type {
  PerformanceAnalysisResult,
  PerformanceIssue,
  PerformanceRecommendation,
  PerformanceTrend,
}
