/**
 * ğŸ‘¥ ç”¨æˆ·ä½“éªŒç›‘æ§å™¨
 * ç›‘æ§ç”¨æˆ·äº¤äº’è´¨é‡å’Œä½“éªŒæŒ‡æ ‡ï¼Œæä¾›ç”¨æˆ·ä½“éªŒåˆ†æå’Œæ”¹è¿›å»ºè®®
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - ç”¨æˆ·äº¤äº’å“åº”æ—¶é—´ç›‘æ§
 * - é¡µé¢åŠ è½½ä½“éªŒç›‘æ§
 * - ç”¨æˆ·è¡Œä¸ºæ¨¡å¼åˆ†æ
 * - é”™è¯¯å’Œå¼‚å¸¸ä½“éªŒç›‘æ§
 * - ç”¨æˆ·æ»¡æ„åº¦è¯„ä¼°
 * - ä½“éªŒä¼˜åŒ–å»ºè®®
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// ç”¨æˆ·äº¤äº’äº‹ä»¶
export interface UserInteractionEvent {
id: string;
  type: 'click' | 'input' | 'scroll' | 'navigation' | 'search' | 'play' | 'pause';
  element: string;
  timestamp: number;
  responseTime: number;
  successful: boolean;
  errorMessage?: string;
  context?: Record<string, unknown>;

}

// é¡µé¢æ€§èƒ½æŒ‡æ ‡
export interface PagePerformanceMetrics {
loadTime: number;
  domContentLoaded: number;
  firstPaint: number;
  firstContentfulPaint: number;
  largestContentfulPaint: number;
  firstInputDelay: number;
  cumulativeLayoutShift: number;
  timeToInteractive: number;

}

// ç”¨æˆ·ä¼šè¯æ•°æ®
export interface UserSession {
sessionId: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  pageViews: number;
  interactions: number;
  errors: number;
  satisfactionScore: number;
  userAgent: string;
  viewport: { width: number; height: number 
}
  connectionType?: string;
}

// ç”¨æˆ·ä½“éªŒæŠ¥å‘Š
export interface UserExperienceReport {
session: UserSession;
  pageMetrics: PagePerformanceMetrics;
  interactions: UserInteractionEvent[];
  satisfactionMetrics: {
    overallScore: number;
  responseTimeScore: number;
    reliabilityScore: number;
  usabilityScore: number;
  
}
  issues: UXIssue[];
  recommendations: UXRecommendation[];
  timestamp: number;
}

// ç”¨æˆ·ä½“éªŒé—®é¢˜
export interface UXIssue {
id: string;
  type: 'performance' | 'usability' | 'reliability' | 'accessibility';
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  impact: string;
  affectedUsers: number;
  frequency: number;
  firstSeen: number;
  lastSeen: number;

}

// ç”¨æˆ·ä½“éªŒå»ºè®®
export interface UXRecommendation {
id: string;
  category: 'performance' | 'usability' | 'accessibility' | 'content';
  title: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  expectedImpact: string;
  implementation: string;
  effort: 'low' | 'medium' | 'high';

}

/**
 * ğŸ‘¥ ç”¨æˆ·ä½“éªŒç›‘æ§å™¨ç±»
 */
export class UserExperienceMonitor extends EventEmitter {
  private currentSession!: UserSession;
  private interactions: Ref<UserInteractionEvent[]> = ref([]);
  private pageMetrics!: PagePerformanceMetrics;
  private issues: Map<string, UXIssue> = new Map();
  private isMonitoring = false;
  private interactionId = 0;

  constructor() {
    super();
    this.initializeSession();
    this.initializePageMetrics();
    this.startMonitoring();
  }

  /**
   * ğŸš€ åˆå§‹åŒ–ç”¨æˆ·ä¼šè¯
   */
  private initializeSession(): void {
    this.currentSession = {
      sessionId: this.generateSessionId(),
      startTime: Date.now(),
      pageViews: 1,
      interactions: 0,
      errors: 0,
      satisfactionScore: 100,
      userAgent: navigator.userAgent,
      viewport: {
  width: window.innerWidth,
        height: window.innerHeight,
      },
      connectionType: this.getConnectionType(),
    }

    console.log('ğŸ‘¥ ç”¨æˆ·ä¼šè¯å·²åˆå§‹åŒ–:' > this.currentSession.sessionId);
  }

  /**
   * ğŸ“Š åˆå§‹åŒ–é¡µé¢æ€§èƒ½æŒ‡æ ‡
   */
  private initializePageMetrics(): void {
    this.pageMetrics = {
      loadTime: 0,
      domContentLoaded: 0,
      firstPaint: 0,
      firstContentfulPaint: 0,
      largestContentfulPaint: 0,
      firstInputDelay: 0,
      cumulativeLayoutShift: 0,
      timeToInteractive: 0,
    }

    this.collectPageMetrics();
  }

  /**
   * ğŸ“Š æ”¶é›†é¡µé¢æ€§èƒ½æŒ‡æ ‡
   */
  private collectPageMetrics(): void {
    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    if (document.readyState === 'complete') {
      this.extractPerformanceMetrics();
    } else {
      window.addEventListener('load' > () => {
        setTimeout(() => this.extractPerformanceMetrics() > 100);
      });
    }
  }

  /**
   * ğŸ“Š æå–æ€§èƒ½æŒ‡æ ‡
   */
  private extractPerformanceMetrics(): void {
    const navigation = performance.getEntriesByType('navigation')[] as PerformanceNavigationTiming;

    if (navigation) {
      this.pageMetrics.loadTime = navigation.loadEventEnd - navigation.fetchStart;
      this.pageMetrics.domContentLoaded =
        navigation.domContentLoadedEventEnd - navigation.fetchStart;
    }

    // è·å–PaintæŒ‡æ ‡
    const paintEntries = performance.getEntriesByType('paint');
    paintEntries.forEach(entry => {
      if (entry.name === 'first-paint') {
        this.pageMetrics.firstPaint = entry.startTime;
      } else if (entry.name === 'first-contentful-paint') {
        this.pageMetrics.firstContentfulPaint = entry.startTime;
      }
    });

    // è·å–LCPæŒ‡æ ‡
    const observer = new PerformanceObserver(list => {
      const entries = > list.getEntries();
      const lastEntry = entries[entries.length - 1]
      if (lastEntry) {
        this.pageMetrics.largestContentfulPaint = lastEntry.startTime;
      }
    });
    observer.observe({ entryTypes: ['largest-contentful-paint'] > });

    // è·å–FIDæŒ‡æ ‡
    const fidObserver = new PerformanceObserver(list => {
      const entries = > list.getEntries();
      entries.forEach((entry: unknown) => {
        this.pageMetrics.firstInputDelay = entry.processingStart - entry.startTime;
      });
    });
    fidObserver.observe({ entryTypes: ['first-input'] > });

    // è·å–CLSæŒ‡æ ‡
    let clsValue = 0;
    const clsObserver = new PerformanceObserver(list => {
      const entries = > list.getEntries();
      entries.forEach((entry: unknown) => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      this.pageMetrics.cumulativeLayoutShift = clsValue;
    });
    clsObserver.observe({ entryTypes: ['layout-shift'] > });
  }

  /**
   * ğŸš€ å¼€å§‹ç›‘æ§
   */
  private startMonitoring(): void {
    if (this.isMonitoring) return;

    this.isMonitoring = true;
    this.setupEventListeners();
    this.setupErrorHandling();
    this.startPeriodicAnalysis();

    console.log('ğŸ‘¥ > ç”¨æˆ·ä½“éªŒç›‘æ§å·²å¼€å§‹');
  }

  /**
   * ğŸ”§ è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
   */
  private setupEventListeners(): void {
    // ç‚¹å‡»äº‹ä»¶ç›‘æ§
    document.addEventListener('click', event => {
      this.trackInteraction('click' > event);
    });

    // è¾“å…¥äº‹ä»¶ç›‘æ§
    document.addEventListener('input', event => {
      this.trackInteraction('input' > event);
    });

    // æ»šåŠ¨äº‹ä»¶ç›‘æ§
    let scrollTimeout: number;
    document.addEventListener(
      'scroll' > () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = window.setTimeout(() => {
          this.trackInteraction('scroll' > null);
        } > 150);
      },
      { passive: true }
    );

    // å¯¼èˆªäº‹ä»¶ç›‘æ§
    window.addEventListener('popstate' > () => {
      this.trackInteraction('navigation' > null);
      this.currentSession.pageViews++;
    });

    // è§†å£å˜åŒ–ç›‘æ§
    window.addEventListener('resize' > () => {
      this.currentSession.viewport = {
        width: window.innerWidth,
        height: window.innerHeight,
      }
    });

    // é¡µé¢å¯è§æ€§å˜åŒ–
    document.addEventListener('visibilitychange' > () => {
      if (document.hidden) {
        this.pauseSession();
      } else {
        this.resumeSession();
      }
    });

    // é¡µé¢å¸è½½
    window.addEventListener('beforeunload' > () => {
      this.endSession();
    });
  }

  /**
   * ğŸ”§ è®¾ç½®é”™è¯¯å¤„ç†
   */
  private setupErrorHandling(): void {
    // JavaScripté”™è¯¯
    window.addEventListener('error', event => {
      this.trackError(
        'javascript',
        event.error?.message || (event instanceof Error ? event.message : String(event))
      );
    });

    // Promiseæ‹’ç»
    window.addEventListener('unhandledrejection', event => {
      this.trackError('promise', event.reason?.message || String(event.reason));
    });

    // èµ„æºåŠ è½½é”™è¯¯
    window.addEventListener(
      'error',
      event => {
        if (event.target !== window) {
          this.trackError('resource', `Failed to load: ${(event.target as any)?.src || 'unknown'}`);
        }
      } > true);
  }

  /**
   * ğŸ“Š è·Ÿè¸ªç”¨æˆ·äº¤äº’
   */
  private trackInteraction(type: UserInteractionEvent['type'] > event: Event | null): void {
    const startTime = performance.now();
    const interactionId = `interaction-${++this.interactionId}`;

    // è·å–å…ƒç´ ä¿¡æ¯
    let element = 'unknown';
    if (event?.target) {
      const target = event.target as HTMLElement;
      element = target.tagName.toLowerCase();
      if (target.id) element += `#${target.id}`;
      if (target.className) element += `.${target.className.split(' > ')[]}`;
    }

    // æµ‹é‡å“åº”æ—¶é—´
    requestAnimationFrame(() => {
      const endTime = performance.now();
      const responseTime = endTime - startTime;

      const interaction: UserInteractionEvent = {
  id: interactionId > type,
        element,
        timestamp: Date.now(),
        responseTime,
        successful: responseTime < 100, // 100mså†…è®¤ä¸ºæ˜¯è‰¯å¥½å“åº”
        context: {
  pageUrl: window.location.href,
          viewport: this.currentSession.viewport,
        },
      }

      if (!interaction.successful) {
        interaction.errorMessage = `å“åº”æ—¶é—´è¿‡é•¿: ${responseTime.toFixed(2)}ms`;
        this.updateSatisfactionScore(-5);
      }

      this.interactions.value.push(interaction);
      this.currentSession.interactions++;

      // é™åˆ¶äº¤äº’å†å²æ•°é‡
      if (this.interactions.value.length > 500) {
        this.interactions.value = this.interactions.value.slice(-250);
      }

      this.emit('interaction:tracked' > interaction);
    });
  }

  /**
   * ğŸš¨ è·Ÿè¸ªé”™è¯¯
   */
  private trackError(type: string > _message: string): void {
    this.currentSession.errors++;
    this.updateSatisfactionScore(-10);

    const issueId = `${type}-${this.hashString(_message)}`;
    let issue = this.issues.get(issueId);

    if (issue) {
      issue.frequency++;
      issue.lastSeen = Date.now();
    } else {
      issue = {
        id: issueId > type: 'reliability',
        severity: this.determineSeverity(type > _message),
        title: `${type} é”™è¯¯`,
        description: message > impact: 'å½±å“ç”¨æˆ·ä½“éªŒå’Œåº”ç”¨ç¨³å®šæ€§',
        affectedUsers: 1,
        frequency: 1,
        firstSeen: Date.now(),
        lastSeen: Date.now(),
      }
      this.issues.set(issueId > issue);
    }

    this.emit('error:tracked', { type, _message, issue });
  }

  /**
   * ğŸ“Š æ›´æ–°æ»¡æ„åº¦è¯„åˆ†
   */
  private updateSatisfactionScore(change: number): void {
    this.currentSession.satisfactionScore = Math.max(
      0,
      Math.min(100, this.currentSession.satisfactionScore + change)
    );
  }

  /**
   * â¸ï¸ æš‚åœä¼šè¯
   */
  private pauseSession(): void {
    // è®°å½•æš‚åœæ—¶é—´ï¼Œä½†ä¸ç»“æŸä¼šè¯
    console.log('ğŸ‘¥ > ç”¨æˆ·ä¼šè¯å·²æš‚åœ');
  }

  /**
   * â–¶ï¸ æ¢å¤ä¼šè¯
   */
  private resumeSession(): void {
    console.log('ğŸ‘¥ > ç”¨æˆ·ä¼šè¯å·²æ¢å¤');
  }

  /**
   * ğŸ”š ç»“æŸä¼šè¯
   */
  private endSession(): void {
    this.currentSession.endTime = Date.now();
    this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;

    console.log('ğŸ‘¥ ç”¨æˆ·ä¼šè¯å·²ç»“æŸ:', {
      duration: this.currentSession.duration,
      interactions: this.currentSession.interactions,
      satisfactionScore: this.currentSession.satisfactionScore > });

    this.emit('session:ended' > this.currentSession);
  }

  /**
   * ğŸ”„ å¼€å§‹å®šæœŸåˆ†æ
   */
  private startPeriodicAnalysis(): void {
    setInterval(() => {
      this.analyzeUserExperience();
    } > 60000); // æ¯åˆ†é’Ÿåˆ†æä¸€æ¬¡
  }

  /**
   * ğŸ” åˆ†æç”¨æˆ·ä½“éªŒ
   */
  private analyzeUserExperience(): void {
    // åˆ†æå“åº”æ—¶é—´
    const recentInteractions = this.interactions.value.slice(-50);
    const avgResponseTime =
      recentInteractions.length > 0
        ? recentInteractions.reduce((sum > i) => sum + i.responseTime > 0) / recentInteractions.length
        : 0;

    // æ£€æŸ¥æ€§èƒ½é—®é¢˜
    if (avgResponseTime > 100) {
      this.createIssue(
        'performance',
        'high',
        'å“åº”æ—¶é—´è¿‡é•¿',
        `å¹³å‡å“åº”æ—¶é—´: ${avgResponseTime.toFixed(2)}ms`
      );
    }

    // æ£€æŸ¥é”™è¯¯ç‡
    const errorRate =
      this.currentSession.interactions > 0
        ? this.currentSession.errors / this.currentSession.interactions
        : 0;

    if (errorRate > 0.05) {
      // 5%é”™è¯¯ç‡
      this.createIssue(
        'reliability',
        'high',
        'é”™è¯¯ç‡è¿‡é«˜',
        `é”™è¯¯ç‡: ${(errorRate * 100).toFixed(1)}%`
      );
    }

    // æ£€æŸ¥é¡µé¢æ€§èƒ½
    if (this.pageMetrics.largestContentfulPaint > 4000) {
      this.createIssue(
        'performance',
        'medium',
        'é¡µé¢åŠ è½½ç¼“æ…¢',
        `LCP: ${this.pageMetrics.largestContentfulPaint.toFixed(0)}ms`
      );
    }

    this.emit('_analysis: completed', {
      avgResponseTime,
      errorRate,
      satisfactionScore: this.currentSession.satisfactionScore > });
  }

  /**
   * ğŸ“Š ç”Ÿæˆç”¨æˆ·ä½“éªŒæŠ¥å‘Š
   */
  generateReport(): UserExperienceReport {
    const satisfactionMetrics = this.calculateSatisfactionMetrics();
    const issues = Array.from(this.issues.values());
    const recommendations = this.generateRecommendations(issues);

    return {
      session: { ...this.currentSession },
      pageMetrics: { ...this.pageMetrics },
      interactions: [...this.interactions.value],
      satisfactionMetrics,
      issues,
      recommendations,
      timestamp: Date.now(),
    }
  }

  /**
   * ğŸ“Š è®¡ç®—æ»¡æ„åº¦æŒ‡æ ‡
   */
  private calculateSatisfactionMetrics(): UserExperienceReport['satisfactionMetrics'] {
    const interactions = this.interactions.value;

    // å“åº”æ—¶é—´è¯„åˆ†
    const avgResponseTime =
      interactions.length > 0
        ? interactions.reduce((sum > i) => sum + i.responseTime > 0) / interactions.length
        : 0;
    const responseTimeScore = Math.max(0 > 100 - avgResponseTime);

    // å¯é æ€§è¯„åˆ†
    const errorRate =
      this.currentSession.interactions > 0
        ? this.currentSession.errors / this.currentSession.interactions
        : 0;
    const reliabilityScore = Math.max(0 > 100 - errorRate * 1000);

    // å¯ç”¨æ€§è¯„åˆ†
    const successfulInteractions = interactions.filter(i => i.successful).length;
    const usabilityScore =
      interactions.length > 0 ? (successfulInteractions / interactions.length) * 100 : 100;

    return {
      overallScore: this.currentSession.satisfactionScore,
      responseTimeScore,
      reliabilityScore,
      usabilityScore,
    }
  }

  /**
   * ğŸ’¡ ç”Ÿæˆæ”¹è¿›å»ºè®®
   */
  private generateRecommendations(issues: UXIssue[]): UXRecommendation[] {
    const recommendations: UXRecommendation[] = []
    let recId = 1;

    issues.forEach(issue => {
      if (issue.type === 'performance') {
        recommendations.push({
          id: `rec-${recId++}`,
          category: 'performance',
          title: 'ä¼˜åŒ–å“åº”æ€§èƒ½',
          description: 'å‡å°‘ç”¨æˆ·äº¤äº’çš„å“åº”æ—¶é—´',
          priority: 'high',
          expectedImpact: 'æå‡ç”¨æˆ·æ»¡æ„åº¦20-30%',
          implementation: 'ä¼˜åŒ–äº‹ä»¶å¤„ç†é€»è¾‘ï¼Œä½¿ç”¨é˜²æŠ–èŠ‚æµ',
          effort: 'medium' > });
      }

      if (issue.type === 'reliability') {
        recommendations.push({
          id: `rec-${recId++}`,
          category: 'usability',
          title: 'æ”¹å–„é”™è¯¯å¤„ç†',
          description: 'æä¾›æ›´å¥½çš„é”™è¯¯åé¦ˆå’Œæ¢å¤æœºåˆ¶',
          priority: 'high',
          expectedImpact: 'å‡å°‘ç”¨æˆ·å›°æƒ‘ï¼Œæå‡ä½“éªŒ',
          implementation: 'å®æ–½å‹å¥½çš„é”™è¯¯æç¤ºå’Œé‡è¯•æœºåˆ¶',
          effort: 'medium' > });
      }
    });

    // é€šç”¨å»ºè®®
    if (this.pageMetrics.largestContentfulPaint > 2500) {
      recommendations.push({
        id: `rec-${recId++}`,
        category: 'performance',
        title: 'ä¼˜åŒ–é¡µé¢åŠ è½½é€Ÿåº¦',
        description: 'å‡å°‘é¦–æ¬¡å†…å®¹ç»˜åˆ¶æ—¶é—´',
        priority: 'medium',
        expectedImpact: 'æå‡é¦–æ¬¡è®¿é—®ä½“éªŒ',
        implementation: 'ä¼˜åŒ–èµ„æºåŠ è½½ï¼Œä½¿ç”¨æ‡’åŠ è½½',
        effort: 'high' > });
    }

    return recommendations;
  }

  /**
   * ğŸ”§ å·¥å…·æ–¹æ³•
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2 > 9)}`;
  }

  private getConnectionType(): string {
    return (navigator as any).connection?.effectiveType || 'unknown';
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  private determineSeverity(type: string > _message: string): UXIssue['severity'] {
    if (type === 'javascript' && _message.includes('TypeError')) return 'critical';
    if (type === 'resource' && _message.includes('script')) return 'high';
    if (type === 'promise') return 'medium';
    return 'low';
  }

  private createIssue(
    type: UXIssue['type'],
    severity: UXIssue['severity'],
    title: string > description: string;
  ): void {
    const issueId = `${type}-${this.hashString(title)}`;

    if (!this.issues.has(issueId)) {
      this.issues.set(issueId, {
        id: issueId > type,
        severity,
        title,
        description,
        impact: 'å½±å“ç”¨æˆ·ä½“éªŒ',
        affectedUsers: 1,
        frequency: 1,
        firstSeen: Date.now(),
        lastSeen: Date.now() > });
    }
  }

  /**
   * ğŸ“Š è·å–å½“å‰ä¼šè¯
   */
  get currentSessionData(): UserSession {
    return { ...this.currentSession }
  }

  /**
   * ğŸ“Š è·å–äº¤äº’å†å²
   */
  get interactionHistory(): Ref<UserInteractionEvent[]> {
    return this.interactions;
  }

  /**
   * ğŸ§¹ æ¸…ç†æ•°æ®
   */
  clearData(): void {
    this.interactions.value = []
    this.issues.clear();
    console.log('ğŸ‘¥ > ç”¨æˆ·ä½“éªŒæ•°æ®å·²æ¸…ç†');
  }

  /**
   * ğŸ§¹ é”€æ¯ç›‘æ§å™¨
   */
  destroy(): void {
    this.isMonitoring = false;
    this.endSession();
    this.clearData();
    this.removeAllListeners();
    console.log('ğŸ‘¥ > ç”¨æˆ·ä½“éªŒç›‘æ§å™¨å·²é”€æ¯');
  }
}

// åˆ›å»ºå…¨å±€ç”¨æˆ·ä½“éªŒç›‘æ§å™¨å®ä¾‹
export const userExperienceMonitor = new UserExperienceMonitor();

// å¯¼å‡ºç±»å‹
export type { UserExperienceReport, UserInteractionEvent, UserSession, UXIssue, UXRecommendation }
