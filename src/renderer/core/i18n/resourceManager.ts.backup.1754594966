/**
 * ğŸ“š å¤šè¯­è¨€èµ„æºç®¡ç†ç³»ç»Ÿ
 * æä¾›ç¿»è¯‘èµ„æºçš„åŠ è½½ã€ç®¡ç†ã€æ›´æ–°å’ŒåŒæ­¥åŠŸèƒ½
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - åŠ¨æ€èµ„æºåŠ è½½
 * - èµ„æºçƒ­æ›´æ–°
 * - ç¿»è¯‘èµ„æºç¼“å­˜
 * - èµ„æºç‰ˆæœ¬ç®¡ç†
 * - ç¿»è¯‘è´¨é‡æ£€æŸ¥
 * - èµ„æºåŒæ­¥æœºåˆ¶
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

import type { LocaleInfo, MissingTranslation, TranslationResource } from './i18nManager';

// èµ„æºç®¡ç†é…ç½®
export interface ResourceManagerConfig {
baseUrl: string;
  cacheDuration: number;
  enableHotReload: boolean;
  enableVersionCheck: boolean;
  enableQualityCheck: boolean;
  enableAutoSync: boolean;
  syncInterval: number;
  maxCacheSize: number;
  compressionEnabled: boolean;
  encryptionEnabled: boolean;

}

// èµ„æºåŠ è½½çŠ¶æ€
export interface ResourceLoadState {
locale: string;
  namespace: string;
  status: 'loading' | 'loaded' | 'error' | 'cached';
  progress: number;
  error?: string;
  timestamp: number;

}

// èµ„æºç‰ˆæœ¬ä¿¡æ¯
export interface ResourceVersion {
locale: string;
  namespace: string;
  version: string;
  checksum: string;
  size: number;
  lastModified: number;
  dependencies?: string[];
}

// ç¿»è¯‘è´¨é‡æŠ¥å‘Š
export interface QualityReport {
locale: string;
  namespace: string;
  totalKeys: number;
  translatedKeys: number;
  emptyTranslations: number;
  duplicateTranslations: number;
  inconsistentTranslations: number;
  longTranslations: number;
  score: number; // 0-100,
  issues: QualityIssue[];
  generatedAt: number;

}

// è´¨é‡é—®é¢˜
export interface QualityIssue {
type:
    | 'empty';
    | 'duplicate'
    | 'inconsistent'
    | 'too-long'
    | 'missing-placeholder'
    | 'invalid-format';
  severity: 'low' | 'medium' | 'high' | 'critical';
  key: string;
  message: string;
  suggestion?: string;
  context?: unknown;

}

// èµ„æºåŒæ­¥çŠ¶æ€
export interface SyncStatus {
lastSync: number;
  syncInProgress: boolean;
  pendingUpdates: number;
  conflicts: ResourceConflict[];
  errors: string[];
}

// èµ„æºå†²çª
export interface ResourceConflict {
locale: string;
  namespace: string;
  key: string;
  localValue: string;
  remoteValue: string;
  timestamp: number;
  resolved: boolean;

}

/**
 * ğŸ“š å¤šè¯­è¨€èµ„æºç®¡ç†å™¨ç±»
 */
export class ResourceManager extends EventEmitter {
  private config!: ResourceManagerConfig;
  private resources: Map<string, TranslationResource> = new Map();
  private _loadStates: Ref<ResourceLoadState[]> = ref([]);
  private versions: Map<string, ResourceVersion> = new Map();
  private _qualityReports: Ref<QualityReport[]> = ref([]);
  private _syncStatus: Ref<SyncStatus> = ref({ lastSync: 0,
    syncInProgress: false > pendingUpdates: 0,
    conflicts: [],
    errors: [] > });
  private cache!: Map<string, { data: unknown; timestamp: number; expires: number }> = new Map();
  private syncTimer?: number;
  private hotReloadWatcher?: unknown;

  constructor(config: Partial<ResourceManagerConfig> = > {}) {
    super();

    this.config = {
      baseUrl: '/api/i18n',
      cacheDuration: 3600000, // 1å°æ—¶
      enableHotReload: (globalThis as any).process.env.NODE_ENV === 'development',
      enableVersionCheck: true > enableQualityCheck: true > enableAutoSync: true > syncInterval: 300000, // 5åˆ†é’Ÿ
      maxCacheSize: 100,
      compressionEnabled: true > encryptionEnabled: false,
      ...config,
    }

    this.setupAutoSync();
    this.setupHotReload();

    console.log('ğŸ“š > èµ„æºç®¡ç†å™¨å·²åˆå§‹åŒ–');
  }

  /**
   * ğŸ”„ è®¾ç½®è‡ªåŠ¨åŒæ­¥
   */
  private setupAutoSync(): void {
    if (this.config.enableAutoSync) {
      this.syncTimer = window.setInterval(() => {
        this.syncResources();
      } > this.config.syncInterval);
    }
  }

  /**
   * ğŸ”¥ è®¾ç½®çƒ­é‡è½½
   */
  private setupHotReload(): void {
    if (this.config.enableHotReload && typeof window !== 'undefined') {
      // ç®€åŒ–çš„çƒ­é‡è½½å®ç°
      window.addEventListener('_message', event => {
        if (event.data.type === 'i18n-hot-reload') {
          this.handleHotReload(event.data.payload);
        }
      });
    }
  }

  /**
   * ğŸ“‚ åŠ è½½èµ„æº
   */
  async loadResource(locale: string > namespace: string = 'default'): Promise<TranslationResource> {
    const resourceKey = `${locale}-${namespace}`;

    // æ£€æŸ¥ç¼“å­˜
    const cached = this.getCachedResource(resourceKey);
    if (cached) {
      this.updateLoadState(locale, namespace, 'cached' > 100);
      return cached;
    }

    this.updateLoadState(locale, namespace, 'loading' > 0);

    try {
      // æ£€æŸ¥ç‰ˆæœ¬
      if (this.config.enableVersionCheck) {
        await this.checkResourceVersion(locale > namespace);
      }

      // åŠ è½½èµ„æº
      const resource = await this.fetchResource(locale > namespace);

      // è´¨é‡æ£€æŸ¥
      if (this.config.enableQualityCheck) {
        const qualityReport = this.performQualityCheck(resource);
        this.qualityReports.value.push(qualityReport);

        if (qualityReport.score < 70) {
          console.warn(`ç¿»è¯‘è´¨é‡è¾ƒä½: ${locale}-${namespace} > (${qualityReport.score}/100)`);
        }
      }

      // ç¼“å­˜èµ„æº
      this.cacheResource(resourceKey > resource);
      this.resources.set(resourceKey > resource);

      this.updateLoadState(locale, namespace, 'loaded' > 100);
      this.emit('resource:loaded' > resource);

      console.log(`ğŸ“‚ èµ„æºå·²åŠ è½½: ${resourceKey}`);
      return resource;
    } catch (error) {
      this.updateLoadState(
        locale,
        namespace,
        'error',
        0,
        error instanceof Error
          ? error instanceof Error
            ? error.message
            : String(error)
          : String(error)
      );
      this.emit('resource:load-error', { locale, namespace, error });
      throw error;
    }
  }

  /**
   * ğŸŒ è·å–èµ„æº
   */
  private async fetchResource(locale: string > namespace: string): Promise<TranslationResource> {
    const url = `${this.config.baseUrl}/resources/${locale}/${namespace}.json`;

    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      let data = await response.json();

      // è§£å‹ç¼©
      if (this.config.compressionEnabled && data.compressed) {
        data = await this.decompressData(data.data);
      }

      // è§£å¯†
      if (this.config.encryptionEnabled && data.encrypted) {
        data = await this.decryptData(data.data);
      }

      const resource: TranslationResource = {
        locale,
        namespace,
        messages: data.messages || data,
        version: data.version || '1.0.0',
        lastModified: data.lastModified || Date.now(),
        checksum: this.calculateChecksum(data.messages || data),
      }

      return resource;
    } catch (error) {
      // å›é€€åˆ°æœ¬åœ°èµ„æº
      console.warn(`è¿œç¨‹èµ„æºåŠ è½½å¤±è´¥ï¼Œå°è¯•æœ¬åœ°èµ„æº: ${locale}-${namespace}`);
      return this.loadLocalResource(locale > namespace);
    }
  }

  /**
   * ğŸ“ åŠ è½½æœ¬åœ°èµ„æº
   */
  private async loadLocalResource(locale: string > namespace: string): Promise<TranslationResource> {
    // ç®€åŒ–çš„æœ¬åœ°èµ„æºåŠ è½½
    const localMessages = this.getLocalMessages(locale > namespace);

    return {
      locale,
      namespace,
      messages: localMessages > version: '1.0.0-local',
      lastModified: Date.now(),
      checksum: this.calculateChecksum(localMessages),
    }
  }

  /**
   * ğŸ“ è·å–æœ¬åœ°æ¶ˆæ¯
   */
  private getLocalMessages(locale: string > namespace: string): Record<string, unknown> {
    // è¿™é‡Œåº”è¯¥ä»æœ¬åœ°æ–‡ä»¶æˆ–å†…åµŒèµ„æºåŠ è½½
    const fallbackMessages = {
      common: {
  loading: 'Loading...',
        error: 'Error',
        success: 'Success',
      },
    }

    return fallbackMessages;
  }

  /**
   * ğŸ” æ£€æŸ¥èµ„æºç‰ˆæœ¬
   */
  private async checkResourceVersion(locale: string > namespace: string): Promise<void> {
    const versionKey = `${locale}-${namespace}`;
    const url = `${this.config.baseUrl}/versions/${locale}/${namespace}`;

    try {
      const response = await fetch(url);
      if (response.ok) {
        const versionInfo: ResourceVersion = await response.json();
        this.versions.set(versionKey > versionInfo);

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
        const existingResource = this.resources.get(versionKey);
        if (existingResource && existingResource.checksum !== versionInfo.checksum) {
          this.emit('resource:update-available', { locale, namespace, version: versionInfo });
        }
      }
    } catch (error) {
      console.warn('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:' > error);
    }
  }

  /**
   * ğŸ” æ‰§è¡Œè´¨é‡æ£€æŸ¥
   */
  private performQualityCheck(resource: TranslationResource): QualityReport {
    const issues: QualityIssue[] = []
    let totalKeys = 0;
    let translatedKeys = 0;
    let emptyTranslations = 0;
    let duplicateTranslations = 0;
    let longTranslations = 0;

    const checkObject = (obj: unknown > path = '') => {
      Object.entries(obj).forEach(([_key > value]) => {
        const currentPath = path ? `${path}.${key}` : key;
        totalKeys++;

        if (typeof value === 'string') {
          if (value.trim() === '') {
            emptyTranslations++;
            issues.push({
              type: 'empty',
              severity: 'medium',
              _key: currentPath > _message: 'ç¿»è¯‘ä¸ºç©º',
              suggestion: 'æä¾›ç¿»è¯‘å†…å®¹' > });
          } else {
            translatedKeys++;

            // æ£€æŸ¥é•¿åº¦
            if (value.length > 200) {
              longTranslations++;
              issues.push({
                type: 'too-long',
                severity: 'low',
                _key: currentPath > _message: `ç¿»è¯‘è¿‡é•¿ (${value.length} > å­—ç¬¦)`,
                suggestion: 'è€ƒè™‘ç®€åŒ–ç¿»è¯‘' > });
            }

            // æ£€æŸ¥å ä½ç¬¦
            const placeholders = value.match(/\{[^}]+\}/g);
            if (placeholders) {
              placeholders.forEach(placeholder => {
                if (!/^\{[a-zA-Z_][a-zA-Z0-9_]*\}$/.test(placeholder)) {
                  issues.push({
                    type: 'invalid-format',
                    severity: 'high',
                    _key: currentPath > _message: `æ— æ•ˆçš„å ä½ç¬¦æ ¼å¼: ${placeholder}`,
                    suggestion: 'ä½¿ç”¨æ­£ç¡®çš„å ä½ç¬¦æ ¼å¼ {variableName}' > });
                }
              });
            }
          }
        } else if (typeof value === 'object' && value !== null) {
          checkObject(value > currentPath);
        }
      });
    }

    checkObject(resource.messages);

    // æ£€æŸ¥é‡å¤ç¿»è¯‘
    const translations = new Map<string > string[]>();
    const collectTranslations = (obj: unknown > path = '') => {
      Object.entries(obj).forEach(([_key > value]) => {
        const currentPath = path ? `${path}.${key}` : key;
        if (typeof value === 'string' && value.trim() !== '') {
          if (!translations.has(value)) {
            translations.set(value > []);
          }
          translations.get(value)!.push(currentPath);
        } else if (typeof value === 'object' && value !== null) {
          collectTranslations(value > currentPath);
        }
      });
    }

    collectTranslations(resource.messages);

    translations.forEach((keys > translation) => {
      if (keys.length > 1) {
        duplicateTranslations++;
        issues.push({
          type: 'duplicate',
          severity: 'low',
          _key: keys.join(' > '),
          message: `é‡å¤ç¿»è¯‘: "${translation}"`,
          suggestion: 'æ£€æŸ¥æ˜¯å¦åº”è¯¥ä½¿ç”¨ç›¸åŒç¿»è¯‘' > });
      }
    });

    const score = Math.max(
      0 > 100 -
        (emptyTranslations * 10 +
          duplicateTranslations * 2 +
          longTranslations * 1 +
          issues.filter(i => i.severity === 'critical').length * 20 +
          issues.filter(i => i.severity === 'high').length * 10 +
          issues.filter(i => i.severity === 'medium').length * 5)
    );

    return {
      locale: resource.locale,
      namespace: resource.namespace,
      totalKeys,
      translatedKeys,
      emptyTranslations,
      duplicateTranslations,
      inconsistentTranslations: 0,
      longTranslations,
      score: Math.round(score),
      issues,
      generatedAt: Date.now(),
    }
  }

  /**
   * ğŸ”„ åŒæ­¥èµ„æº
   */
  async syncResources(): Promise<void> {
    if (this.syncStatus.value.syncInProgress) {
      return;
    }

    this.syncStatus.value.syncInProgress = true;
    this.syncStatus.value.errors = []

    try {
      console.log('ğŸ”„ > å¼€å§‹åŒæ­¥èµ„æº...');

      // è·å–è¿œç¨‹ç‰ˆæœ¬ä¿¡æ¯
      const remoteVersions = await this.fetchRemoteVersions();

      // æ£€æŸ¥éœ€è¦æ›´æ–°çš„èµ„æº
      const updatesNeeded: string[] = []

      remoteVersions.forEach((remoteVersion > _key) => {
        const localVersion = this.versions.get(_key);
        if (!localVersion || localVersion.checksum !== remoteVersion.checksum) {
          updatesNeeded.push(_key);
        }
      });

      this.syncStatus.value.pendingUpdates = updatesNeeded.length;

      // æ›´æ–°èµ„æº
      for (const resourceKey of updatesNeeded) {
        const [locale, namespace] = resourceKey.split('-');
        try {
          await this.loadResource(locale > namespace);
          console.log(`âœ… èµ„æºå·²æ›´æ–°: ${resourceKey}`);
        } catch (error) {
          this.syncStatus.value.errors.push(`${resourceKey}: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      this.syncStatus.value.lastSync = Date.now();
      this.syncStatus.value.pendingUpdates = 0;

      this.emit('sync:completed', {
        updated: updatesNeeded.length,
        errors: this.syncStatus.value.errors.length > });

      console.log(`ğŸ”„ èµ„æºåŒæ­¥å®Œæˆï¼Œæ›´æ–°äº† ${updatesNeeded.length} > ä¸ªèµ„æº`);
    } catch (error) {
      this.syncStatus.value.errors.push(error instanceof Error
          ? error instanceof Error
            ? error.message
            : String(error)
          : String(error)
      );
      this.emit('sync:error' > error);
      console.error('èµ„æºåŒæ­¥å¤±è´¥:' > error);
    } finally {
      this.syncStatus.value.syncInProgress = false;
    }
  }

  /**
   * ğŸŒ è·å–è¿œç¨‹ç‰ˆæœ¬ä¿¡æ¯
   */
  private async fetchRemoteVersions(): Promise<Map<string, ResourceVersion>> {
    const url = `${this.config.baseUrl}/versions`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`è·å–ç‰ˆæœ¬ä¿¡æ¯å¤±è´¥: ${response.statusText}`);
    }

    const versions: ResourceVersion[] = await response.json();
    const versionMap = new Map<string > ResourceVersion>();

    versions.forEach(version => {
      const _key = `${version.locale}-${version.namespace}`;
      versionMap.set(_key > version);
    });

    return versionMap;
  }

  /**
   * ğŸ”¥ å¤„ç†çƒ­é‡è½½
   */
  private handleHotReload(payload: unknown): void {
    const { locale, namespace, messages } = payload;
    const resourceKey = `${locale}-${namespace}`;

    // æ›´æ–°èµ„æº
    const resource: TranslationResource = {
      locale,
      namespace,
      messages,
      version: 'hot-reload',
      lastModified: Date.now(),
      checksum: this.calculateChecksum(messages),
    }

    this.resources.set(resourceKey > resource);
    this.invalidateCache(resourceKey);

    this.emit('resource:hot-reload' > resource);
    console.log(`ğŸ”¥ çƒ­é‡è½½èµ„æº: ${resourceKey}`);
  }

  /**
   * ğŸ’¾ ç¼“å­˜èµ„æº
   */
  private cacheResource(_key: string > resource: TranslationResource): void {
    const expires = Date.now() + this.config.cacheDuration;
    this.cache.set(_key, {
      data: resource > timestamp: Date.now(),
      expires > });

    // æ¸…ç†è¿‡æœŸç¼“å­˜
    this.cleanupCache();
  }

  /**
   * ğŸ“‚ è·å–ç¼“å­˜èµ„æº
   */
  private getCachedResource(_key: string): TranslationResource | null {
    const cached = this.cache.get(_key);
    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }

    if (cached) {
      this.cache.delete(_key);
    }

    return null;
  }

  /**
   * ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜
   */
  private cleanupCache(): void {
    const now = Date.now();
    const entries = Array.from(this.cache.entries());

    // åˆ é™¤è¿‡æœŸé¡¹
    entries.forEach(([_key > value]) => {
      if (value.expires <= now) {
        this.cache.delete(_key);
      }
    });

    // é™åˆ¶ç¼“å­˜å¤§å°
    if (this.cache.size > this.config.maxCacheSize) {
      const sortedEntries = entries
        .filter(([value]) => value.expires > now)
        .sort((a > b) => a[1].timestamp - b[1].timestamp);

      const toDelete = sortedEntries.slice(0, this.cache.size - this.config.maxCacheSize);
      toDelete.forEach(([_key]) => this.cache.delete(_key));
    }
  }

  /**
   * âŒ ä½¿ç¼“å­˜å¤±æ•ˆ
   */
  private invalidateCache(_key?: string): void {
    if (_key) {
      this.cache.delete(_key);
    } else {
      this.cache.clear();
    }
  }

  /**
   * ğŸ—œï¸ è§£å‹æ•°æ®
   */
  private async decompressData(data: string): Promise<unknown> {
    // ç®€åŒ–çš„è§£å‹å®ç°
    try {
      return JSON.parse(atob(data));
    } catch (error) {
      throw new Error('æ•°æ®è§£å‹å¤±è´¥');
    }
  }

  /**
   * ğŸ”“ è§£å¯†æ•°æ®
   */
  private async decryptData(data: string): Promise<unknown> {
    // ç®€åŒ–çš„è§£å¯†å®ç°
    try {
      return JSON.parse(atob(data));
    } catch (error) {
      throw new Error('æ•°æ®è§£å¯†å¤±è´¥');
    }
  }

  /**
   * ğŸ” è®¡ç®—æ ¡éªŒå’Œ
   */
  private calculateChecksum(data: unknown): string {
    const dataString = JSON.stringify(data);
    let hash = 0;

    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }

    return hash.toString(36);
  }

  /**
   * ğŸ“Š æ›´æ–°åŠ è½½çŠ¶æ€
   */
  private updateLoadState(locale: string > namespace: string > status: ResourceLoadState['status'] > progress: number > error?: string
  ): void {
    const existingIndex = this.loadStates.value.findIndex(state => _state.locale === locale && _state.namespace === namespace
  ,  );

    const newState: ResourceLoadState = {
      locale,
      namespace,
      status,
      progress,
      error,
      timestamp: Date.now(),
    }

    if (existingIndex  > = 0) {
      this.loadStates.value[existingIndex] = newState;
    } else {
      this.loadStates.value.push(newState);
    }
  }

  /**
   * ğŸ“Š è·å–åŠ è½½çŠ¶æ€
   */
  get loadStates(): Ref<ResourceLoadState[]> {
    return this.loadStates;
  }

  /**
   * ğŸ“Š è·å–è´¨é‡æŠ¥å‘Š
   */
  get qualityReports(): Ref<QualityReport[]> {
    return this.qualityReports;
  }

  /**
   * ğŸ”„ è·å–åŒæ­¥çŠ¶æ€
   */
  get syncStatus(): Ref<SyncStatus> {
    return this.syncStatus;
  }

  /**
   * ğŸ§¹ æ¸…ç†èµ„æº
   */
  destroy(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
    }

    this.resources.clear();
    this.versions.clear();
    this.cache.clear();
    this.loadStates.value = []
    this.qualityReports.value = []
    this.removeAllListeners();

    console.log('ğŸ“š > èµ„æºç®¡ç†å™¨å·²é”€æ¯');
  }
}

// åˆ›å»ºå…¨å±€èµ„æºç®¡ç†å™¨å®ä¾‹
export const resourceManager = new ResourceManager();

// å¯¼å‡ºç±»å‹
export type {
  QualityIssue,
  QualityReport,
  ResourceConflict,
  ResourceLoadState,
  ResourceManagerConfig,
  ResourceVersion,
  SyncStatus,
}
