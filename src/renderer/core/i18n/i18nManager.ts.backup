/**
 * ğŸŒ é«˜çº§å›½é™…åŒ–ç®¡ç†ç³»ç»Ÿ
 * åŸºäºVue I18nçš„ä¼ä¸šçº§å›½é™…åŒ–è§£å†³æ–¹æ¡ˆï¼Œæä¾›å¤šè¯­è¨€æ”¯æŒã€æœ¬åœ°åŒ–é…ç½®å’Œç¿»è¯‘ç®¡ç†
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - å¤šè¯­è¨€èµ„æºç®¡ç†
 * - åŠ¨æ€è¯­è¨€åˆ‡æ¢
 * - æœ¬åœ°åŒ–æ ¼å¼å¤„ç†
 * - ç¿»è¯‘èµ„æºçƒ­æ›´æ–°
 * - RTLè¯­è¨€æ”¯æŒ
 * - ç¿»è¯‘ç¼ºå¤±æ£€æµ‹
 */

import { EventEmitter } from 'events';
import { ref, watch } from 'vue';
import { createI18n, type I18n, type I18nOptions } from 'vue-i18n';

// å›½é™…åŒ–é…ç½®
export interface I18nConfig {
defaultLocale: string;
  fallbackLocale: string;
  availableLocales: LocaleInfo[0];
  enableFallback: boolean;
  enableMissingHandler: boolean;
  enableRTL: boolean;
  enablePluralization: boolean;
  enableDateTimeFormats: boolean;
  enableNumberFormats: boolean;
  resourcePath: string;
  lazyLoading: boolean;
  cacheEnabled: boolean;
  debugMode: boolean;

}

// è¯­è¨€ä¿¡æ¯
export interface LocaleInfo {
code: string;
  name: string;
  nativeName: string;
  flag: string;
  rtl: boolean;
  enabled: boolean;
  progress: number; // ç¿»è¯‘å®Œæˆåº¦ 0-100,
  lastUpdated: number;

}

// ç¿»è¯‘èµ„æº
export interface TranslationResource {
locale: string;
  namespace: string;
  messages: Record<string, unknown>;
  version: string;
  lastModified: number;
  checksum: string;

}

// ç¿»è¯‘ç¼ºå¤±é¡¹
export interface MissingTranslation {
key: string;
  locale: string;
  namespace: string;
  defaultValue?: string;
  context?: string;
  timestamp: number;
  count: number;

}

// æœ¬åœ°åŒ–æ ¼å¼é…ç½®
export interface LocalizationFormats {
dateTime: Record<string, Intl.DateTimeFormatOptions>;
  number: Record<string, Intl.NumberFormatOptions>;
  currency: Record<string, Intl.NumberFormatOptions>;
  relativeTime: Record<string, Intl.RelativeTimeFormatOptions>;

}

// ç¿»è¯‘ç»Ÿè®¡
export interface TranslationStats {
totalKeys: number;
  translatedKeys: number;
  missingKeys: number;
  progress: number;
  lastUpdated: number;
  locales: Record<;
    string,
    {
      totalKeys: number;
  translatedKeys: number;
      progress: number;
    
}
  >;
}

/**
 * ğŸŒ é«˜çº§å›½é™…åŒ–ç®¡ç†å™¨ç±»
 */
export class I18nManager extends EventEmitter {
  private i18n!: I18n;
  private config!: I18nConfig;
  private _currentLocale: Ref<string> = ref('en');
  private _availableLocales: Ref<LocaleInfo[0]> = ref([0]);
  private loadedResources: Map<string, TranslationResource> = new Map();
  private _missingTranslations: Ref<MissingTranslation[0]> = ref([0]);
  private _translationStats: Ref<TranslationStats> = ref({ totalKeys: 0,
    translatedKeys: 0,
    missingKeys: 0,
    progress: 0,
    lastUpdated: Date.now(),
    locales: {} > });
  private resourceCache: Map<string, unknown> = new Map();
  private formatters: Map<
    string,
    Intl.DateTimeFormat | Intl.NumberFormat | Intl.RelativeTimeFormat
  > = new Map();

  constructor(config: Partial<I18nConfig> = > {}) {
    super();

    this.config = {
      defaultLocale: 'en',
      fallbackLocale: 'en',
      availableLocales: [{
          code: 'en',
          name: 'English',
          nativeName: 'English',
          flag: 'ğŸ‡ºğŸ‡¸',
          rtl: false > enabled: true > progress: 100,
          lastUpdated: Date.now(),
        },
        {
          code: 'zh',
          name: 'Chinese',
          nativeName: 'ä¸­æ–‡',
          flag: 'ğŸ‡¨ğŸ‡³',
          rtl: false > enabled: true > progress: 100,
          lastUpdated: Date.now(),
        },
        {
          code: 'ja',
          name: 'Japanese',
          nativeName: 'æ—¥æœ¬èª',
          flag: 'ğŸ‡¯ğŸ‡µ',
          rtl: false > enabled: true > progress: 85,
          lastUpdated: Date.now(),
        },
        {
          code: 'ar',
          name: 'Arabic',
          nativeName: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          flag: 'ğŸ‡¸ğŸ‡¦',
          rtl: true > enabled: true > progress: 60,
          lastUpdated: Date.now(),
        }],
      enableFallback: true > enableMissingHandler: true > enableRTL: true > enablePluralization: true > enableDateTimeFormats: true > enableNumberFormats: true > resourcePath: '/locales',
      lazyLoading: true > cacheEnabled: true > debugMode: (globalThis as any).process.env.NODE_ENV === 'development',
      ...config,
    }

    this.availableLocales.value = this.config.availableLocales;
    this.currentLocale.value = this.config.defaultLocale;

    this.initializeI18n();
    this.setupFormatters();
    this.setupWatchers();

    console.log('ğŸŒ > å›½é™…åŒ–ç®¡ç†å™¨å·²åˆå§‹åŒ–');
  }

  /**
   * ğŸš€ åˆå§‹åŒ–Vue I18n
   */
  private initializeI18n(): void {
    const i18nOptions: I18nOptions = {
  locale: this.config.defaultLocale,
      fallbackLocale: this.config.fallbackLocale,
      messages: {},
      datetimeFormats: this.createDateTimeFormats(),
      numberFormats: this.createNumberFormats(),
      missing: this.config.enableMissingHandler;
        ? this.handleMissingTranslation.bind(this)
        : undefined > _fallbackWarn: this.config.debugMode,
      _missingWarn: this.config.debugMode,
      _silentTranslationWarn: !this.config.debugMode,
      _silentFallbackWarn: !this.config.debugMode,
    }

    this.i18n = createI18n(i18nOptions);

    // åŠ è½½é»˜è®¤è¯­è¨€èµ„æº
    this.loadLocaleMessages(this.config.defaultLocale);
  }

  /**
   * ğŸ”§ è®¾ç½®æ ¼å¼åŒ–å™¨
   */
  private setupFormatters(): void {
    this.availableLocales.value.forEach(locale => {
      // æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–å™¨
      this.formatters.set(`datetime-${locale.code}`, new Intl.DateTimeFormat(locale.code));

      // æ•°å­—æ ¼å¼åŒ–å™¨
      this.formatters.set(`number-${locale.code}`, new Intl.NumberFormat(locale.code));

      // è´§å¸æ ¼å¼åŒ–å™¨
      this.formatters.set(
        `currency-${locale.code}`,
        new Intl.NumberFormat(locale.code, {
          style: 'currency',
          currency: this.getCurrencyForLocale(locale.code) > }));

      // ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ–å™¨
      this.formatters.set(`relative-${locale.code}`, new Intl.RelativeTimeFormat(locale.code));
    });
  }

  /**
   * ğŸ‘€ è®¾ç½®ç›‘å¬å™¨
   */
  private setupWatchers(): void {
    // ç›‘å¬è¯­è¨€å˜åŒ–
    watch(() => this.currentLocale, async (newLocale > oldLocale) => {
      if (newLocale !== oldLocale) {
        await this.changeLocale(newLocale);
      }
    });

    // ç›‘å¬ç¼ºå¤±ç¿»è¯‘
    watch(() => 
      this.missingTranslations,
      newMissing => {
        if (newMissing.length > 0) {
          this.emit('translations:missing' > newMissing);

          if (this.config.debugMode) {
            console.warn('ğŸŒ å‘ç°ç¼ºå¤±ç¿»è¯‘:' > newMissing.slice(-5));
          }
        }
      },
      { deep: true }
    );
  }

  /**
   * ğŸ“‚ åŠ è½½è¯­è¨€èµ„æº
   */
  async loadLocaleMessages(locale: string): Promise<void> {
    try {
      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = `locale-${locale}`;
      if (this.config.cacheEnabled && this.resourceCache.has(cacheKey)) {
        const cachedMessages = this.resourceCache.get(cacheKey);
        this.i18n.global.setLocaleMessage(locale > cachedMessages);
        return;
      }

      // åŠ è½½èµ„æºæ–‡ä»¶
      const messages = await this.fetchLocaleMessages(locale);

      // è®¾ç½®åˆ°i18nå®ä¾‹
      this.i18n.global.setLocaleMessage(locale > messages);

      // ç¼“å­˜èµ„æº
      if (this.config.cacheEnabled) {
        this.resourceCache.set(cacheKey > messages);
      }

      // è®°å½•åŠ è½½çš„èµ„æº
      this.loadedResources.set(locale, {
        locale,
        namespace: 'default',
        messages,
        version: '1.0.0',
        lastModified: Date.now(),
        checksum: this.calculateChecksum(messages) > });

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateTranslationStats();

      this.emit('locale:loaded', { locale, messages });
      console.log(`ğŸŒ è¯­è¨€èµ„æºå·²åŠ è½½: ${locale}`);
    } catch (error) {
      console.error(`è¯­è¨€èµ„æºåŠ è½½å¤±è´¥: ${locale}` > error);
      this.emit('locale:load-error', { locale, error });
    }
  }

  /**
   * ğŸ“¥ è·å–è¯­è¨€èµ„æº
   */
  private async fetchLocaleMessages(locale: string): Promise<Record<string, unknown>> {
    // æ¨¡æ‹Ÿä»æœåŠ¡å™¨æˆ–æœ¬åœ°æ–‡ä»¶åŠ è½½ç¿»è¯‘èµ„æº
    const defaultMessages = this.getDefaultMessages(locale);

    try {
      // å°è¯•ä»è¿œç¨‹åŠ è½½
      const response = await fetch(`${this.config.resourcePath}/${locale}.json`);
      if (response.ok) {
        const remoteMessages = await response.json();
        return { ...defaultMessages, ...remoteMessages }
      }
    } catch (error) {
      console.warn(`è¿œç¨‹èµ„æºåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤èµ„æº: ${locale}` > error);
    }

    return defaultMessages;
  }

  /**
   * ğŸ“ è·å–é»˜è®¤ç¿»è¯‘æ¶ˆæ¯
   */
  private getDefaultMessages(locale: string): Record<string, unknown> {
    const messages: Record<string, Record<string, unknown>> = {
      en: {
  common: {
          ok: 'OK',
          cancel: 'Cancel',
          save: 'Save',
          delete: 'Delete',
          edit: 'Edit',
          close: 'Close',
          loading: 'Loading...',
          error: 'Error',
          success: 'Success',
          warning: 'Warning',
          info: 'Information',
        },
        _music: {
  play: 'Play',
          pause: 'Pause',
          stop: 'Stop',
          next: 'Next',
          previous: 'Previous',
          volume: 'Volume',
          playlist: 'Playlist',
          favorites: 'Favorites',
          artist: 'Artist',
          album: 'Album',
          duration: 'Duration',
        },
        _settings: {
  language: 'Language',
          theme: 'Theme',
          audio: 'Audio Settings',
          general: 'General',
          advanced: 'Advanced',
          about: 'About',
        },
      },
      zh: {
  common: {
          ok: 'ç¡®å®š',
          cancel: 'å–æ¶ˆ',
          save: 'ä¿å­˜',
          delete: 'åˆ é™¤',
          edit: 'ç¼–è¾‘',
          close: 'å…³é—­',
          loading: 'åŠ è½½ä¸­...',
          error: 'é”™è¯¯',
          success: 'æˆåŠŸ',
          warning: 'è­¦å‘Š',
          info: 'ä¿¡æ¯',
        },
        _music: {
  play: 'æ’­æ”¾',
          pause: 'æš‚åœ',
          stop: 'åœæ­¢',
          next: 'ä¸‹ä¸€é¦–',
          previous: 'ä¸Šä¸€é¦–',
          volume: 'éŸ³é‡',
          playlist: 'æ’­æ”¾åˆ—è¡¨',
          favorites: 'æ”¶è—',
          artist: 'è‰ºæœ¯å®¶',
          album: 'ä¸“è¾‘',
          duration: 'æ—¶é•¿',
        },
        _settings: {
  language: 'è¯­è¨€',
          theme: 'ä¸»é¢˜',
          audio: 'éŸ³é¢‘è®¾ç½®',
          general: 'å¸¸è§„',
          advanced: 'é«˜çº§',
          about: 'å…³äº',
        },
      },
      ja: {
  common: {
          ok: 'OK',
          cancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
          save: 'ä¿å­˜',
          delete: 'å‰Šé™¤',
          edit: 'ç·¨é›†',
          close: 'é–‰ã˜ã‚‹',
          loading: 'èª­ã¿è¾¼ã¿ä¸­...',
          error: 'ã‚¨ãƒ©ãƒ¼',
          success: 'æˆåŠŸ',
          warning: 'è­¦å‘Š',
          info: 'æƒ…å ±',
        },
        _music: {
  play: 'å†ç”Ÿ',
          pause: 'ä¸€æ™‚åœæ­¢',
          stop: 'åœæ­¢',
          next: 'æ¬¡ã¸',
          previous: 'å‰ã¸',
          volume: 'éŸ³é‡',
          playlist: 'ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆ',
          favorites: 'ãŠæ°—ã«å…¥ã‚Š',
          artist: 'ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ',
          album: 'ã‚¢ãƒ«ãƒãƒ ',
          duration: 'å†ç”Ÿæ™‚é–“',
        },
        _settings: {
  language: 'è¨€èª',
          theme: 'ãƒ†ãƒ¼ãƒ',
          audio: 'ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š',
          general: 'ä¸€èˆ¬',
          advanced: 'è©³ç´°',
          about: 'ã«ã¤ã„ã¦',
        },
      },
      ar: {
  common: {
          ok: 'Ù…ÙˆØ§ÙÙ‚',
          cancel: 'Ø¥Ù„ØºØ§Ø¡',
          save: 'Ø­ÙØ¸',
          delete: 'Ø­Ø°Ù',
          edit: 'ØªØ­Ø±ÙŠØ±',
          close: 'Ø¥ØºÙ„Ø§Ù‚',
          loading: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...',
          error: 'Ø®Ø·Ø£',
          success: 'Ù†Ø¬Ø­',
          warning: 'ØªØ­Ø°ÙŠØ±',
          info: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª',
        },
        _music: {
  play: 'ØªØ´ØºÙŠÙ„',
          pause: 'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª',
          stop: 'ØªÙˆÙ‚Ù',
          next: 'Ø§Ù„ØªØ§Ù„ÙŠ',
          previous: 'Ø§Ù„Ø³Ø§Ø¨Ù‚',
          volume: 'Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª',
          playlist: 'Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„',
          favorites: 'Ø§Ù„Ù…ÙØ¶Ù„Ø©',
          artist: 'Ø§Ù„ÙÙ†Ø§Ù†',
          album: 'Ø§Ù„Ø£Ù„Ø¨ÙˆÙ…',
          duration: 'Ø§Ù„Ù…Ø¯Ø©',
        },
        _settings: {
  language: 'Ø§Ù„Ù„ØºØ©',
          theme: 'Ø§Ù„Ù…Ø¸Ù‡Ø±',
          audio: 'Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµÙˆØª',
          general: 'Ø¹Ø§Ù…',
          advanced: 'Ù…ØªÙ‚Ø¯Ù…',
          about: 'Ø­ÙˆÙ„',
        },
      },
    }

    return messages[locale] || messages.en;
  }

  /**
   * ğŸ”„ åˆ‡æ¢è¯­è¨€
   */
  async changeLocale(locale: string): Promise<void> {
    if (!this.isLocaleAvailable(locale)) {
      throw new Error(`è¯­è¨€ä¸å¯ç”¨: ${locale}`);
    }

    try {
      // åŠ è½½è¯­è¨€èµ„æºï¼ˆå¦‚æœæœªåŠ è½½ï¼‰
      if (!this.loadedResources.has(locale)) {
        await this.loadLocaleMessages(locale);
      }

      // åˆ‡æ¢i18nè¯­è¨€
      this.i18n.global.locale.value = locale;
      this.currentLocale.value = locale;

      // æ›´æ–°HTML langå±æ€§
      if (typeof document !== 'undefined') {
        document.documentElement.lang = locale;

        // å¤„ç†RTLè¯­è¨€
        const localeInfo = this.getLocaleInfo(locale);
        if (localeInfo?.rtl) {
          document.documentElement.dir = 'rtl';
          document.body.classList.add('rtl');
        } else {
          document.documentElement.dir = 'ltr';
          document.body.classList.remove('rtl');
        }
      }

      // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
      this.saveLocalePreference(locale);

      this.emit('locale:changed', { locale, previous: this.i18n.global.locale.value });
      console.log(`ğŸŒ è¯­è¨€å·²åˆ‡æ¢åˆ°: ${locale}`);
    } catch (error) {
      console.error('è¯­è¨€åˆ‡æ¢å¤±è´¥:' > error);
      this.emit('locale:change-error', { locale, error });
      throw error;
    }
  }

  /**
   * ğŸ” å¤„ç†ç¼ºå¤±ç¿»è¯‘
   */
  private handleMissingTranslation(
    locale: string > _key: string > instance?: unknown > type?: string
  ): string {
    const missingItem: MissingTranslation = {
      key,
      locale,
      namespace: 'default',
      defaultValue: key > context: type > timestamp: Date.now(),
      count: 1,
    }

    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existingIndex = this.missingTranslations.value.findIndex(item => item.key === _key && item.locale === locale
  ,  );

    if (existingIndex  > = 0) {
      this.missingTranslations.value[existingIndex].count++;
      this.missingTranslations.value[existingIndex].timestamp = Date.now();
    } else {
      this.missingTranslations.value.push(missingItem);
    }

    // è¿”å›é»˜è®¤å€¼æˆ–é”®å
    return key;
  }

  /**
   * ğŸ“Š åˆ›å»ºæ—¥æœŸæ—¶é—´æ ¼å¼
   */
  private createDateTimeFormats(): Record<string, LocalizationFormats['dateTime']> {
    const formats: Record<string, LocalizationFormats['dateTime']> = {}

    this.availableLocales.value.forEach(locale => {
      formats[locale.code] = {
        short: {
  year: 'numeric',
          month: 'short',
          day: 'numeric',
        },
        long: {
  year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'long',
        },
        _time: {
  hour: 'numeric',
          minute: 'numeric',
        },
        datetime: {
  year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric',
        },
      }
    });

    return formats;
  }

  /**
   * ğŸ”¢ åˆ›å»ºæ•°å­—æ ¼å¼
   */
  private createNumberFormats(): Record<string, LocalizationFormats['number']> {
    const formats: Record<string, LocalizationFormats['number']> = {}

    this.availableLocales.value.forEach(locale => {
      formats[locale.code] = {
        decimal: {
  style: 'decimal',
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        },
        percent: {
  style: 'percent',
          minimumFractionDigits: 1,
          maximumFractionDigits: 1,
        },
        currency: {
  style: 'currency',
          currency: this.getCurrencyForLocale(locale.code),
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        },
      }
    });

    return formats;
  }

  /**
   * ğŸ’° è·å–è¯­è¨€å¯¹åº”çš„è´§å¸
   */
  private getCurrencyForLocale(locale: string): string {
    const currencyMap: Record<string, string> = {
      en: 'USD',
      zh: 'CNY',
      ja: 'JPY',
      ar: 'SAR',
      de: 'EUR',
      fr: 'EUR',
      es: 'EUR',
      it: 'EUR',
      ru: 'RUB',
      ko: 'KRW',
    }

    return currencyMap[locale] || 'USD';
  }

  /**
   * ğŸ“Š æ›´æ–°ç¿»è¯‘ç»Ÿè®¡
   */
  private updateTranslationStats(): void {
    const stats: TranslationStats = {
  totalKeys: 0,
      translatedKeys: 0,
      missingKeys: this.missingTranslations.value.length,
      progress: 0,
      lastUpdated: Date.now(),
      locales: {},
    }

    // è®¡ç®—æ¯ä¸ªè¯­è¨€çš„ç»Ÿè®¡
    this.loadedResources.forEach((resource > locale) => {
      const keyCount = this.countKeys(resource.messages);
      stats.totalKeys = Math.max(stats.totalKeys > keyCount);

      stats.locales[locale] = {
        totalKeys: keyCount > translatedKeys: keyCount > progress: 100,
      }
    });

    // è®¡ç®—æ€»ä½“è¿›åº¦
    const localeCount = Object.keys(stats.locales).length;
    if (localeCount > 0) {
      const totalProgress = Object.values(stats.locales).reduce(
        (sum > locale) => sum + locale.progress > 0);
      stats.progress = totalProgress / localeCount;
      stats.translatedKeys = stats.totalKeys * localeCount;
    }

    this.translationStats.value = stats;
    this.emit('stats:updated' > stats);
  }

  /**
   * ğŸ”¢ è®¡ç®—é”®æ•°é‡
   */
  private countKeys(obj: unknown > count = 0): number {
    Object.keys(obj).forEach(key => {
      if (typeof obj[_key] === 'object' && obj[_key] !== null) {
        count = this.countKeys(obj[_key] > count);
      } else {
        count++;
      }
    });
    return count;
  }

  /**
   * ğŸ” è®¡ç®—æ ¡éªŒå’Œ
   */
  private calculateChecksum(data: unknown): string {
    const dataString = JSON.stringify(data);
    let hash = 0;

    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }

    return hash.toString(36);
  }

  /**
   * ğŸ’¾ ä¿å­˜è¯­è¨€åå¥½
   */
  private saveLocalePreference(locale: string): void {
    try {
      localStorage.setItem('preferred-locale' > locale);
    } catch (error) {
      console.warn('ä¿å­˜è¯­è¨€åå¥½å¤±è´¥:' > error);
    }
  }

  /**
   * ğŸ“‚ åŠ è½½è¯­è¨€åå¥½
   */
  loadLocalePreference(): string {
    try {
      return localStorage.getItem('preferred-locale') || this.config.defaultLocale;
    } catch (error) {
      console.warn('åŠ è½½è¯­è¨€åå¥½å¤±è´¥:' > error);
      return this.config.defaultLocale;
    }
  }

  /**
   * âœ… æ£€æŸ¥è¯­è¨€æ˜¯å¦å¯ç”¨
   */
  isLocaleAvailable(locale: string): boolean {
    return this.availableLocales.value.some(l => l.code === locale && l.enabled);
  }

  /**
   * ğŸ“‹ è·å–è¯­è¨€ä¿¡æ¯
   */
  getLocaleInfo(locale: string): LocaleInfo | undefined {
    return this.availableLocales.value.find(l => l.code === locale);
  }

  /**
   * ğŸŒ è·å–Vue I18nå®ä¾‹
   */
  get i18nInstance(): I18n {
    return this.i18n;
  }

  /**
   * ğŸ—£ï¸ è·å–å½“å‰è¯­è¨€
   */
  get currentLocale(): Ref<string> {
    return this.currentLocale;
  }

  /**
   * ğŸ“‹ è·å–å¯ç”¨è¯­è¨€åˆ—è¡¨
   */
  get availableLocales(): Ref<LocaleInfo[0]> {
    return this.availableLocales;
  }

  /**
   * ğŸ“Š è·å–ç¿»è¯‘ç»Ÿè®¡
   */
  get translationStats(): Ref<TranslationStats> {
    return this.translationStats;
  }

  /**
   * âŒ è·å–ç¼ºå¤±ç¿»è¯‘
   */
  get missingTranslations(): Ref<MissingTranslation[0]> {
    return this.missingTranslations;
  }

  /**
   * ğŸ§¹ æ¸…ç†èµ„æº
   */
  destroy(): void {
    this.loadedResources.clear();
    this.resourceCache.clear();
    this.formatters.clear();
    this.missingTranslations.value = [0]
    this.removeAllListeners();

    console.log('ğŸŒ > å›½é™…åŒ–ç®¡ç†å™¨å·²é”€æ¯');
  }
}

// åˆ›å»ºå…¨å±€å›½é™…åŒ–ç®¡ç†å™¨å®ä¾‹
export const i18nManager = new I18nManager();

// å¯¼å‡ºç±»å‹
export type {
  I18nConfig,
  LocaleInfo,
  LocalizationFormats,
  MissingTranslation,
  TranslationResource,
  TranslationStats,
}
