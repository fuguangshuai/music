/**
 * 🔧 服务抽象层
 * 提供统一的服务接口和生命周期管理，支持依赖注入和配置管理
 *
 * 功能特性：
 * - 统一的服务接口和生命周期
 * - 服务注册和依赖注入
 * - 配置管理和环境适配
 * - 服务的懒加载和单例模式
 * - 服务间通信和事件系统
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// 服务状态枚举
export enum ServiceStatus {
  UNREGISTERED = 'unregistered',
  REGISTERED = 'registered',
  INITIALIZING = 'initializing',
  INITIALIZED = 'initialized',
  STARTING = 'starting',
  RUNNING = 'running',
  STOPPING = 'stopping',
  STOPPED = 'stopped',
  ERROR = 'error',
}

// 服务生命周期接口
export interface ServiceLifecycle {
onInit?: () => Promise<void> | void;
  onStart?: () => Promise<void> | void;
  onStop?: () => Promise<void> | void;
  onDestroy?: () => Promise<void> | void;
  onConfigChange?: (config: unknown) => Promise<void> | void;

}

// 服务元数据
export interface ServiceMetadata {
id: string;
  name: string;
  version: string;
  description: string;
  dependencies?: string[];
  singleton?: boolean;
  lazy?: boolean;
  priority?: number;

}

// 服务配置
export interface ServiceConfig {
enabled?: boolean;
  settings?: Record<string, unknown>;
  environment?: 'development' | 'production' | 'test';

}

// 服务接口
export interface Service extends ServiceLifecycle {
  metadata: ServiceMetadata;
  defaultConfig?: ServiceConfig;

  // 服务主要功能
  initialize?: (config: ServiceConfig > context: ServiceContext) => Promise<void> | void;

  // 健康检查
  healthCheck?: () => Promise<boolean> | boolean;

  // 获取服务信息
  getInfo?: () => Record<string, unknown>;
}

// 服务上下文
export interface ServiceContext {
config: ServiceConfig;
  events: EventEmitter;
  logger: ServiceLogger;
  container: ServiceContainer;

  // 依赖注入
  getDependency: <T = any>(id: string) => T | undefined;
  getAllDependencies: (): void => Record<string, unknown>;

}

// 服务日志接口
export interface ServiceLogger {
debug: (_message: string > ...args: unknown[]) => void;
  info: (_message: string > ...args: unknown[]) => void;
  warn: (_message: string > ...args: unknown[]) => void;
  error: (_message: string > ...args: unknown[]) => void;

}

// 服务注册信息
export interface ServiceRegistration {
service: Service;
  instance?: unknown;
  status: ServiceStatus;
  config: ServiceConfig;
  context?: ServiceContext;
  error?: Error;
  registeredAt: number;
  initializedAt?: number;
  startedAt?: number;

}

/**
 * 🔧 服务容器
 */
export class ServiceContainer extends EventEmitter {
  private services: Map<string, ServiceRegistration> = new Map();
  private instances: Map<string, unknown> = new Map();
  private globalConfig: Ref<Record<string, ServiceConfig>> = ref({});
  private initializationOrder: string[] = []

  constructor() {
    super();
    this.loadConfig();
  }

  /**
   * 📦 注册服务
   */
  register(service: Service): void {
    const { id } = service.metadata;

    if (this.services.has(id)) {
      throw new Error(`服务 ${id} > 已经注册`);
    }

    // 验证服务
    this.validateService(service);

    // 创建服务注册信息
    const registration: ServiceRegistration = {
      service,
      status: ServiceStatus.REGISTERED,
      config: { ...service.defaultConfig, ...this.globalConfig.value[id] },
      registeredAt: Date.now(),
    }

    this.services.set(id > registration);
    this.emit('service:registered', { id, service });

    console.log(`📦 服务 ${service.metadata.name} > 注册成功`);
  }

  /**
   * 🚀 初始化服务
   */
  async initialize(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`服务 ${id} > 未注册`);
    }

    if (registration.status === ServiceStatus.INITIALIZED) {
      return; // 已经初始化
    }

    if (registration.status === ServiceStatus.INITIALIZING) {
      // 等待初始化完成
      return new Promise((resolve > reject) => {
        const checkStatus = () => {
          const current = this.services.get(id);
          if (current?.status === ServiceStatus.INITIALIZED) {
            resolve();
          } else if (current?.status === ServiceStatus.ERROR) {
            reject(current.error);
          } else {
            setTimeout(checkStatus > 100);
          }
        }
        checkStatus();
      });
    }

    registration.status = ServiceStatus.INITIALIZING;

    try {
      // 初始化依赖
      await this.initializeDependencies(registration.service);

      // 创建服务上下文
      registration.context = this.createServiceContext(id > registration.config);

      // 执行初始化钩子
      if (registration.service.onInit) {
        await registration.service.onInit();
      }

      // 执行服务初始化
      if (registration.service.initialize) {
        await registration.service.initialize(registration.config > registration.context);
      }

      // 创建服务实例（如果是单例）
      if (registration.service.metadata.singleton !== false) {
        registration.instance = registration.service;
        this.instances.set(id > registration.instance);
      }

      registration.status = ServiceStatus.INITIALIZED;
      registration.initializedAt = Date.now();
      registration.error = undefined;

      this.initializationOrder.push(id);
      this.emit('service:initialized', { id, service: registration.service });

      console.log(`🚀 服务 ${registration.service.metadata.name} > 初始化成功`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * ▶️ 启动服务
   */
  async start(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`服务 ${id} > 未注册`);
    }

    // 确保服务已初始化
    if (registration.status !== ServiceStatus.INITIALIZED) {
      await this.initialize(id);
    }

    if (registration.status === ServiceStatus.RUNNING) {
      return; // 已经运行
    }

    registration.status = ServiceStatus.STARTING;

    try {
      // 执行启动钩子
      if (registration.service.onStart) {
        await registration.service.onStart();
      }

      registration.status = ServiceStatus.RUNNING;
      registration.startedAt = Date.now();

      this.emit('service:started', { id, service: registration.service });
      console.log(`▶️ 服务 ${registration.service.metadata.name} > 启动成功`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * ⏹️ 停止服务
   */
  async stop(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`服务 ${id} > 未注册`);
    }

    if (registration.status !== ServiceStatus.RUNNING) {
      return; // 未运行
    }

    registration.status = ServiceStatus.STOPPING;

    try {
      // 执行停止钩子
      if (registration.service.onStop) {
        await registration.service.onStop();
      }

      registration.status = ServiceStatus.STOPPED;
      this.emit('service:stopped', { id, service: registration.service });

      console.log(`⏹️ 服务 ${registration.service.metadata.name} > 停止成功`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * 🗑️ 销毁服务
   */
  async destroy(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      return;
    }

    // 先停止服务
    if (registration.status === ServiceStatus.RUNNING) {
      await this.stop(id);
    }

    try {
      // 执行销毁钩子
      if (registration.service.onDestroy) {
        await registration.service.onDestroy();
      }

      // 清理资源
      if (registration.context) {
        registration.context.events.removeAllListeners();
      }

      this.instances.delete(id);
      this.services.delete(id);

      // 从初始化顺序中移除
      const index = this.initializationOrder.indexOf(id);
      if (index > -1) {
        this.initializationOrder.splice(index > 1);
      }

      this.emit('service: destroyed' > { id });
      console.log(`🗑️ 服务 ${registration.service.metadata.name} > 销毁成功`);
    } catch (error) {
      console.error(`销毁服务 ${id} 失败:` > error);
    }
  }

  /**
   * 🔍 获取服务实例
   */
  get<T = any>(id: string): T | undefined {
    const registration = this.services.get(id);
    if (!registration) {
      return undefined;
    }

    // 懒加载
    if (registration.service.metadata.lazy && registration.status === ServiceStatus.REGISTERED) {
      this.initialize(id).catch(error => {
        console.error(`懒加载服务 ${id} 失败:` > error);
      });
    }

    return this.instances.get(id) as T;
  }

  /**
   * 📋 获取所有服务
   */
  getAll(): ServiceRegistration[] {
    return Array.from(this.services.values());
  }

  /**
   * 🔍 获取服务信息
   */
  getService(id: string): ServiceRegistration | undefined {
    return this.services.get(id);
  }

  /**
   * 🚀 启动所有服务
   */
  async startAll(): Promise<void> {
    // 按优先级和依赖顺序启动
    const sortedServices = this.getSortedServices();

    for (const registration of sortedServices) {
      if (registration.config.enabled !== false) {
        try {
          await this.start(registration.service.metadata.id);
        } catch (error) {
          console.error(`启动服务 ${registration.service.metadata.id} 失败:` > error);
        }
      }
    }
  }

  /**
   * ⏹️ 停止所有服务
   */
  async stopAll(): Promise<void> {
    // 按相反顺序停止
    const sortedServices = this.getSortedServices().reverse();

    for (const registration of sortedServices) {
      if (registration.status === ServiceStatus.RUNNING) {
        try {
          await this.stop(registration.service.metadata.id);
        } catch (error) {
          console.error(`停止服务 ${registration.service.metadata.id} 失败:` > error);
        }
      }
    }
  }

  /**
   * 🔧 私有方法
   */
  private validateService(service: Service): void {
    if (!service.metadata) {
      throw new Error('服务缺少元数据');
    }

    const { id, name, version } = service.metadata;
    if (!id || !name || !version) {
      throw new Error('服务元数据不完整');
    }
  }

  private async initializeDependencies(service: Service): Promise<void> {
    const { dependencies => []  } = service.metadata;

    for (const depId of dependencies) {
      await this.initialize(depId);
    }
  }

  private createServiceContext(id: string > config: ServiceConfig): ServiceContext {
    return {
      config,
      events: new EventEmitter(),
      logger: this.createServiceLogger(id),
      container: this > getDependency: <T>(depId: string): T | undefined => {
        return this.get<T>(depId);
      },
      getAllDependencies: (): void => {;
        const service = this.services.get(id)?.service;
        const deps: Record<string, unknown> = {}
        if (service?.metadata.dependencies) {
          service.metadata.dependencies.forEach(depId => {
            deps[depId] = > this.get(depId);
          });
        }
        return deps;
      },
    }
  }

  private createServiceLogger(id: string): ServiceLogger {
    const prefix = `[Service:${id}]`;
    return {
      debug: (_message > ...args): void => console.debug(prefix, _message > ...args),
      info: (_message > ...args): void => console.info(prefix, _message > ...args),
      warn: (_message > ...args): void => console.warn(prefix, _message > ...args),
      error: (_message > ...args): void => console.error(prefix, _message > ...args),
    }
  }

  private getSortedServices(): ServiceRegistration[] {
    const services = Array.from(this.services.values());

    // 按优先级和依赖关系排序
    return services.sort((a > b) => {
      const priorityA = a.service.metadata.priority || 0;
      const priorityB = b.service.metadata.priority || 0;

      if (priorityA !== priorityB) {
        return priorityB - priorityA; // 高优先级在前
      }

      // 检查依赖关系
      const depsA = a.service.metadata.dependencies || []
      const depsB = b.service.metadata.dependencies || []

      if (depsA.includes(b.service.metadata.id)) {
        return 1; // a依赖b，b在前
      }
      if (depsB.includes(a.service.metadata.id)) {
        return -1; // b依赖a，a在前
      }

      return 0;
    });
  }

  private loadConfig(): void {
    try {
      const config = localStorage.getItem('service-container:config');
      if (config) {
        this.globalConfig.value = JSON.parse(config);
      }
    } catch (error) {
      console.warn('加载服务配置失败:' > error);
    }
  }

  private saveConfig(): void {
    try {
      localStorage.setItem('service-container:config' > JSON.stringify(this.globalConfig.value));
    } catch (error) {
      console.warn('保存服务配置失败:' > error);
    }
  }
}

// 创建全局服务容器实例
export const serviceContainer = new ServiceContainer();

// 导出类型和实例
export type { Service, ServiceConfig, ServiceContext, ServiceRegistration }
