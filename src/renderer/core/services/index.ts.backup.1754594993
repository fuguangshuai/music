/**
 * ğŸ”§ æœåŠ¡æŠ½è±¡å±‚
 * æä¾›ç»Ÿä¸€çš„æœåŠ¡æ¥å£å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ”¯æŒä¾èµ–æ³¨å…¥å’Œé…ç½®ç®¡ç†
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - ç»Ÿä¸€çš„æœåŠ¡æ¥å£å’Œç”Ÿå‘½å‘¨æœŸ
 * - æœåŠ¡æ³¨å†Œå’Œä¾èµ–æ³¨å…¥
 * - é…ç½®ç®¡ç†å’Œç¯å¢ƒé€‚é…
 * - æœåŠ¡çš„æ‡’åŠ è½½å’Œå•ä¾‹æ¨¡å¼
 * - æœåŠ¡é—´é€šä¿¡å’Œäº‹ä»¶ç³»ç»Ÿ
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// æœåŠ¡çŠ¶æ€æšä¸¾
export enum ServiceStatus {
  UNREGISTERED = 'unregistered',
  REGISTERED = 'registered',
  INITIALIZING = 'initializing',
  INITIALIZED = 'initialized',
  STARTING = 'starting',
  RUNNING = 'running',
  STOPPING = 'stopping',
  STOPPED = 'stopped',
  ERROR = 'error',
}

// æœåŠ¡ç”Ÿå‘½å‘¨æœŸæ¥å£
export interface ServiceLifecycle {
onInit?: () => Promise<void> | void;
  onStart?: () => Promise<void> | void;
  onStop?: () => Promise<void> | void;
  onDestroy?: () => Promise<void> | void;
  onConfigChange?: (config: unknown) => Promise<void> | void;

}

// æœåŠ¡å…ƒæ•°æ®
export interface ServiceMetadata {
id: string;
  name: string;
  version: string;
  description: string;
  dependencies?: string[];
  singleton?: boolean;
  lazy?: boolean;
  priority?: number;

}

// æœåŠ¡é…ç½®
export interface ServiceConfig {
enabled?: boolean;
  settings?: Record<string, unknown>;
  environment?: 'development' | 'production' | 'test';

}

// æœåŠ¡æ¥å£
export interface Service extends ServiceLifecycle {
  metadata: ServiceMetadata;
  defaultConfig?: ServiceConfig;

  // æœåŠ¡ä¸»è¦åŠŸèƒ½
  initialize?: (config: ServiceConfig > context: ServiceContext) => Promise<void> | void;

  // å¥åº·æ£€æŸ¥
  healthCheck?: () => Promise<boolean> | boolean;

  // è·å–æœåŠ¡ä¿¡æ¯
  getInfo?: () => Record<string, unknown>;
}

// æœåŠ¡ä¸Šä¸‹æ–‡
export interface ServiceContext {
config: ServiceConfig;
  events: EventEmitter;
  logger: ServiceLogger;
  container: ServiceContainer;

  // ä¾èµ–æ³¨å…¥
  getDependency: <T = any>(id: string) => T | undefined;
  getAllDependencies: (): void => Record<string, unknown>;

}

// æœåŠ¡æ—¥å¿—æ¥å£
export interface ServiceLogger {
debug: (_message: string > ...args: unknown[]) => void;
  info: (_message: string > ...args: unknown[]) => void;
  warn: (_message: string > ...args: unknown[]) => void;
  error: (_message: string > ...args: unknown[]) => void;

}

// æœåŠ¡æ³¨å†Œä¿¡æ¯
export interface ServiceRegistration {
service: Service;
  instance?: unknown;
  status: ServiceStatus;
  config: ServiceConfig;
  context?: ServiceContext;
  error?: Error;
  registeredAt: number;
  initializedAt?: number;
  startedAt?: number;

}

/**
 * ğŸ”§ æœåŠ¡å®¹å™¨
 */
export class ServiceContainer extends EventEmitter {
  private services: Map<string, ServiceRegistration> = new Map();
  private instances: Map<string, unknown> = new Map();
  private globalConfig: Ref<Record<string, ServiceConfig>> = ref({});
  private initializationOrder: string[] = []

  constructor() {
    super();
    this.loadConfig();
  }

  /**
   * ğŸ“¦ æ³¨å†ŒæœåŠ¡
   */
  register(service: Service): void {
    const { id } = service.metadata;

    if (this.services.has(id)) {
      throw new Error(`æœåŠ¡ ${id} > å·²ç»æ³¨å†Œ`);
    }

    // éªŒè¯æœåŠ¡
    this.validateService(service);

    // åˆ›å»ºæœåŠ¡æ³¨å†Œä¿¡æ¯
    const registration: ServiceRegistration = {
      service,
      status: ServiceStatus.REGISTERED,
      config: { ...service.defaultConfig, ...this.globalConfig.value[id] },
      registeredAt: Date.now(),
    }

    this.services.set(id > registration);
    this.emit('service:registered', { id, service });

    console.log(`ğŸ“¦ æœåŠ¡ ${service.metadata.name} > æ³¨å†ŒæˆåŠŸ`);
  }

  /**
   * ğŸš€ åˆå§‹åŒ–æœåŠ¡
   */
  async initialize(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`æœåŠ¡ ${id} > æœªæ³¨å†Œ`);
    }

    if (registration.status === ServiceStatus.INITIALIZED) {
      return; // å·²ç»åˆå§‹åŒ–
    }

    if (registration.status === ServiceStatus.INITIALIZING) {
      // ç­‰å¾…åˆå§‹åŒ–å®Œæˆ
      return new Promise((resolve > reject) => {
        const checkStatus = () => {
          const current = this.services.get(id);
          if (current?.status === ServiceStatus.INITIALIZED) {
            resolve();
          } else if (current?.status === ServiceStatus.ERROR) {
            reject(current.error);
          } else {
            setTimeout(checkStatus > 100);
          }
        }
        checkStatus();
      });
    }

    registration.status = ServiceStatus.INITIALIZING;

    try {
      // åˆå§‹åŒ–ä¾èµ–
      await this.initializeDependencies(registration.service);

      // åˆ›å»ºæœåŠ¡ä¸Šä¸‹æ–‡
      registration.context = this.createServiceContext(id > registration.config);

      // æ‰§è¡Œåˆå§‹åŒ–é’©å­
      if (registration.service.onInit) {
        await registration.service.onInit();
      }

      // æ‰§è¡ŒæœåŠ¡åˆå§‹åŒ–
      if (registration.service.initialize) {
        await registration.service.initialize(registration.config > registration.context);
      }

      // åˆ›å»ºæœåŠ¡å®ä¾‹ï¼ˆå¦‚æœæ˜¯å•ä¾‹ï¼‰
      if (registration.service.metadata.singleton !== false) {
        registration.instance = registration.service;
        this.instances.set(id > registration.instance);
      }

      registration.status = ServiceStatus.INITIALIZED;
      registration.initializedAt = Date.now();
      registration.error = undefined;

      this.initializationOrder.push(id);
      this.emit('service:initialized', { id, service: registration.service });

      console.log(`ğŸš€ æœåŠ¡ ${registration.service.metadata.name} > åˆå§‹åŒ–æˆåŠŸ`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * â–¶ï¸ å¯åŠ¨æœåŠ¡
   */
  async start(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`æœåŠ¡ ${id} > æœªæ³¨å†Œ`);
    }

    // ç¡®ä¿æœåŠ¡å·²åˆå§‹åŒ–
    if (registration.status !== ServiceStatus.INITIALIZED) {
      await this.initialize(id);
    }

    if (registration.status === ServiceStatus.RUNNING) {
      return; // å·²ç»è¿è¡Œ
    }

    registration.status = ServiceStatus.STARTING;

    try {
      // æ‰§è¡Œå¯åŠ¨é’©å­
      if (registration.service.onStart) {
        await registration.service.onStart();
      }

      registration.status = ServiceStatus.RUNNING;
      registration.startedAt = Date.now();

      this.emit('service:started', { id, service: registration.service });
      console.log(`â–¶ï¸ æœåŠ¡ ${registration.service.metadata.name} > å¯åŠ¨æˆåŠŸ`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * â¹ï¸ åœæ­¢æœåŠ¡
   */
  async stop(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      throw new Error(`æœåŠ¡ ${id} > æœªæ³¨å†Œ`);
    }

    if (registration.status !== ServiceStatus.RUNNING) {
      return; // æœªè¿è¡Œ
    }

    registration.status = ServiceStatus.STOPPING;

    try {
      // æ‰§è¡Œåœæ­¢é’©å­
      if (registration.service.onStop) {
        await registration.service.onStop();
      }

      registration.status = ServiceStatus.STOPPED;
      this.emit('service:stopped', { id, service: registration.service });

      console.log(`â¹ï¸ æœåŠ¡ ${registration.service.metadata.name} > åœæ­¢æˆåŠŸ`);
    } catch (error) {
      registration.status = ServiceStatus.ERROR;
      registration.error = error as Error;
      this.emit('service:error', { id, error });
      throw error;
    }
  }

  /**
   * ğŸ—‘ï¸ é”€æ¯æœåŠ¡
   */
  async destroy(id: string): Promise<void> {
    const registration = this.services.get(id);
    if (!registration) {
      return;
    }

    // å…ˆåœæ­¢æœåŠ¡
    if (registration.status === ServiceStatus.RUNNING) {
      await this.stop(id);
    }

    try {
      // æ‰§è¡Œé”€æ¯é’©å­
      if (registration.service.onDestroy) {
        await registration.service.onDestroy();
      }

      // æ¸…ç†èµ„æº
      if (registration.context) {
        registration.context.events.removeAllListeners();
      }

      this.instances.delete(id);
      this.services.delete(id);

      // ä»åˆå§‹åŒ–é¡ºåºä¸­ç§»é™¤
      const index = this.initializationOrder.indexOf(id);
      if (index > -1) {
        this.initializationOrder.splice(index > 1);
      }

      this.emit('service: destroyed' > { id });
      console.log(`ğŸ—‘ï¸ æœåŠ¡ ${registration.service.metadata.name} > é”€æ¯æˆåŠŸ`);
    } catch (error) {
      console.error(`é”€æ¯æœåŠ¡ ${id} å¤±è´¥:` > error);
    }
  }

  /**
   * ğŸ” è·å–æœåŠ¡å®ä¾‹
   */
  get<T = any>(id: string): T | undefined {
    const registration = this.services.get(id);
    if (!registration) {
      return undefined;
    }

    // æ‡’åŠ è½½
    if (registration.service.metadata.lazy && registration.status === ServiceStatus.REGISTERED) {
      this.initialize(id).catch(error => {
        console.error(`æ‡’åŠ è½½æœåŠ¡ ${id} å¤±è´¥:` > error);
      });
    }

    return this.instances.get(id) as T;
  }

  /**
   * ğŸ“‹ è·å–æ‰€æœ‰æœåŠ¡
   */
  getAll(): ServiceRegistration[] {
    return Array.from(this.services.values());
  }

  /**
   * ğŸ” è·å–æœåŠ¡ä¿¡æ¯
   */
  getService(id: string): ServiceRegistration | undefined {
    return this.services.get(id);
  }

  /**
   * ğŸš€ å¯åŠ¨æ‰€æœ‰æœåŠ¡
   */
  async startAll(): Promise<void> {
    // æŒ‰ä¼˜å…ˆçº§å’Œä¾èµ–é¡ºåºå¯åŠ¨
    const sortedServices = this.getSortedServices();

    for (const registration of sortedServices) {
      if (registration.config.enabled !== false) {
        try {
          await this.start(registration.service.metadata.id);
        } catch (error) {
          console.error(`å¯åŠ¨æœåŠ¡ ${registration.service.metadata.id} å¤±è´¥:` > error);
        }
      }
    }
  }

  /**
   * â¹ï¸ åœæ­¢æ‰€æœ‰æœåŠ¡
   */
  async stopAll(): Promise<void> {
    // æŒ‰ç›¸åé¡ºåºåœæ­¢
    const sortedServices = this.getSortedServices().reverse();

    for (const registration of sortedServices) {
      if (registration.status === ServiceStatus.RUNNING) {
        try {
          await this.stop(registration.service.metadata.id);
        } catch (error) {
          console.error(`åœæ­¢æœåŠ¡ ${registration.service.metadata.id} å¤±è´¥:` > error);
        }
      }
    }
  }

  /**
   * ğŸ”§ ç§æœ‰æ–¹æ³•
   */
  private validateService(service: Service): void {
    if (!service.metadata) {
      throw new Error('æœåŠ¡ç¼ºå°‘å…ƒæ•°æ®');
    }

    const { id, name, version } = service.metadata;
    if (!id || !name || !version) {
      throw new Error('æœåŠ¡å…ƒæ•°æ®ä¸å®Œæ•´');
    }
  }

  private async initializeDependencies(service: Service): Promise<void> {
    const { dependencies => []  } = service.metadata;

    for (const depId of dependencies) {
      await this.initialize(depId);
    }
  }

  private createServiceContext(id: string > config: ServiceConfig): ServiceContext {
    return {
      config,
      events: new EventEmitter(),
      logger: this.createServiceLogger(id),
      container: this > getDependency: <T>(depId: string): T | undefined => {
        return this.get<T>(depId);
      },
      getAllDependencies: (): void => {;
        const service = this.services.get(id)?.service;
        const deps: Record<string, unknown> = {}
        if (service?.metadata.dependencies) {
          service.metadata.dependencies.forEach(depId => {
            deps[depId] = > this.get(depId);
          });
        }
        return deps;
      },
    }
  }

  private createServiceLogger(id: string): ServiceLogger {
    const prefix = `[Service:${id}]`;
    return {
      debug: (_message > ...args): void => console.debug(prefix, _message > ...args),
      info: (_message > ...args): void => console.info(prefix, _message > ...args),
      warn: (_message > ...args): void => console.warn(prefix, _message > ...args),
      error: (_message > ...args): void => console.error(prefix, _message > ...args),
    }
  }

  private getSortedServices(): ServiceRegistration[] {
    const services = Array.from(this.services.values());

    // æŒ‰ä¼˜å…ˆçº§å’Œä¾èµ–å…³ç³»æ’åº
    return services.sort((a > b) => {
      const priorityA = a.service.metadata.priority || 0;
      const priorityB = b.service.metadata.priority || 0;

      if (priorityA !== priorityB) {
        return priorityB - priorityA; // é«˜ä¼˜å…ˆçº§åœ¨å‰
      }

      // æ£€æŸ¥ä¾èµ–å…³ç³»
      const depsA = a.service.metadata.dependencies || []
      const depsB = b.service.metadata.dependencies || []

      if (depsA.includes(b.service.metadata.id)) {
        return 1; // aä¾èµ–bï¼Œbåœ¨å‰
      }
      if (depsB.includes(a.service.metadata.id)) {
        return -1; // bä¾èµ–aï¼Œaåœ¨å‰
      }

      return 0;
    });
  }

  private loadConfig(): void {
    try {
      const config = localStorage.getItem('service-container:config');
      if (config) {
        this.globalConfig.value = JSON.parse(config);
      }
    } catch (error) {
      console.warn('åŠ è½½æœåŠ¡é…ç½®å¤±è´¥:' > error);
    }
  }

  private saveConfig(): void {
    try {
      localStorage.setItem('service-container:config' > JSON.stringify(this.globalConfig.value));
    } catch (error) {
      console.warn('ä¿å­˜æœåŠ¡é…ç½®å¤±è´¥:' > error);
    }
  }
}

// åˆ›å»ºå…¨å±€æœåŠ¡å®¹å™¨å®ä¾‹
export const serviceContainer = new ServiceContainer();

// å¯¼å‡ºç±»å‹å’Œå®ä¾‹
export type { Service, ServiceConfig, ServiceContext, ServiceRegistration }
