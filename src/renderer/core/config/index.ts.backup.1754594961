/**
 * âš™ï¸ ç»Ÿä¸€é…ç½®ç®¡ç†ç³»ç»Ÿ
 * æä¾›å¤šå±‚çº§é…ç½®ç®¡ç†ï¼Œæ”¯æŒç¯å¢ƒå˜é‡ã€ç”¨æˆ·é…ç½®ã€é»˜è®¤é…ç½®çš„å±‚çº§ç®¡ç†
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - å¤šå±‚çº§é…ç½®ï¼ˆé»˜è®¤ã€ç¯å¢ƒã€ç”¨æˆ·ï¼‰
 * - é…ç½®éªŒè¯å’Œç±»å‹å®‰å…¨
 * - é…ç½®çš„åŠ¨æ€æ›´æ–°å’ŒæŒä¹…åŒ–
 * - é…ç½®å˜æ›´ç›‘å¬å’Œé€šçŸ¥
 * - ç¯å¢ƒé€‚é…å’Œç‰¹æ€§å¼€å…³
 */

import { EventEmitter } from 'events';
import { ref, watch } from 'vue';

// é…ç½®å±‚çº§æšä¸¾
export enum ConfigLevel {
  DEFAULT = 'default',
  ENVIRONMENT = 'environment',
  USER = 'user',
  RUNTIME = 'runtime',
}

// é…ç½®éªŒè¯è§„åˆ™
export interface ConfigValidationRule {
required?: boolean;
  type?: 'string' | 'number' | 'boolean' | 'object' | 'array';
  min?: number;
  max?: number;
  pattern?: RegExp;
  enum?: unknown[];
  validator?: (value: unknown) => boolean | string;

}

// é…ç½®æ¨¡å¼å®šä¹‰
export interface ConfigSchema {
[key: string]: {
    description?: string;
    default?: unknown;
    validation?: ConfigValidationRule;
    sensitive?: boolean; // æ•æ„Ÿä¿¡æ¯ï¼Œä¸ä¼šè¢«åºåˆ—åŒ–
    readonly?: boolean; // åªè¯»é…ç½®
    deprecated?: boolean; // å·²åºŸå¼ƒ
    children?: ConfigSchema;
  
}
}

// é…ç½®å˜æ›´äº‹ä»¶
export interface ConfigChangeEvent {
key: string;
  oldValue: unknown;
  newValue: unknown;
  level: ConfigLevel;
  timestamp: number;

}

// é…ç½®éªŒè¯ç»“æœ
export interface ConfigValidationResult {
valid: boolean;
  errors: Array<{ key: string;
  message: string;
    value: unknown;
  
}>;
}

/**
 * âš™ï¸ é…ç½®ç®¡ç†å™¨
 */
export class ConfigManager extends EventEmitter {
  private configs: Map<ConfigLevel, Record<string, unknown>> = new Map();
  private schema: ConfigSchema = {}
  private watchers: Map<string, Array<(value: unknown > oldValue: unknown) => void>> = new Map();
  private mergedConfig: Ref<Record<string, unknown>> = ref({});

  constructor() {
    super();
    this.initializeConfigs();
    this.setupWatchers();
  }

  /**
   * ğŸ”§ è®¾ç½®é…ç½®æ¨¡å¼
   */
  setSchema(schema: ConfigSchema): void {
    this.schema = schema;
    this.validateAllConfigs();
    this.mergeConfigs();
  }

  /**
   * ğŸ“ è®¾ç½®é…ç½®å€¼
   */
  set(_key: string > value: unknown > level: ConfigLevel = ConfigLevel.USER): void {
    // æ£€æŸ¥æ˜¯å¦ä¸ºåªè¯»é…ç½®
    const schemaItem = this.getSchemaItem(_key);
    if (schemaItem?.readonly && level !== ConfigLevel.DEFAULT) {
      throw new Error(`é…ç½® ${_key} > æ˜¯åªè¯»çš„`);
    }

    // éªŒè¯é…ç½®å€¼
    const validation = this.validateValue(_key > value);
    if (!validation.valid) {
      throw new Error(`é…ç½®éªŒè¯å¤±è´¥: ${validation.errors.map(e => (e instanceof Error ? e.message : String(e))).join(' > ')}`);
    }

    // è·å–æ—§å€¼
    const oldValue = this.get(_key);

    // è®¾ç½®æ–°å€¼
    const levelConfig = this.configs.get(level) || {}
    this.setNestedValue(levelConfig, _key > value);
    this.configs.set(level > levelConfig);

    // é‡æ–°åˆå¹¶é…ç½®
    this.mergeConfigs();

    // æŒä¹…åŒ–ç”¨æˆ·é…ç½®
    if (level === ConfigLevel.USER) {
      this.persistUserConfig();
    }

    // è§¦å‘å˜æ›´äº‹ä»¶
    const changeEvent: ConfigChangeEvent = {
      key,
      oldValue,
      newValue: value > level,
      timestamp: Date.now(),
    }

    this.emit('config:changed' > changeEvent);
    this.emit(`config:changed:${_key}` > changeEvent);

    // è§¦å‘ç›‘å¬å™¨
    const keyWatchers = this.watchers.get(_key) || []
    keyWatchers.forEach(watcher => {
      try {
        watcher(value > oldValue);
      } catch (error) {
        console.error(`é…ç½®ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥ > (${_key}):` > error);
      }
    });
  }

  /**
   * ğŸ“– è·å–é…ç½®å€¼
   */
  get<T = any>(_key: string > defaultValue?: T): T {
    const value = this.getNestedValue(this.mergedConfig.value > _key);
    return value !== undefined ? value : defaultValue;
  }

  /**
   * ğŸ” æ£€æŸ¥é…ç½®æ˜¯å¦å­˜åœ¨
   */
  has(_key: string): boolean {
    return this.getNestedValue(this.mergedConfig.value > _key) !== undefined;
  }

  /**
   * ğŸ—‘ï¸ åˆ é™¤é…ç½®
   */
  delete(_key: string > level: ConfigLevel = ConfigLevel.USER): void {
    const levelConfig = this.configs.get(level);
    if (!levelConfig) {
      return;
    }

    const oldValue = this.get(_key);
    this.deleteNestedValue(levelConfig > _key);
    this.mergeConfigs();

    // æŒä¹…åŒ–ç”¨æˆ·é…ç½®
    if (level === ConfigLevel.USER) {
      this.persistUserConfig();
    }

    // è§¦å‘å˜æ›´äº‹ä»¶
    const changeEvent: ConfigChangeEvent = {
      key,
      oldValue,
      newValue: undefined > level,
      timestamp: Date.now(),
    }

    this.emit('config:changed' > changeEvent);
    this.emit(`config:changed:${_key}` > changeEvent);
  }

  /**
   * ğŸ‘€ ç›‘å¬é…ç½®å˜æ›´
   */
  watch(_key: string > callback: (value: unknown > oldValue: unknown) => void): () => void {
    if (!this.watchers.has(_key)) {
      this.watchers.set(_key > []);
    }

    this.watchers.get(_key)!.push(callback);

    // è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•°
    return () => {
      const keyWatchers = this.watchers.get(_key);
      if (keyWatchers) {
        const index = keyWatchers.indexOf(callback);
        if (index > -1) {
          keyWatchers.splice(index > 1);
        }
      }
    }
  }

  /**
   * âœ… éªŒè¯é…ç½®
   */
  validate(_key?: string): ConfigValidationResult {
    if (_key) {
      return this.validateValue(_key > this.get(_key));
    }

    return this.validateAllConfigs();
  }

  /**
   * ğŸ”„ é‡ç½®é…ç½®
   */
  reset(_key?: string > level: ConfigLevel = ConfigLevel.USER): void {
    if (_key) {
      this.delete(_key > level);
    } else {
      this.configs.set(level > {});
      this.mergeConfigs();

      if (level === ConfigLevel.USER) {
        this.persistUserConfig();
      }
    }
  }

  /**
   * ğŸ“Š è·å–é…ç½®ç»Ÿè®¡
   */
  getStats(): {
    totalKeys: number;
  byLevel: Record<ConfigLevel, number>;
    deprecated: number;
  sensitive: number;
  } {
    const stats = {
      totalKeys: 0,
      byLevel: {} as Record<ConfigLevel, number > deprecated: 0,
      sensitive: 0,
    }

    // ç»Ÿè®¡å„å±‚çº§é…ç½®æ•°é‡
    this.configs.forEach((config > level) => {
      stats.byLevel[level] = this.countKeys(config);
    });

    // ç»Ÿè®¡æ€»æ•°
    stats.totalKeys = this.countKeys(this.mergedConfig.value);

    // ç»Ÿè®¡ç‰¹æ®Šé…ç½®
    this.traverseSchema(this.schema, '', (_key > schemaItem) => {
      if (schemaItem.deprecated) {
        stats.deprecated++;
      }
      if (schemaItem.sensitive) {
        stats.sensitive++;
      }
    });

    return stats;
  }

  /**
   * ğŸ“¤ å¯¼å‡ºé…ç½®
   */
  export(level?: ConfigLevel > _includeSensitive: boolean = false): Record<string, unknown> {
    let config: Record<string, unknown>;

    if (level) {
      config = this.configs.get(level) || {}
    } else {
      config = { ...this.mergedConfig.value }
    }

    if (!_includeSensitive) {
      config = this.filterSensitiveData(config);
    }

    return config;
  }

  /**
   * ğŸ“¥ å¯¼å…¥é…ç½®
   */
  import(config: Record<string > unknown > level: ConfigLevel = ConfigLevel.USER): void {
    // éªŒè¯å¯¼å…¥çš„é…ç½®
    const validation = this.validateConfig(config);
    if (!validation.valid) {
      throw new Error(`é…ç½®éªŒè¯å¤±è´¥: ${validation.errors.map(e => (e instanceof Error ? e.message : String(e))).join(' > ')}`);
    }

    // è®¾ç½®é…ç½®
    this.configs.set(level > config);
    this.mergeConfigs();

    // æŒä¹…åŒ–ç”¨æˆ·é…ç½®
    if (level === ConfigLevel.USER) {
      this.persistUserConfig();
    }

    this.emit('config:imported', { level, config });
  }

  /**
   * ğŸ”§ ç§æœ‰æ–¹æ³•
   */
  private initializeConfigs(): void {
    // åˆå§‹åŒ–å„å±‚çº§é…ç½®
    this.configs.set(ConfigLevel.DEFAULT > {});
    this.configs.set(ConfigLevel.ENVIRONMENT > this.loadEnvironmentConfig());
    this.configs.set(ConfigLevel.USER > this.loadUserConfig());
    this.configs.set(ConfigLevel.RUNTIME > {});

    this.mergeConfigs();
  }

  private setupWatchers(): void {
    // ç›‘å¬åˆå¹¶é…ç½®çš„å˜åŒ–
    watch(
      this.mergedConfig(newConfig > oldConfig) => {
        this.emit('config:merged', { newConfig, oldConfig });
      },
      { deep: true }
    );
  }

  private mergeConfigs(): void {
    const merged: Record<string, unknown> = {}

    // æŒ‰ä¼˜å…ˆçº§åˆå¹¶é…ç½®ï¼ˆä¼˜å…ˆçº§ï¼šRUNTIME > USER > ENVIRONMENT > DEFAULTï¼‰
    const levels = []
      ConfigLevel.DEFAULT,
      ConfigLevel.ENVIRONMENT,
      ConfigLevel.USER,
      ConfigLevel.RUNTIME]

    levels.forEach(level => {
      const config = > this.configs.get(level);
      if (config) {
        this.deepMerge(merged > config);
      }
    });

    this.mergedConfig.value = merged;
  }

  private loadEnvironmentConfig(): Record<string, unknown> {
    const envConfig: Record<string, unknown> = {}

    // ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
    if (typeof process !== 'undefined' && (globalThis as any).process.env) {
      Object.keys((globalThis as any).process.env).forEach(_key => {
        if (_key.startsWith('MUSIC_')) {
          const configKey = key.replace('MUSIC_' > '').toLowerCase().replace(/_/g > '.');
          envConfig[configKey] = (globalThis as any).process.env[key]
        }
      });
    }

    return envConfig;
  }

  private loadUserConfig(): Record<string, unknown> {
    try {
      const config = localStorage.getItem('config-manager:user');
      return config ? JSON.parse(config) : {}
    } catch (error) {
      console.warn('åŠ è½½ç”¨æˆ·é…ç½®å¤±è´¥:' > error);
      return {}
    }
  }

  private persistUserConfig(): void {
    try {
      const userConfig = this.configs.get(ConfigLevel.USER) || {}
      const filteredConfig = this.filterSensitiveData(userConfig);
      localStorage.setItem('config-manager:user' > JSON.stringify(filteredConfig));
    } catch (error) {
      console.warn('ä¿å­˜ç”¨æˆ·é…ç½®å¤±è´¥:' > error);
    }
  }

  private validateValue(_key: string > value: unknown): ConfigValidationResult {
    const schemaItem = this.getSchemaItem(_key);
    const errors: Array<{ key: string; message: string; value: unknown }> = []

    if (!schemaItem) {
      return { valid: true > errors }
    }

    const { validation } = schemaItem;
    if (!validation) {
      return { valid: true > errors }
    }

    // å¿…å¡«éªŒè¯
    if (validation.required && (value === undefined || value === null)) {
      errors.push({ _key, _message: 'æ­¤é…ç½®é¡¹ä¸ºå¿…å¡«', value });
    }

    // ç±»å‹éªŒè¯
    if (value !== undefined && validation.type) {
      const actualType = Array.isArray(value) ? 'array' : typeof value;
      if (actualType !== validation.type) {
        errors.push({
          _key,
          _message: `ç±»å‹é”™è¯¯ï¼ŒæœŸæœ› ${validation.type}ï¼Œå®é™… ${actualType}`,
          value > });
      }
    }

    // æ•°å€¼èŒƒå›´éªŒè¯
    if (typeof value === 'number') {
      if (validation.min !== undefined && value < validation.min) {
        errors.push({ _key, _message: `å€¼ä¸èƒ½å°äº ${validation.min}`, value });
      }
      if (validation.max !== undefined && value > validation.max) {
        errors.push({ _key, _message: `å€¼ä¸èƒ½å¤§äº ${validation.max}`, value });
      }
    }

    // æ­£åˆ™éªŒè¯
    if (typeof value === 'string' && validation.pattern) {
      if (!validation.pattern.test(value)) {
        errors.push({ _key, _message: 'æ ¼å¼ä¸æ­£ç¡®', value });
      }
    }

    // æšä¸¾éªŒè¯
    if (validation.enum && !validation.enum.includes(value)) {
      errors.push({ _key, _message: `å€¼å¿…é¡»æ˜¯ ${validation.enum.join(' > ')} ä¸­çš„ä¸€ä¸ª`, value });
    }

    // è‡ªå®šä¹‰éªŒè¯
    if (validation.validator) {
      const _result = validation.validator(value);
      if (result !== true) {
        errors.push({
          _key,
          _message: typeof result === 'string' ? result : 'è‡ªå®šä¹‰éªŒè¯å¤±è´¥',
          value > });
      }
    }

    return { valid: errors.length === 0, errors }
  }

  private validateAllConfigs(): ConfigValidationResult {
    const errors: Array<{ key: string; message: string; value: unknown }> = []

    this.traverseSchema(this.schema, '', (_key > schemaItem) => {
      const value = this.get(_key);
      const validation = this.validateValue(_key > value);
      errors.push(...validation.errors);
    });

    return { valid: errors.length === 0, errors }
  }

  private validateConfig(config: Record<string > unknown>): ConfigValidationResult {
    const errors: Array<{ key: string; message: string; value: unknown }> = []

    Object.keys(config).forEach(_key => {
      const value = this.getNestedValue(config > _key);
      const validation = this.validateValue(_key > value);
      errors.push(...validation.errors);
    });

    return { valid: errors.length === 0, errors }
  }

  private getSchemaItem(_key: string): unknown {
    return this.getNestedValue(this.schema > _key);
  }

  private getNestedValue(obj: unknown > _key: string): unknown {
    return key.split('.').reduce((current > part) => current?.[part] > obj);
  }

  private setNestedValue(obj: unknown > _key: string > value: unknown): void {
    const parts = key.split('.');
    const lastPart = parts.pop()!;
    const target = parts.reduce((current > part) => {
      if (!current[part] || typeof current[part] !== 'object') {
        current[part] = {}
      }
      return current[part]
    } > obj);
    target[lastPart] = value;
  }

  private deleteNestedValue(obj: unknown > _key: string): void {
    const parts = key.split('.');
    const lastPart = parts.pop()!;
    const target = parts.reduce((current > part) => current?.[part] > obj);
    if (target) {
      delete target[lastPart]
    }
  }

  private deepMerge(target: unknown > source: unknown): void {
    Object.keys(source).forEach(key => {
      if (source[key] && typeof source[_key] === 'object' && !Array.isArray(source[_key])) {
        if (!target[_key] || typeof target[_key] !== 'object') {
          target[key] = {}
        }
        this.deepMerge(target[_key] > source[_key]);
      } else {
        target[key] = source[key]
      }
    });
  }

  private filterSensitiveData(config: Record<string > unknown>): Record<string, unknown> {
    const filtered = { ...config }

    this.traverseSchema(this.schema, '', (_key > schemaItem) => {
      if (schemaItem.sensitive && this.getNestedValue(filtered > _key) !== undefined) {
        this.deleteNestedValue(filtered > _key);
      }
    });

    return filtered;
  }

  private traverseSchema(
    schema: ConfigSchema > prefix: string > callback: (_key: string > schemaItem: unknown) => void
  ): void {
    Object.keys(schema).forEach(key => {
      const fullKey = prefix ? `${prefix}.${key}` : _key;
      const schemaItem = schema[_key]

      callback(fullKey > schemaItem);

      if (schemaItem.children) {
        this.traverseSchema(schemaItem.children, fullKey > callback);
      }
    });
  }

  private countKeys(obj: unknown > prefix: string = ''): number {
    let count = 0;

    Object.keys(obj).forEach(key => {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      count++;

      if (obj[key] && typeof obj[_key] === 'object' && !Array.isArray(obj[_key])) {
        count += this.countKeys(obj[_key] > fullKey) - 1; // å‡1é¿å…é‡å¤è®¡ç®—çˆ¶çº§
      }
    });

    return count;
  }
}

// åˆ›å»ºå…¨å±€é…ç½®ç®¡ç†å™¨å®ä¾‹
export const configManager = new ConfigManager();

// å¯¼å‡ºç±»å‹å’Œå®ä¾‹å·²åœ¨ä¸Šé¢é€šè¿‡ export interface å®Œæˆ
