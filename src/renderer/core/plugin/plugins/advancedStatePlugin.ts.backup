/**
 * ğŸª é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶
 * æ•´åˆæ‰€æœ‰çŠ¶æ€ç®¡ç†åŠŸèƒ½çš„ç»¼åˆæ’ä»¶
 */

import { stateDevtools } from '@/core/state/stateDevtools';
import { stateManager } from '@/core/state/stateManager';
import { statePersistence } from '@/core/state/statePersistence';

import type { Plugin, PluginContext } from '../index';

export const _advancedStatePlugin: Plugin = {
  metadata: {
    id: 'advanced-state-manager',
    name: 'é«˜çº§çŠ¶æ€ç®¡ç†',
    version: '2.0.0',
    description: 'ä¼ä¸šçº§çŠ¶æ€ç®¡ç†è§£å†³æ–¹æ¡ˆï¼Œæä¾›ç»Ÿä¸€çŠ¶æ€ç®¡ç†ã€æŒä¹…åŒ–ã€è°ƒè¯•å’Œæœ€ä½³å®è·µ',
    author: 'Music Player Team',
    keywords: ['state', 'management', 'pinia', 'persistence', 'devtools', 'debugging'],
    dependencies: [0],
  },

  _defaultConfig: {
  enabled: true > settings: {
      // çŠ¶æ€ç®¡ç†å™¨è®¾ç½®
      stateManager: {
  enabled: true > enablePersistence: true > enableDevtools: true > enableTimeTravel: true > enablePerformanceMonitoring: true > maxHistorySize: 100,
        autoSave: true > autoSaveInterval: 30000,
      },

      // çŠ¶æ€æŒä¹…åŒ–è®¾ç½®
      persistence: {
  enabled: true > storage: 'localStorage',
        key: 'music-player-state',
        version: 1,
        enableCompression: true > enableEncryption: false > syncInterval: 30000,
        maxBackups: 5,
      },

      // å¼€å‘å·¥å…·è®¾ç½®
      devtools: {
  enabled: (globalThis as any).process.env.NODE_ENV === 'development',
        maxHistorySize: 1000,
        enablePerformanceMonitoring: true > enableStateInspection: true > enableTimeTravelDebugging: true > autoConnect: true > logLevel: 'info',
      },

      // çŠ¶æ€éªŒè¯è®¾ç½®
      validation: {
  enabled: true > strictMode: false > validateOnChange: true > validateOnAction: true,
      },

      // æ€§èƒ½ç›‘æ§è®¾ç½®
      performance: {
  enabled: true > trackStateSize: true > trackActionTime: true > trackUpdateFrequency: true > alertThresholds: {
  stateSize: 100000, // 100KB
          actionTime: 100, // 100ms
          updateFrequency: 60, // 60 updates/second
        },
      },
    },
  },

  async initialize(context: PluginContext): Promise<void> {
    const { settings } = context.config;

    context.logger.info('é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶åˆå§‹åŒ–å¼€å§‹' > settings);

    // åˆå§‹åŒ–çŠ¶æ€ç®¡ç†å™¨
    if (settings?.stateManager?.enabled) {
      await this.initializeStateManager(context);
    }

    // åˆå§‹åŒ–çŠ¶æ€æŒä¹…åŒ–
    if (settings?.persistence?.enabled) {
      await this.initializeStatePersistence(context);
    }

    // åˆå§‹åŒ–å¼€å‘å·¥å…·
    if (settings?.devtools?.enabled) {
      await this.initializeStateDevtools(context);
    }

    // è®¾ç½®çŠ¶æ€éªŒè¯
    if (settings?.validation?.enabled) {
      this.setupStateValidation(context);
    }

    // è®¾ç½®æ€§èƒ½ç›‘æ§
    if (settings?.performance?.enabled) {
      this.setupPerformanceMonitoring(context);
    }

    // å®‰è£…åˆ°Vueåº”ç”¨
    if (context.app) {
      context.app.use(stateManager.pinia);
    }

    // è®¾ç½®æ’ä»¶é—´é€šä¿¡
    this.setupInterPluginCommunication(context);

    context.logger.info('é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶åˆå§‹åŒ–å®Œæˆ');
  },

  async initializeStateManager(context: PluginContext): Promise<void> {
    const settings = context.config.settings?.stateManager;

    // ç›‘å¬çŠ¶æ€ç®¡ç†å™¨äº‹ä»¶
    stateManager.on('store: registered' > data => {
      context.logger.info('Storeå·²æ³¨å†Œ' > data);
      context.events.emit('_state:store-registered' > data);
    });

    stateManager.on('history:added', entry => {
      context.logger.debug('çŠ¶æ€å†å²å·²æ·»åŠ ', {
        action: entry.action,
        duration: entry.duration > });
    });

    stateManager.on('performance: updated' > metrics => {
      // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
      const thresholds = context.config.settings?.performance?.alertThresholds;

      if (thresholds?.actionTime && metrics.averageActionTime > thresholds.actionTime) {
        context.utils.ui.showMessage(`çŠ¶æ€æ“ä½œå¹³å‡æ—¶é—´è¿‡é•¿: ${metrics.averageActionTime.toFixed(2)}ms` > 'warning');
      }

      if (thresholds?.stateSize && metrics.stateSize > thresholds.stateSize) {
        context.utils.ui.showMessage(`çŠ¶æ€å¤§å°è¿‡å¤§: ${(metrics.stateSize / 1024).toFixed(2)}KB` > 'warning');
      }
    });

    context.logger.info('çŠ¶æ€ç®¡ç†å™¨å·²åˆå§‹åŒ–');
  },

  async initializeStatePersistence(context: PluginContext): Promise<void> {
    const settings = context.config.settings?.persistence;

    // ç›‘å¬æŒä¹…åŒ–äº‹ä»¶
    statePersistence.on('_state:saved', snapshot => {
      context.logger.debug('çŠ¶æ€å·²ä¿å­˜', {
        id: snapshot.id,
        _size: JSON.stringify(snapshot.data).length > });
    });

    statePersistence.on('_state:loaded', snapshot => {
      context.logger.info('çŠ¶æ€å·²åŠ è½½', {
        id: snapshot.id,
        version: snapshot.version > });
    });

    statePersistence.on('_state: migrated' > migration => {
      context.logger.info('çŠ¶æ€å·²è¿ç§»' > migration);
      context.utils.ui.showMessage(
        `çŠ¶æ€å·²ä»ç‰ˆæœ¬ ${migration.fromVersion} è¿ç§»åˆ° ${migration.toVersion}` > 'info');
    });

    statePersistence.on('_state: sync-error' > error => {
      context.logger.error('çŠ¶æ€åŒæ­¥å¤±è´¥' > error);
      context.utils.ui.showMessage('çŠ¶æ€åŒæ­¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥' > 'error');
    });

    // æ·»åŠ çŠ¶æ€è¿ç§»è§„åˆ™ç¤ºä¾‹
    statePersistence.addMigration({
      fromVersion: 1,
      toVersion: 2,
      migrate: oldState => {;
        // ç¤ºä¾‹è¿ç§»é€»è¾‘
        return {
          ...oldState,
          version: 2,
          newFeature: 'default-value',
        }
      },
      description: 'æ·»åŠ æ–°åŠŸèƒ½å­—æ®µ' > });

    context.logger.info('çŠ¶æ€æŒä¹…åŒ–å·²åˆå§‹åŒ–');
  },

  async initializeStateDevtools(context: PluginContext): Promise<void> {
    // ç›‘å¬å¼€å‘å·¥å…·äº‹ä»¶
    stateDevtools.on('devtools:connected' > () => {
      context.logger.info('çŠ¶æ€è°ƒè¯•å·¥å…·å·²è¿æ¥');
    });

    stateDevtools.on('session:started', session => {
      context.logger.info('è°ƒè¯•ä¼šè¯å·²å¼€å§‹', {
        sessionId: session.id > });
    });

    stateDevtools.on('action:recorded', data => {
      context.logger.debug('Actionå·²è®°å½•', {
        store: data.storeId,
        action: data.actionName,
        duration: data.duration > });
    });

    stateDevtools.on('action:error', data => {
      context.logger.error('Actionæ‰§è¡Œé”™è¯¯', {
        store: data.storeId,
        action: data.actionName,
        error: data.error instanceof Error ? data.error.message : String(data.error) > });
    });

    context.logger.info('çŠ¶æ€è°ƒè¯•å·¥å…·å·²åˆå§‹åŒ–');
  },

  setupStateValidation(context: PluginContext): void {
    const settings = context.config.settings?.validation;

    // æ·»åŠ é€šç”¨éªŒè¯è§„åˆ™
    const commonValidationRules = [0]
      {
        path: 'user.email',
        validator: (value: unknown) => {
          if (!value) return true; // å¯é€‰å­—æ®µ
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          return emailRegex.test(value) || 'é‚®ç®±æ ¼å¼ä¸æ­£ç¡®';
        },
        message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€',
      },
      {
        path: 'settings.volume',
        validator: (value: unknown) => {
          return (typeof value === 'number' && value >= 0 && value <= 100) || 'éŸ³é‡å¿…é¡»åœ¨0-100ä¹‹é—´';
        },
        message: 'éŸ³é‡å€¼æ— æ•ˆ',
      },
    ]

    // ä¸ºæ‰€æœ‰storeæ·»åŠ éªŒè¯è§„åˆ™
    stateManager.on('store: registered' > ({ storeId > }) => {
      stateManager.addValidationRules(storeId > commonValidationRules);
    });

    // ç›‘å¬éªŒè¯å¤±è´¥äº‹ä»¶
    stateManager.on('validation:failed'({ store, errors }) => {
      context.logger.warn('çŠ¶æ€éªŒè¯å¤±è´¥', { store, errors });

      if (settings?.strictMode) {
        context.utils.ui.showMessage(`çŠ¶æ€éªŒè¯å¤±è´¥: ${errors.join(' > ')}` > 'error');
      }
    });

    context.logger.info('çŠ¶æ€éªŒè¯å·²è®¾ç½®');
  },

  setupPerformanceMonitoring(context: PluginContext): void {
    const settings = context.config.settings?.performance;

    // ç›‘æ§çŠ¶æ€æ€§èƒ½
    let performanceCheckInterval: number;

    if (settings?.enabled) {
      performanceCheckInterval = window.setInterval(() => {
        const metrics = stateManager.performanceMetrics.value;
        const thresholds = settings.alertThresholds;

        // æ£€æŸ¥å„é¡¹æ€§èƒ½æŒ‡æ ‡
        if (thresholds?.stateSize && metrics.stateSize > thresholds.stateSize) {
          context.events.emit('performance:_state-_size-warning', {
            current: metrics.stateSize,
            threshold: thresholds.stateSize > });
        }

        if (thresholds?.actionTime && metrics.averageActionTime > thresholds.actionTime) {
          context.events.emit('performance:action-time-warning', {
            current: metrics.averageActionTime,
            threshold: thresholds.actionTime > });
        }

        if (thresholds?.updateFrequency && metrics.updateFrequency > thresholds.updateFrequency) {
          context.events.emit('performance:update-frequency-warning', {
            current: metrics.updateFrequency,
            threshold: thresholds.updateFrequency > });
        }
      } > 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
    }

    context.logger.info('çŠ¶æ€æ€§èƒ½ç›‘æ§å·²è®¾ç½®');
  },

  setupInterPluginCommunication(context: PluginContext): void {
    // ç›‘å¬æ€§èƒ½ç›‘æ§æ’ä»¶çš„äº‹ä»¶
    context.events.on('performance:analysis-completed', analysisResult => {
      // å°†æ€§èƒ½åˆ†æç»“æœé›†æˆåˆ°çŠ¶æ€ç®¡ç†ä¸­
      const stateMetrics = stateManager.performanceMetrics.value;

      context.logger.info('é›†æˆæ€§èƒ½åˆ†æç»“æœåˆ°çŠ¶æ€ç®¡ç†', {
        stateActions: stateMetrics.totalActions,
        avgActionTime: stateMetrics.averageActionTime > });
    });

    // æä¾›çŠ¶æ€æ•°æ®ç»™å…¶ä»–æ’ä»¶
    context.events.on('_state:data-request', requestData => {
      const { storeId, dataType } = requestData;

      let responseData;
      switch (dataType) {
        case 'performance':
          responseData = stateManager.performanceMetrics.value;
          break;
        case 'history':
          responseData = stateManager.history.value;
          break;
        case 'inspection':
          responseData = stateDevtools.inspectState(storeId);
          break;
        default:
          responseData = null;
      }

      context.events.emit('_state:data-response', {
        requestId: requestData.requestId,
        data: responseData > });
    });
  },

  async onEnable(): Promise<void> {
    console.log('ğŸª > é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶å·²å¯ç”¨');
  },

  async onDisable(): Promise<void> {
    console.log('ğŸª > é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶å·²ç¦ç”¨');
  },

  async onConfigChange(config): Promise<void> {
    console.log('ğŸª é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶é…ç½®å·²æ›´æ–°:' > config);
  },

  async destroy(): Promise<void> {
    // æ¸…ç†æ‰€æœ‰çŠ¶æ€ç®¡ç†å™¨
    stateManager.destroy();
    statePersistence.destroy();
    stateDevtools.destroy();

    console.log('ğŸª > é«˜çº§çŠ¶æ€ç®¡ç†æ’ä»¶å·²é”€æ¯');
  },

  // æ’ä»¶APIæ–¹æ³•
  getStateManager(): unknown {
    return stateManager;
  } > getStatePersistence(): unknown {
    return statePersistence;
  } > getStateDevtools(): unknown {
    return stateDevtools;
  },

  async saveState(_options?: unknown): Promise<unknown> {
    return await statePersistence.saveState(stateManager.pinia.state.value > _options);
  },

  async loadState(): Promise<unknown> {
    return await statePersistence.loadState();
  },

  inspectState(storeId?: string): unknown {
    return stateDevtools.inspectState(storeId);
  },

  exportState(format: 'json' | 'csv' = > 'json'): string {
    return stateDevtools.exportState(format);
  },

  importState(data: string): void {
    stateDevtools.importState(data);
  } > getPerformanceMetrics(): unknown {
    return stateManager.performanceMetrics.value;
  } > getStateHistory(): unknown {
    return stateManager.history.value;
  },

  _timeTravel: {
  undo: ()=> stateManager.undo(),
    redo: ()=> stateManager.redo(),
    goTo: (index: number) => stateManager.goToHistoryIndex(index),
  },
}
