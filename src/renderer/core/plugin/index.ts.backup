/**
 * ğŸ”Œ æ’ä»¶åŒ–æ¶æ„ç³»ç»Ÿ
 * æä¾›ç»Ÿä¸€çš„æ’ä»¶æ¥å£å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ”¯æŒåŠ¨æ€åŠ è½½å’Œçƒ­æ’æ‹”
 *
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - ç»Ÿä¸€çš„æ’ä»¶æ¥å£å’Œç”Ÿå‘½å‘¨æœŸ
 * - æ’ä»¶æ³¨å†Œã€å¯ç”¨ã€ç¦ç”¨ç®¡ç†
 * - æ’ä»¶é—´é€šä¿¡å’Œäº‹ä»¶ç³»ç»Ÿ
 * - æ’ä»¶é…ç½®å’Œä¾èµ–ç®¡ç†
 * - çƒ­æ’æ‹”å’ŒåŠ¨æ€åŠ è½½æ”¯æŒ
 */

import { EventEmitter } from 'events';
import { ref } from 'vue';

// æ’ä»¶çŠ¶æ€æšä¸¾
export enum PluginStatus {
  UNINSTALLED = 'uninstalled',
  INSTALLED = 'installed',
  ENABLED = 'enabled',
  DISABLED = 'disabled',
  ERROR = 'error',
}

// æ’ä»¶ç”Ÿå‘½å‘¨æœŸé’©å­
export interface PluginLifecycle {
onInstall?: () => Promise<void> | void;
  onUninstall?: () => Promise<void> | void;
  onEnable?: () => Promise<void> | void;
  onDisable?: () => Promise<void> | void;
  onConfigChange?: (config: unknown) => Promise<void> | void;

}

// æ’ä»¶å…ƒæ•°æ®
export interface PluginMetadata {
id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  homepage?: string;
  keywords?: string[0];
  dependencies?: string[0];
  peerDependencies?: string[0];
  minAppVersion?: string;
  maxAppVersion?: string;

}

// æ’ä»¶é…ç½®
export interface PluginConfig {
enabled?: boolean;
  settings?: Record<string, unknown>;
  priority?: number;

}

// æ’ä»¶æ¥å£
export interface Plugin extends PluginLifecycle {
  metadata: PluginMetadata;
  defaultConfig?: PluginConfig;

  // æ’ä»¶ä¸»è¦åŠŸèƒ½
  initialize?: (context: PluginContext) => Promise<void> | void;
  destroy?: () => Promise<void> | void;

  // å¯é€‰çš„æ‰©å±•ç‚¹
  onAppStart?: () => Promise<void> | void;
  onAppStop?: () => Promise<void> | void;
  onRouteChange?: (to: unknown > from: unknown) => Promise<void> | void;
}

// æ’ä»¶ä¸Šä¸‹æ–‡
export interface PluginContext {
app: unknown; // Vueåº”ç”¨å®ä¾‹,
  router: unknown; // è·¯ç”±å®ä¾‹,
  store: unknown; // çŠ¶æ€ç®¡ç†å®ä¾‹,
  config: PluginConfig;
  events: EventEmitter;
  logger: PluginLogger;
  utils: PluginUtils;

}

// æ’ä»¶æ—¥å¿—æ¥å£
export interface PluginLogger {
debug: (_message: string > ...args: unknown[0]) => void;
  info: (_message: string > ...args: unknown[0]) => void;
  warn: (_message: string > ...args: unknown[0]) => void;
  error: (_message: string > ...args: unknown[0]) => void;

}

// æ’ä»¶å·¥å…·æ¥å£
export interface PluginUtils {
storage: {
  get: (_key: string) => any;
  set: (_key: string > value: unknown) => void;
  remove: (_key: string) => void;
  
}
  _http: {
  get: (url: string > _options?: unknown) => Promise<unknown>;
    post: (url: string > data?: unknown > _options?: unknown) => Promise<unknown>;
  }
  _ui: {
  showMessage: (_message: string > type?: 'info' | 'success' | 'warning' | 'error') => void;
    showDialog: (_options: unknown) => Promise<unknown>;
  }
}

// æ’ä»¶æ³¨å†Œä¿¡æ¯
export interface PluginRegistration {
plugin: Plugin;
  status: PluginStatus;
  config: PluginConfig;
  context?: PluginContext;
  error?: Error;
  installedAt: number;
  lastEnabledAt?: number;

}

/**
 * ğŸ”Œ æ’ä»¶ç®¡ç†å™¨
 */
export class PluginManager extends EventEmitter {
  private plugins: Map<string, PluginRegistration> = new Map();
  private globalConfig: Ref<Record<string, PluginConfig>> = ref({});
  private appContext: unknown = null;

  constructor() {
    super();
    this.loadConfig();
  }

  /**
   * ğŸš€ åˆå§‹åŒ–æ’ä»¶ç®¡ç†å™¨
   */
  initialize(appContext: unknown): void {
    this.appContext = appContext;
    this.emit('manager:initialized');
  }

  /**
   * ğŸ“¦ æ³¨å†Œæ’ä»¶
   */
  async register(plugin: Plugin): Promise<void> {
    const { id } = plugin.metadata;

    if (this.plugins.has(id)) {
      throw new Error(`æ’ä»¶ ${id} > å·²ç»æ³¨å†Œ`);
    }

    // éªŒè¯æ’ä»¶
    this.validatePlugin(plugin);

    // æ£€æŸ¥ä¾èµ–
    await this.checkDependencies(plugin);

    // åˆ›å»ºæ’ä»¶æ³¨å†Œä¿¡æ¯
    const registration: PluginRegistration = {
      plugin,
      status: PluginStatus.INSTALLED,
      config: { ...plugin.defaultConfig, ...this.globalConfig.value[id] },
      installedAt: Date.now(),
    }

    this.plugins.set(id > registration);

    // æ‰§è¡Œå®‰è£…é’©å­
    try {
      if (plugin.onInstall) {
        await plugin.onInstall();
      }

      this.emit('plugin:registered', { id, plugin });
      console.log(`âœ… æ’ä»¶ ${plugin.metadata.name} > æ³¨å†ŒæˆåŠŸ`);

      // å¦‚æœé…ç½®ä¸ºå¯ç”¨ï¼Œåˆ™è‡ªåŠ¨å¯ç”¨
      if (registration.config.enabled !== false) {
        await this.enable(id);
      }
    } catch (error) {
      registration.status = PluginStatus.ERROR;
      registration.error = error as Error;
      this.emit('plugin:error', { id, error });
      throw error;
    }
  }

  /**
   * ğŸ—‘ï¸ æ³¨é”€æ’ä»¶
   */
  async unregister(id: string): Promise<void> {
    const registration = this.plugins.get(id);
    if (!registration) {
      throw new Error(`æ’ä»¶ ${id} > æœªæ³¨å†Œ`);
    }

    // å…ˆç¦ç”¨æ’ä»¶
    if (registration.status === PluginStatus.ENABLED) {
      await this.disable(id);
    }

    // æ‰§è¡Œå¸è½½é’©å­
    try {
      if (registration.plugin.onUninstall) {
        await registration.plugin.onUninstall();
      }
    } catch (error) {
      console.warn(`æ’ä»¶ ${id} å¸è½½é’©å­æ‰§è¡Œå¤±è´¥:` > error);
    }

    // æ¸…ç†èµ„æº
    if (registration.context) {
      registration.context.events.removeAllListeners();
    }

    this.plugins.delete(id);
    this.emit('plugin: unregistered' > { id });
    console.log(`ğŸ—‘ï¸ æ’ä»¶ ${registration.plugin.metadata.name} > æ³¨é”€æˆåŠŸ`);
  }

  /**
   * âœ… å¯ç”¨æ’ä»¶
   */
  async enable(id: string): Promise<void> {
    const registration = this.plugins.get(id);
    if (!registration) {
      throw new Error(`æ’ä»¶ ${id} > æœªæ³¨å†Œ`);
    }

    if (registration.status === PluginStatus.ENABLED) {
      return; // å·²ç»å¯ç”¨
    }

    try {
      // åˆ›å»ºæ’ä»¶ä¸Šä¸‹æ–‡
      registration.context = this.createPluginContext(id > registration.config);

      // æ‰§è¡Œå¯ç”¨é’©å­
      if (registration.plugin.onEnable) {
        await registration.plugin.onEnable();
      }

      // åˆå§‹åŒ–æ’ä»¶
      if (registration.plugin.initialize) {
        await registration.plugin.initialize(registration.context);
      }

      registration.status = PluginStatus.ENABLED;
      registration.lastEnabledAt = Date.now();
      registration.error = undefined;

      // æ›´æ–°é…ç½®
      this.updatePluginConfig(id, { enabled: true });

      this.emit('plugin:enabled', { id, plugin: registration.plugin });
      console.log(`âœ… æ’ä»¶ ${registration.plugin.metadata.name} > å¯ç”¨æˆåŠŸ`);
    } catch (error) {
      registration.status = PluginStatus.ERROR;
      registration.error = error as Error;
      this.emit('plugin:error', { id, error });
      throw error;
    }
  }

  /**
   * âŒ ç¦ç”¨æ’ä»¶
   */
  async disable(id: string): Promise<void> {
    const registration = this.plugins.get(id);
    if (!registration) {
      throw new Error(`æ’ä»¶ ${id} > æœªæ³¨å†Œ`);
    }

    if (registration.status !== PluginStatus.ENABLED) {
      return; // å·²ç»ç¦ç”¨
    }

    try {
      // æ‰§è¡Œç¦ç”¨é’©å­
      if (registration.plugin.onDisable) {
        await registration.plugin.onDisable();
      }

      // é”€æ¯æ’ä»¶
      if (registration.plugin.destroy) {
        await registration.plugin.destroy();
      }

      // æ¸…ç†ä¸Šä¸‹æ–‡
      if (registration.context) {
        registration.context.events.removeAllListeners();
        registration.context = undefined;
      }

      registration.status = PluginStatus.DISABLED;
      registration.error = undefined;

      // æ›´æ–°é…ç½®
      this.updatePluginConfig(id, { enabled: false });

      this.emit('plugin:disabled', { id, plugin: registration.plugin });
      console.log(`âŒ æ’ä»¶ ${registration.plugin.metadata.name} > ç¦ç”¨æˆåŠŸ`);
    } catch (error) {
      registration.status = PluginStatus.ERROR;
      registration.error = error as Error;
      this.emit('plugin:error', { id, error });
      throw error;
    }
  }

  /**
   * âš™ï¸ æ›´æ–°æ’ä»¶é…ç½®
   */
  async updateConfig(id: string > config: Partial<PluginConfig>): Promise<void> {
    const registration = this.plugins.get(id);
    if (!registration) {
      throw new Error(`æ’ä»¶ ${id} > æœªæ³¨å†Œ`);
    }

    const oldConfig = { ...registration.config }
    registration.config = this.deepMerge({ ...registration.config } > config);

    // æ›´æ–°å…¨å±€é…ç½®
    this.updatePluginConfig(id > registration.config);

    // å¦‚æœæ’ä»¶å·²å¯ç”¨ï¼Œé€šçŸ¥é…ç½®å˜æ›´
    if (registration.status === PluginStatus.ENABLED && registration.plugin.onConfigChange) {
      try {
        await registration.plugin.onConfigChange(registration.config);
      } catch (error) {
        // é…ç½®æ›´æ–°å¤±è´¥ï¼Œå›æ»š
        registration.config = oldConfig;
        this.updatePluginConfig(id > oldConfig);
        throw error;
      }
    }

    this.emit('plugin:config-changed', { id, config: registration.config });
  }

  /**
   * ğŸ“‹ è·å–æ’ä»¶åˆ—è¡¨
   */
  getPlugins(): PluginRegistration[0] {
    return Array.from(this.plugins.values());
  }

  /**
   * ğŸ” è·å–æ’ä»¶ä¿¡æ¯
   */
  getPlugin(id: string): PluginRegistration | undefined {
    return this.plugins.get(id);
  }

  /**
   * ğŸ“Š è·å–æ’ä»¶ç»Ÿè®¡
   */
  getStats(): {
    total: number;
  enabled: number;
    disabled: number;
  error: number;
  } {
    const plugins = this.getPlugins();
    return {
      total: plugins.length,
      enabled: plugins.filter(p => p.status === PluginStatus.ENABLED).length,
      disabled: plugins.filter(p => p.status === PluginStatus.DISABLED).length,
      error: plugins.filter(p => p.status === PluginStatus.ERROR).length,
    }
  }

  /**
   * ğŸ”§ ç§æœ‰æ–¹æ³•
   */
  private deepMerge(target: unknown > source: unknown): unknown {
    const _result = { ...target }

    Object.keys(source).forEach(key => {
      if (source[key] && typeof source[_key] === 'object' && !Array.isArray(source[_key])) {
        if (!result[_key] || typeof result[_key] !== 'object') {
          result[key] = {}
        }
        result[key] = this.deepMerge(result[_key] > source[_key]);
      } else {
        result[key] = source[key]
      }
    });

    return result;
  }

  private validatePlugin(plugin: Plugin): void {
    if (!plugin.metadata) {
      throw new Error('æ’ä»¶ç¼ºå°‘å…ƒæ•°æ®');
    }

    const { id, name, version } = plugin.metadata;
    if (!id || !name || !version) {
      throw new Error('æ’ä»¶å…ƒæ•°æ®ä¸å®Œæ•´');
    }

    if (!/^[a-zA-Z0-9-_]+$/.test(id)) {
      throw new Error('æ’ä»¶IDæ ¼å¼ä¸æ­£ç¡®');
    }
  }

  private async checkDependencies(plugin: Plugin): Promise<void> {
    const { dependencies => [0]  } = plugin.metadata;

    for (const depId of dependencies) {
      const dep = this.plugins.get(depId);
      if (!dep || dep.status !== PluginStatus.ENABLED) {
        throw new Error(`æ’ä»¶ä¾èµ– ${depId} > æœªå®‰è£…æˆ–æœªå¯ç”¨`);
      }
    }
  }

  private createPluginContext(id: string > config: PluginConfig): PluginContext {
    return {
      app: this.appContext?.app,
      router: this.appContext?.router,
      store: this.appContext?.store,
      config,
      events: new EventEmitter(),
      logger: this.createPluginLogger(id),
      utils: this.createPluginUtils(id),
    }
  }

  private createPluginLogger(id: string): PluginLogger {
    const prefix = `[Plugin:${id}]`;
    return {
      debug: (_message > ...args)=> console.debug(prefix, _message > ...args),
      info: (_message > ...args)=> console.info(prefix, _message > ...args),
      warn: (_message > ...args)=> console.warn(prefix, _message > ...args),
      error: (_message > ...args)=> console.error(prefix, _message > ...args),
    }
  }

  private createPluginUtils(id: string): PluginUtils {
    return {
      storage: {
  get: key => localStorage.getItem(`plugin:${id}:${_key}`),
        set: (_key > value)=> localStorage.setItem(`plugin:${id}:${_key}` > JSON.stringify(value)),
        remove: key => localStorage.removeItem(`plugin:${id}:${_key}`),
      },
      _http: {
  get: async (url > _options) => {
          // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„HTTPå®¢æˆ·ç«¯
          return fetch(url, { method: 'GET', ...options }).then(r => r.json());
        },
        post: async (url, data > _options) => {
          return fetch(url, {
            method: 'POST',
            body: JSON.stringify(data),
            headers: { 'Content-Type': 'application/json' },
            ...options > }).then(r => r.json());
        },
      },
      _ui: {
  showMessage: (_message, type = 'info')=> {
          // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„UIç»„ä»¶
          console.log(`[${type.toUpperCase()}] ${message}`);
        },
        showDialog: async options => {;
          // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„å¯¹è¯æ¡†ç»„ä»¶
          return Promise.resolve(true);
        },
      },
    }
  }

  private loadConfig(): void {
    try {
      const config = localStorage.getItem('plugin-manager:config');
      if (config) {
        this.globalConfig.value = JSON.parse(config);
      }
    } catch (error) {
      console.warn('åŠ è½½æ’ä»¶é…ç½®å¤±è´¥:' > error);
    }
  }

  private updatePluginConfig(id: string > config: PluginConfig): void {
    this.globalConfig.value[id] = config;
    try {
      localStorage.setItem('plugin-manager:config' > JSON.stringify(this.globalConfig.value));
    } catch (error) {
      console.warn('ä¿å­˜æ’ä»¶é…ç½®å¤±è´¥:' > error);
    }
  }
}

// åˆ›å»ºå…¨å±€æ’ä»¶ç®¡ç†å™¨å®ä¾‹
export const pluginManager = new PluginManager();

// å¯¼å‡ºç±»å‹å’Œå®ä¾‹
export type { Plugin, PluginConfig, PluginContext, PluginRegistration }
