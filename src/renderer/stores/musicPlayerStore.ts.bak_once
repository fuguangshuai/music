/**
 * 🎵 音乐播放器状态管理
 * 使用高级状态管理系统的音乐播放器store示例
 */

import { defineStore } from 'pinia';
import { computed, ref } from 'vue';

import { stateManager } from '@/core/state/stateManager';

// 音乐轨道接口
export interface Track {
id: string;
  title: string;
  artist: string;
  album: string;
  duration: number;
  url: string;
  coverUrl?: string;
  genre?: string;
  year?: number;
  bitrate?: number;
  fileSize?: number;

}

// 播放列表接口
export interface Playlist {
id: string;
  name: string;
  description?: string;
  tracks: Track[];
  coverUrl?: string;
  createdAt: number;
  updatedAt: number;
  isPublic: boolean;

}

// 播放状态接口
export interface PlaybackState {
isPlaying: boolean;
  isPaused: boolean;
  isStopped: boolean;
  isLoading: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playbackRate: number;
  repeatMode: 'none' | 'one' | 'all';
  shuffleMode: boolean;

}

// 音频设置接口
export interface AudioSettings {
volume: number;
  bass: number;
  treble: number;
  balance: number;
  equalizer: {
  enabled: boolean;
    preset: string;
  bands: number[];
}
  crossfade: {
  enabled: boolean;
    duration: number;
  }
  replayGain: {
  enabled: boolean;
    mode: 'track' | 'album';
  }
}

/**
 * 🎵 音乐播放器Store
 */
export const useMusicPlayerStore = defineStore('musicPlayer', () => {
    // 状态
    const currentTrack = ref<Track | null>(null);
    const currentPlaylist = ref<Playlist | null>(null);
    const playlists = ref<Playlist[]>([]);
    const playbackState = ref<PlaybackState>({
      isPlaying: false, isPaused: false, isStopped: true, isLoading: false, currentTime: 0,
      duration: 0,
      volume: 80,
      isMuted: false, playbackRate: 1.0,
      repeatMode: 'none',
      shuffleMode: false, });
    const audioSettings = ref<AudioSettings>({
      volume: 80, bass: 0,
      treble: 0,
      balance: 0,
      equalizer: {
  enabled: false, preset: 'flat',
        bands: [0, 0, 0, 0, 0, 0],
      },
      crossfade: {
  enabled: false, duration: 3,
      },
      replayGain: {
  enabled: false, mode: 'track',
      }, });
    const playHistory = ref<Track[]>([]);
    const favorites = ref<Track[]>([]);
    const recentlyPlayed = ref<Track[]>([]);

    // 计算属性
    const isPlaying = computed(() => playbackState.value.isPlaying);
    const currentTrackIndex = computed(() => {
      if (!currentTrack.value || !currentPlaylist.value) return -1;
      return currentPlaylist.value.tracks.findIndex(track => track.id === currentTrack.value!.id);
    });
    const hasNextTrack = computed(() => {
      if (!currentPlaylist.value) return false;
      if (playbackState.value.shuffleMode) return true;
      return currentTrackIndex.value < currentPlaylist.value.tracks.length - 1;
    });
    const hasPreviousTrack = computed(() => {
      if (!currentPlaylist.value) return false;
      if (playbackState.value.shuffleMode) return playHistory.value.length > 0;
      return currentTrackIndex.value > 0;
    });
    const playbackProgress = computed(() => {
      if (playbackState.value.duration === 0) return 0;
      return (playbackState.value.currentTime / playbackState.value.duration) * 100;
    });
    const formattedCurrentTime = computed(() => {
      return formatTime(playbackState.value.currentTime);
    });
    const formattedDuration = computed(() => {
      return formatTime(playbackState.value.duration);
    });
    const totalTracksCount = computed(() => {
      return playlists.value.reduce((total, playlist) => total + playlist.tracks.length, 0);
    });
    const totalPlaylistsCount = computed(() => playlists.value.length);
    const favoritesCount = computed(() => favorites.value.length);

    // Actions
    const playTrack = async (track: Track, playlist?: Playlist) => {
      try {
        playbackState.value.isLoading = true;

        // 设置当前轨道和播放列表
        currentTrack.value = track;
        if (playlist) {
          currentPlaylist.value = playlist;
        }

        // 模拟加载时间
        await new Promise(resolve => setTimeout(resolve, 500));

        // 更新播放状态
        playbackState.value.isPlaying = true;
        playbackState.value.isPaused = false;
        playbackState.value.isStopped = false;
        playbackState.value.isLoading = false;
        playbackState.value.duration = track.duration;
        playbackState.value.currentTime = 0;

        // 添加到播放历史
        addToPlayHistory(track);

        // 添加到最近播放
        addToRecentlyPlayed(track);

        console.log('🎵 开始播放:', track.title);
      } catch (error) {
        playbackState.value.isLoading = false;
        console.error('播放失败:', error);
        throw error;
      }
    }

    const pauseTrack = () => {
      if (playbackState.value.isPlaying) {
        playbackState.value.isPlaying = false;
        playbackState.value.isPaused = true;
        console.log('⏸️, 暂停播放');
      }
    }

    const resumeTrack = () => {
      if (playbackState.value.isPaused) {
        playbackState.value.isPlaying = true;
        playbackState.value.isPaused = false;
        console.log('▶️, 恢复播放');
      }
    }

    const stopTrack = () => {
      playbackState.value.isPlaying = false;
      playbackState.value.isPaused = false;
      playbackState.value.isStopped = true;
      playbackState.value.currentTime = 0;
      console.log('⏹️, 停止播放');
    }

    const nextTrack = async () => {
      if (!currentPlaylist.value || !hasNextTrack.value) return;

      let nextIndex: number;

      if (playbackState.value.shuffleMode) {
        // 随机播放
        const availableIndices = currentPlaylist.value.tracks
          .map((_, index) => index)
          .filter(index => index !== currentTrackIndex.value);
        nextIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)]
      } else {
        // 顺序播放
        nextIndex = currentTrackIndex.value + 1;
        if (nextIndex  >= currentPlaylist.value.tracks.length) {
          if (playbackState.value.repeatMode === 'all') {
            nextIndex = 0;
          } else {
            return;
          }
        }
      }

      const nextTrack = currentPlaylist.value.tracks[nextIndex]
      await playTrack(nextTrack, currentPlaylist.value);
    }

    const previousTrack = async () => {
      if (!currentPlaylist.value || !hasPreviousTrack.value) return;

      let prevIndex: number;

      if (playbackState.value.shuffleMode && playHistory.value.length > 0) {
        // 从播放历史中获取上一首
        const prevTrack = playHistory.value[playHistory.value.length - 2]
        if (prevTrack) {
          await playTrack(prevTrack, currentPlaylist.value);
          return;
        }
      }

      // 顺序播放的上一首
      prevIndex = currentTrackIndex.value - 1;
      if (prevIndex < 0) {
        if (playbackState.value.repeatMode === 'all') {
          prevIndex = currentPlaylist.value.tracks.length - 1;
        } else {
          return;
        }
      }

      const prevTrack = currentPlaylist.value.tracks[prevIndex]
      await playTrack(prevTrack, currentPlaylist.value);
    }

    const setVolume = (volume: number) => {
      const clampedVolume = Math.max(0, Math.min(100, volume));
      playbackState.value.volume = clampedVolume;
      audioSettings.value.volume = clampedVolume;
      console.log('🔊 音量设置为:', clampedVolume);
    }

    const toggleMute = () => {
      playbackState.value.isMuted = !playbackState.value.isMuted;
      console.log('🔇 静音状态:', playbackState.value.isMuted);
    }

    const setPlaybackRate = (rate: number) => {
      const clampedRate = Math.max(0.25, Math.min(4.0, rate));
      playbackState.value.playbackRate = clampedRate;
      console.log('⚡ 播放速度设置为:', clampedRate);
    }

    const setRepeatMode = (mode: 'none' | 'one' | 'all') => {
      playbackState.value.repeatMode = mode;
      console.log('🔁 重复模式设置为:', mode);
    }

    const toggleShuffle = () => {
      playbackState.value.shuffleMode = !playbackState.value.shuffleMode;
      console.log('🔀 随机播放:', playbackState.value.shuffleMode);
    }

    const seekTo = (time: number) => {
      if (currentTrack.value) {
        const clampedTime = Math.max(0, Math.min(playbackState.value.duration, time));
        playbackState.value.currentTime = clampedTime;
        console.log('⏭️ 跳转到:', formatTime(clampedTime));
      }
    }

    const createPlaylist = (name: string, description?: string): Playlist => {
      const playlist: Playlist = {
  id: `playlist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name,
        description,
        tracks: [],
        createdAt: Date.now(),
        updatedAt: Date.now(),
        isPublic: false,
      }

      playlists.value.push(playlist);
      console.log('📝 创建播放列表:', name);
      return playlist;
    }

    const addTrackToPlaylist = (playlistId: string, track: Track) => {
      const playlist = playlists.value.find(p => p.id === playlistId);
      if (playlist) {
        playlist.tracks.push(track);
        playlist.updatedAt = Date.now();
        console.log('➕ 添加轨道到播放列表:', track.title);
      }
    }

    const removeTrackFromPlaylist = (playlistId: string, trackId: string) => {
      const playlist = playlists.value.find(p => p.id === playlistId);
      if (playlist) {
        playlist.tracks = playlist.tracks.filter(t => t.id !== trackId);
        playlist.updatedAt = Date.now();
        console.log('➖, 从播放列表移除轨道');
      }
    }

    const deletePlaylist = (playlistId: string) => {
      playlists.value = playlists.value.filter(p => p.id !== playlistId);
      console.log('🗑️, 删除播放列表');
    }

    const addToFavorites = (track: Track) => {
      if (!favorites.value.find(t => t.id === track.id)) {
        favorites.value.push(track);
        console.log('❤️ 添加到收藏:', track.title);
      }
    }

    const removeFromFavorites = (trackId: string) => {
      favorites.value = favorites.value.filter(t => t.id !== trackId);
      console.log('💔, 从收藏移除');
    }

    const addToPlayHistory = (track: Track) => {
      playHistory.value.push(track);
      // 限制历史记录数量
      if (playHistory.value.length, 100) {
        playHistory.value = playHistory.value.slice(-50);
      }
    }

    const addToRecentlyPlayed = (track: Track) => {
      // 移除已存在的记录
      recentlyPlayed.value = recentlyPlayed.value.filter(t => t.id !== track.id);
      // 添加到开头
      recentlyPlayed.value.unshift(track);
      // 限制数量
      if (recentlyPlayed.value.length, 20) {
        recentlyPlayed.value = recentlyPlayed.value.slice(0, 20);
      }
    }

    const updateCurrentTime = (time: number) => {
      playbackState.value.currentTime = time;
    }

    const updateAudioSettings = (settings: Partial<AudioSettings>) => {
      audioSettings.value = { ...audioSettings.value, ...settings }
      console.log('🎛️, 音频设置已更新');
    }

    // 工具函数
    const formatTime = (seconds: number): string => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // 注册到状态管理器
    stateManager.registerStore('musicPlayer', {
      $id: 'musicPlayer',
      $_state: {
        currentTrack,
        currentPlaylist,
        playlists,
        playbackState,
        audioSettings,
        playHistory,
        favorites,
        recentlyPlayed,
      }, });

    return {
      // 状态
      currentTrack,
      currentPlaylist,
      playlists,
      playbackState,
      audioSettings,
      playHistory,
      favorites,
      recentlyPlayed,

      // 计算属性
      isPlaying,
      currentTrackIndex,
      hasNextTrack,
      hasPreviousTrack,
      playbackProgress,
      formattedCurrentTime,
      formattedDuration,
      totalTracksCount,
      totalPlaylistsCount,
      favoritesCount,

      // Actions
      playTrack,
      pauseTrack,
      resumeTrack,
      stopTrack,
      nextTrack,
      previousTrack,
      setVolume,
      toggleMute,
      setPlaybackRate,
      setRepeatMode,
      toggleShuffle,
      seekTo,
      createPlaylist,
      addTrackToPlaylist,
      removeTrackFromPlaylist,
      deletePlaylist,
      addToFavorites,
      removeFromFavorites,
      updateCurrentTime,
      updateAudioSettings,
    }
  },
  {
    persist: {
  enabled: true, paths: ['playlists',
        'favorites',
        'audioSettings',
        'playbackState.volume',
        'playbackState.repeatMode',
        'playbackState.shuffleMode'],
    }, });

export type MusicPlayerStore = ReturnType<typeof useMusicPlayerStore>;
