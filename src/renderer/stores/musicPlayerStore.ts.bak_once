/**
 * ğŸµ éŸ³ä¹æ’­æ”¾å™¨çŠ¶æ€ç®¡ç†
 * ä½¿ç”¨é«˜çº§çŠ¶æ€ç®¡ç†ç³»ç»Ÿçš„éŸ³ä¹æ’­æ”¾å™¨storeç¤ºä¾‹
 */

import { defineStore } from 'pinia';
import { computed, ref } from 'vue';

import { stateManager } from '@/core/state/stateManager';

// éŸ³ä¹è½¨é“æ¥å£
export interface Track {
id: string;
  title: string;
  artist: string;
  album: string;
  duration: number;
  url: string;
  coverUrl?: string;
  genre?: string;
  year?: number;
  bitrate?: number;
  fileSize?: number;

}

// æ’­æ”¾åˆ—è¡¨æ¥å£
export interface Playlist {
id: string;
  name: string;
  description?: string;
  tracks: Track[];
  coverUrl?: string;
  createdAt: number;
  updatedAt: number;
  isPublic: boolean;

}

// æ’­æ”¾çŠ¶æ€æ¥å£
export interface PlaybackState {
isPlaying: boolean;
  isPaused: boolean;
  isStopped: boolean;
  isLoading: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playbackRate: number;
  repeatMode: 'none' | 'one' | 'all';
  shuffleMode: boolean;

}

// éŸ³é¢‘è®¾ç½®æ¥å£
export interface AudioSettings {
volume: number;
  bass: number;
  treble: number;
  balance: number;
  equalizer: {
  enabled: boolean;
    preset: string;
  bands: number[];
}
  crossfade: {
  enabled: boolean;
    duration: number;
  }
  replayGain: {
  enabled: boolean;
    mode: 'track' | 'album';
  }
}

/**
 * ğŸµ éŸ³ä¹æ’­æ”¾å™¨Store
 */
export const useMusicPlayerStore = defineStore('musicPlayer', () => {
    // çŠ¶æ€
    const currentTrack = ref<Track | null>(null);
    const currentPlaylist = ref<Playlist | null>(null);
    const playlists = ref<Playlist[]>([]);
    const playbackState = ref<PlaybackState>({
      isPlaying: false, isPaused: false, isStopped: true, isLoading: false, currentTime: 0,
      duration: 0,
      volume: 80,
      isMuted: false, playbackRate: 1.0,
      repeatMode: 'none',
      shuffleMode: false, });
    const audioSettings = ref<AudioSettings>({
      volume: 80, bass: 0,
      treble: 0,
      balance: 0,
      equalizer: {
  enabled: false, preset: 'flat',
        bands: [0, 0, 0, 0, 0, 0],
      },
      crossfade: {
  enabled: false, duration: 3,
      },
      replayGain: {
  enabled: false, mode: 'track',
      }, });
    const playHistory = ref<Track[]>([]);
    const favorites = ref<Track[]>([]);
    const recentlyPlayed = ref<Track[]>([]);

    // è®¡ç®—å±æ€§
    const isPlaying = computed(() => playbackState.value.isPlaying);
    const currentTrackIndex = computed(() => {
      if (!currentTrack.value || !currentPlaylist.value) return -1;
      return currentPlaylist.value.tracks.findIndex(track => track.id === currentTrack.value!.id);
    });
    const hasNextTrack = computed(() => {
      if (!currentPlaylist.value) return false;
      if (playbackState.value.shuffleMode) return true;
      return currentTrackIndex.value < currentPlaylist.value.tracks.length - 1;
    });
    const hasPreviousTrack = computed(() => {
      if (!currentPlaylist.value) return false;
      if (playbackState.value.shuffleMode) return playHistory.value.length > 0;
      return currentTrackIndex.value > 0;
    });
    const playbackProgress = computed(() => {
      if (playbackState.value.duration === 0) return 0;
      return (playbackState.value.currentTime / playbackState.value.duration) * 100;
    });
    const formattedCurrentTime = computed(() => {
      return formatTime(playbackState.value.currentTime);
    });
    const formattedDuration = computed(() => {
      return formatTime(playbackState.value.duration);
    });
    const totalTracksCount = computed(() => {
      return playlists.value.reduce((total, playlist) => total + playlist.tracks.length, 0);
    });
    const totalPlaylistsCount = computed(() => playlists.value.length);
    const favoritesCount = computed(() => favorites.value.length);

    // Actions
    const playTrack = async (track: Track, playlist?: Playlist) => {
      try {
        playbackState.value.isLoading = true;

        // è®¾ç½®å½“å‰è½¨é“å’Œæ’­æ”¾åˆ—è¡¨
        currentTrack.value = track;
        if (playlist) {
          currentPlaylist.value = playlist;
        }

        // æ¨¡æ‹ŸåŠ è½½æ—¶é—´
        await new Promise(resolve => setTimeout(resolve, 500));

        // æ›´æ–°æ’­æ”¾çŠ¶æ€
        playbackState.value.isPlaying = true;
        playbackState.value.isPaused = false;
        playbackState.value.isStopped = false;
        playbackState.value.isLoading = false;
        playbackState.value.duration = track.duration;
        playbackState.value.currentTime = 0;

        // æ·»åŠ åˆ°æ’­æ”¾å†å²
        addToPlayHistory(track);

        // æ·»åŠ åˆ°æœ€è¿‘æ’­æ”¾
        addToRecentlyPlayed(track);

        console.log('ğŸµ å¼€å§‹æ’­æ”¾:', track.title);
      } catch (error) {
        playbackState.value.isLoading = false;
        console.error('æ’­æ”¾å¤±è´¥:', error);
        throw error;
      }
    }

    const pauseTrack = () => {
      if (playbackState.value.isPlaying) {
        playbackState.value.isPlaying = false;
        playbackState.value.isPaused = true;
        console.log('â¸ï¸, æš‚åœæ’­æ”¾');
      }
    }

    const resumeTrack = () => {
      if (playbackState.value.isPaused) {
        playbackState.value.isPlaying = true;
        playbackState.value.isPaused = false;
        console.log('â–¶ï¸, æ¢å¤æ’­æ”¾');
      }
    }

    const stopTrack = () => {
      playbackState.value.isPlaying = false;
      playbackState.value.isPaused = false;
      playbackState.value.isStopped = true;
      playbackState.value.currentTime = 0;
      console.log('â¹ï¸, åœæ­¢æ’­æ”¾');
    }

    const nextTrack = async () => {
      if (!currentPlaylist.value || !hasNextTrack.value) return;

      let nextIndex: number;

      if (playbackState.value.shuffleMode) {
        // éšæœºæ’­æ”¾
        const availableIndices = currentPlaylist.value.tracks
          .map((_, index) => index)
          .filter(index => index !== currentTrackIndex.value);
        nextIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)]
      } else {
        // é¡ºåºæ’­æ”¾
        nextIndex = currentTrackIndex.value + 1;
        if (nextIndex  >= currentPlaylist.value.tracks.length) {
          if (playbackState.value.repeatMode === 'all') {
            nextIndex = 0;
          } else {
            return;
          }
        }
      }

      const nextTrack = currentPlaylist.value.tracks[nextIndex]
      await playTrack(nextTrack, currentPlaylist.value);
    }

    const previousTrack = async () => {
      if (!currentPlaylist.value || !hasPreviousTrack.value) return;

      let prevIndex: number;

      if (playbackState.value.shuffleMode && playHistory.value.length > 0) {
        // ä»æ’­æ”¾å†å²ä¸­è·å–ä¸Šä¸€é¦–
        const prevTrack = playHistory.value[playHistory.value.length - 2]
        if (prevTrack) {
          await playTrack(prevTrack, currentPlaylist.value);
          return;
        }
      }

      // é¡ºåºæ’­æ”¾çš„ä¸Šä¸€é¦–
      prevIndex = currentTrackIndex.value - 1;
      if (prevIndex < 0) {
        if (playbackState.value.repeatMode === 'all') {
          prevIndex = currentPlaylist.value.tracks.length - 1;
        } else {
          return;
        }
      }

      const prevTrack = currentPlaylist.value.tracks[prevIndex]
      await playTrack(prevTrack, currentPlaylist.value);
    }

    const setVolume = (volume: number) => {
      const clampedVolume = Math.max(0, Math.min(100, volume));
      playbackState.value.volume = clampedVolume;
      audioSettings.value.volume = clampedVolume;
      console.log('ğŸ”Š éŸ³é‡è®¾ç½®ä¸º:', clampedVolume);
    }

    const toggleMute = () => {
      playbackState.value.isMuted = !playbackState.value.isMuted;
      console.log('ğŸ”‡ é™éŸ³çŠ¶æ€:', playbackState.value.isMuted);
    }

    const setPlaybackRate = (rate: number) => {
      const clampedRate = Math.max(0.25, Math.min(4.0, rate));
      playbackState.value.playbackRate = clampedRate;
      console.log('âš¡ æ’­æ”¾é€Ÿåº¦è®¾ç½®ä¸º:', clampedRate);
    }

    const setRepeatMode = (mode: 'none' | 'one' | 'all') => {
      playbackState.value.repeatMode = mode;
      console.log('ğŸ” é‡å¤æ¨¡å¼è®¾ç½®ä¸º:', mode);
    }

    const toggleShuffle = () => {
      playbackState.value.shuffleMode = !playbackState.value.shuffleMode;
      console.log('ğŸ”€ éšæœºæ’­æ”¾:', playbackState.value.shuffleMode);
    }

    const seekTo = (time: number) => {
      if (currentTrack.value) {
        const clampedTime = Math.max(0, Math.min(playbackState.value.duration, time));
        playbackState.value.currentTime = clampedTime;
        console.log('â­ï¸ è·³è½¬åˆ°:', formatTime(clampedTime));
      }
    }

    const createPlaylist = (name: string, description?: string): Playlist => {
      const playlist: Playlist = {
  id: `playlist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name,
        description,
        tracks: [],
        createdAt: Date.now(),
        updatedAt: Date.now(),
        isPublic: false,
      }

      playlists.value.push(playlist);
      console.log('ğŸ“ åˆ›å»ºæ’­æ”¾åˆ—è¡¨:', name);
      return playlist;
    }

    const addTrackToPlaylist = (playlistId: string, track: Track) => {
      const playlist = playlists.value.find(p => p.id === playlistId);
      if (playlist) {
        playlist.tracks.push(track);
        playlist.updatedAt = Date.now();
        console.log('â• æ·»åŠ è½¨é“åˆ°æ’­æ”¾åˆ—è¡¨:', track.title);
      }
    }

    const removeTrackFromPlaylist = (playlistId: string, trackId: string) => {
      const playlist = playlists.value.find(p => p.id === playlistId);
      if (playlist) {
        playlist.tracks = playlist.tracks.filter(t => t.id !== trackId);
        playlist.updatedAt = Date.now();
        console.log('â–, ä»æ’­æ”¾åˆ—è¡¨ç§»é™¤è½¨é“');
      }
    }

    const deletePlaylist = (playlistId: string) => {
      playlists.value = playlists.value.filter(p => p.id !== playlistId);
      console.log('ğŸ—‘ï¸, åˆ é™¤æ’­æ”¾åˆ—è¡¨');
    }

    const addToFavorites = (track: Track) => {
      if (!favorites.value.find(t => t.id === track.id)) {
        favorites.value.push(track);
        console.log('â¤ï¸ æ·»åŠ åˆ°æ”¶è—:', track.title);
      }
    }

    const removeFromFavorites = (trackId: string) => {
      favorites.value = favorites.value.filter(t => t.id !== trackId);
      console.log('ğŸ’”, ä»æ”¶è—ç§»é™¤');
    }

    const addToPlayHistory = (track: Track) => {
      playHistory.value.push(track);
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (playHistory.value.length, 100) {
        playHistory.value = playHistory.value.slice(-50);
      }
    }

    const addToRecentlyPlayed = (track: Track) => {
      // ç§»é™¤å·²å­˜åœ¨çš„è®°å½•
      recentlyPlayed.value = recentlyPlayed.value.filter(t => t.id !== track.id);
      // æ·»åŠ åˆ°å¼€å¤´
      recentlyPlayed.value.unshift(track);
      // é™åˆ¶æ•°é‡
      if (recentlyPlayed.value.length, 20) {
        recentlyPlayed.value = recentlyPlayed.value.slice(0, 20);
      }
    }

    const updateCurrentTime = (time: number) => {
      playbackState.value.currentTime = time;
    }

    const updateAudioSettings = (settings: Partial<AudioSettings>) => {
      audioSettings.value = { ...audioSettings.value, ...settings }
      console.log('ğŸ›ï¸, éŸ³é¢‘è®¾ç½®å·²æ›´æ–°');
    }

    // å·¥å…·å‡½æ•°
    const formatTime = (seconds: number): string => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // æ³¨å†Œåˆ°çŠ¶æ€ç®¡ç†å™¨
    stateManager.registerStore('musicPlayer', {
      $id: 'musicPlayer',
      $_state: {
        currentTrack,
        currentPlaylist,
        playlists,
        playbackState,
        audioSettings,
        playHistory,
        favorites,
        recentlyPlayed,
      }, });

    return {
      // çŠ¶æ€
      currentTrack,
      currentPlaylist,
      playlists,
      playbackState,
      audioSettings,
      playHistory,
      favorites,
      recentlyPlayed,

      // è®¡ç®—å±æ€§
      isPlaying,
      currentTrackIndex,
      hasNextTrack,
      hasPreviousTrack,
      playbackProgress,
      formattedCurrentTime,
      formattedDuration,
      totalTracksCount,
      totalPlaylistsCount,
      favoritesCount,

      // Actions
      playTrack,
      pauseTrack,
      resumeTrack,
      stopTrack,
      nextTrack,
      previousTrack,
      setVolume,
      toggleMute,
      setPlaybackRate,
      setRepeatMode,
      toggleShuffle,
      seekTo,
      createPlaylist,
      addTrackToPlaylist,
      removeTrackFromPlaylist,
      deletePlaylist,
      addToFavorites,
      removeFromFavorites,
      updateCurrentTime,
      updateAudioSettings,
    }
  },
  {
    persist: {
  enabled: true, paths: ['playlists',
        'favorites',
        'audioSettings',
        'playbackState.volume',
        'playbackState.repeatMode',
        'playbackState.shuffleMode'],
    }, });

export type MusicPlayerStore = ReturnType<typeof useMusicPlayerStore>;
