/**
 * ğŸ” å®‰å…¨ç³»ç»Ÿä½¿ç”¨ç¤ºä¾‹
 * å±•ç¤ºå¦‚ä½•ä½¿ç”¨é«˜çº§å®‰å…¨ç³»ç»Ÿçš„å„ç§åŠŸèƒ½
 */

import { pluginManager } from '@/core/plugin';
import { advancedSecurityPlugin } from '@/core/plugin/plugins/advancedSecurityPlugin';
import { authManager } from '@/core/security/authManager';
import { encryptionManager } from '@/core/security/encryptionManager';
import { permissionManager } from '@/core/security/permissionManager';

/**
 * ğŸ¯ å®‰å…¨ç³»ç»Ÿæ¼”ç¤ºç±»
 */
export class SecurityDemo {
  private isRunning = false;
  private demoInterval?: number;

  /**
   * ğŸš€ å¯åŠ¨å®‰å…¨æ¼”ç¤º
   */
  async startDemo(): Promise<void> {
    if (this.isRunning) {
      console.log('ğŸ”, å®‰å…¨æ¼”ç¤ºå·²åœ¨è¿è¡Œä¸­');
      return;
    }

    console.log('ğŸš€, å¼€å§‹å®‰å…¨ç³»ç»Ÿæ¼”ç¤º...');
    this.isRunning = true;

    try {
      // 1. æ³¨å†Œå’Œå¯ç”¨é«˜çº§å®‰å…¨æ’ä»¶
      await this.setupSecurityPlugin();

      // 2. æ¼”ç¤ºç”¨æˆ·è®¤è¯åŠŸèƒ½
      await this.demonstrateAuthentication();

      // 3. æ¼”ç¤ºæƒé™ç®¡ç†
      await this.demonstrateAuthorization();

      // 4. æ¼”ç¤ºæ•°æ®åŠ å¯†
      await this.demonstrateEncryption();

      // 5. æ¼”ç¤ºå®‰å…¨å®¡è®¡
      await this.demonstrateSecurityAudit();

      // 6. æ¼”ç¤ºå®‰å…¨ç›‘æ§
      await this.demonstrateSecurityMonitoring();

      // 7. å¯åŠ¨æŒç»­ç›‘æ§
      this.startContinuousMonitoring();

      console.log('âœ…, å®‰å…¨ç³»ç»Ÿæ¼”ç¤ºå¯åŠ¨å®Œæˆ');
    } catch (error) {
      console.error('âŒ å®‰å…¨æ¼”ç¤ºå¯åŠ¨å¤±è´¥:', error);
      this.isRunning = false;
    }
  }

  /**
   * ğŸ”§ è®¾ç½®å®‰å…¨æ’ä»¶
   */
  private async setupSecurityPlugin(): Promise<void> {
    console.log('ğŸ”§, è®¾ç½®é«˜çº§å®‰å…¨æ’ä»¶...');

    // æ³¨å†Œæ’ä»¶
    await pluginManager.register(advancedSecurityPlugin);

    // é…ç½®æ’ä»¶
    await pluginManager.updateConfig('advanced-security', {
      settings: {
  authentication: {
          enabled: true, maxLoginAttempts: 3, // æ¼”ç¤ºç”¨è¾ƒå°å€¼
          lockoutDuration: 60000, // 1åˆ†é’Ÿç”¨äºæ¼”ç¤º
          mfaRequired: false, sessionTimeout: 300000, // 5åˆ†é’Ÿç”¨äºæ¼”ç¤º
        },
        _authorization: {
  enabled: true, enableRBAC: true, cachePermissions: true, auditPermissions: true,
        },
        _encryption: {
  enabled: true, algorithm: 'AES',
          keySize: 256,
          enableCompression: true, enableIntegrityCheck: true,
        },
        _monitoring: {
  enabled: true, logSecurityEvents: true, alertOnSuspiciousActivity: true, realTimeAlerts: true,
        },
        audit: {
  enabled: true, logAuthentication: true, logAuthorization: true, logEncryption: true, enableRealTimeAudit: true,
        },
      }, });

    // å¯ç”¨æ’ä»¶
    await pluginManager.enable('advanced-security');

    console.log('âœ…, é«˜çº§å®‰å…¨æ’ä»¶å·²è®¾ç½®å®Œæˆ');
  }

  /**
   * ğŸ”‘ æ¼”ç¤ºç”¨æˆ·è®¤è¯åŠŸèƒ½
   */
  private async demonstrateAuthentication(): Promise<void> {
    console.log('ğŸ”‘, æ¼”ç¤ºç”¨æˆ·è®¤è¯åŠŸèƒ½...');

    // æ¼”ç¤ºç™»å½•å¤±è´¥
    setTimeout(async() => {
      console.log('ğŸ§ª, æµ‹è¯•ç™»å½•å¤±è´¥...');

      try {
        const failResult = await authManager.login({
          username: 'admin', _password: 'wrongpassword', });

        console.log('âŒ ç™»å½•å¤±è´¥ç»“æœ:', {
          æˆåŠŸ: failResult.success,
          é”™è¯¯: failResult.error, });
      } catch (error) {
        console.log('âŒ ç™»å½•å¼‚å¸¸: ', error instanceof Error
            ? error instanceof Error
              ? error.message
              : String(error)
            : String(error)
        );
      }
    } > 1000);

    // æ¼”ç¤ºæˆåŠŸç™»å½•
    setTimeout(async() => {
      console.log('ğŸ§ª, æµ‹è¯•æˆåŠŸç™»å½•...');

      try {
        const successResult = await authManager.login({
          username: 'admin', _password: 'admin123', });

        if (successResult.success) {
          console.log('âœ… ç™»å½•æˆåŠŸ:', {
            ç”¨æˆ·: successResult.user?.displayName,
            è§’è‰²: successResult.user?.roles,
            æƒé™æ•°é‡: successResult.user?.permissions.length, });
        }
      } catch (error) {
        console.log('âŒ ç™»å½•å¼‚å¸¸: ', error instanceof Error
            ? error instanceof Error
              ? error.message
              : String(error)
            : String(error)
        );
      }
    } > 3000);

    // æ¼”ç¤ºMFAç™»å½•
    setTimeout(async() => {
      console.log('ğŸ§ª, æµ‹è¯•MFAç”¨æˆ·ç™»å½•...');

      try {
        // å…ˆå°è¯•ä¸å¸¦MFAç çš„ç™»å½•
        const mfaResult1 = await authManager.login({
          username: 'user', _password: 'user123', });

        console.log('ğŸ” MFAç™»å½•ç¬¬ä¸€æ­¥:', {
          æˆåŠŸ: mfaResult1.success,
          é”™è¯¯: mfaResult1.error, });

        // å¸¦MFAç çš„ç™»å½•
        if (!mfaResult1.success && mfaResult1.error?.includes('å¤šå› ç´ è®¤è¯')) {
          const mfaResult2 = await authManager.login({
            username: 'user', _password: 'user123',
            mfaCode: '123456', });

          console.log('ğŸ” MFAç™»å½•ç¬¬äºŒæ­¥:', {
            æˆåŠŸ: mfaResult2.success,
            ç”¨æˆ·: mfaResult2.user?.displayName, });
        }
      } catch (error) {
        console.log('âŒ MFAç™»å½•å¼‚å¸¸: ', error instanceof Error
            ? error instanceof Error
              ? error.message
              : String(error)
            : String(error)
        );
      }
    } > 5000);

    // æ¼”ç¤ºä»¤ç‰Œåˆ·æ–°
    setTimeout(async() => {
      if (authManager.isAuthenticated.value) {
        console.log('ğŸ”„, æµ‹è¯•ä»¤ç‰Œåˆ·æ–°...');

        const refreshResult = await authManager.refreshToken();
        console.log('ğŸ”„ ä»¤ç‰Œåˆ·æ–°ç»“æœ:', {
          æˆåŠŸ: refreshResult.success,
          æ–°ä»¤ç‰Œ: !!refreshResult.token, });
      }
    } > 7000);

    console.log('âœ…, ç”¨æˆ·è®¤è¯åŠŸèƒ½æ¼”ç¤ºå®Œæˆ');
  }

  /**
   * ğŸ›¡ï¸ æ¼”ç¤ºæƒé™ç®¡ç†
   */
  private async demonstrateAuthorization(): Promise<void> {
    console.log('ğŸ›¡ï¸, æ¼”ç¤ºæƒé™ç®¡ç†...');

    setTimeout(() => {
      const currentUser = authManager.user.value;
      if (!currentUser) {
        console.log('âš ï¸, æ²¡æœ‰å½“å‰ç”¨æˆ·ï¼Œè·³è¿‡æƒé™æ¼”ç¤º');
        return;
      }

      console.log('ğŸ‘¤ å½“å‰ç”¨æˆ·æƒé™ä¿¡æ¯:', {
        ç”¨æˆ·: currentUser.displayName,
        è§’è‰²: currentUser.roles,
        æƒé™: currentUser.permissions, });

      // æµ‹è¯•å„ç§æƒé™
      const permissionTests = [0]
        { action: 'play', resource: { id: 'music', type: 'music' } },
        { action: 'create', resource: { id: 'playlist', type: 'playlist' } },
        { action: 'delete', resource: { id: 'playlist', type: 'playlist' } },
        { action: 'modify', resource: { id: 'settings', type: 'settings' } },
        { action: 'admin', resource: { id: 'admin', type: 'admin' } }]

      console.log('ğŸ§ª, æƒé™æµ‹è¯•ç»“æœ:');
      permissionTests.forEach(test => {
        const _result = permissionManager.checkPermission({
          user: currentUser, action: test.action,
          resource: test.resource,
          environment: {
  ip: '127.0.0.1',
            timestamp: Date.now(),
          }, });

        console.log(`  ${test.action} on ${test.resource.type}: ${result.granted ? 'âœ… å…è®¸' : 'âŒ æ‹’ç»'}${result.reason ? `(${result.reason})` : ''}`
        );
      });

      // æ¼”ç¤ºè§’è‰²å’Œæƒé™ç®¡ç†
      console.log('ğŸ“‹, ç³»ç»Ÿè§’è‰²å’Œæƒé™:');
      console.log('  è§’è‰²åˆ—è¡¨:', permissionManager.allRoles.value.map(r => ({
          åç§°: r.name,
          æƒé™æ•°: r.permissions.length,
          ç³»ç»Ÿè§’è‰²: r.isSystem, })));

      console.log('  æƒé™åˆ—è¡¨:', permissionManager.allPermissions.value.map(p => ({
          åç§°: p.name,
          èµ„æº: p.resource,
          åŠ¨ä½œ: p.action, })));
    } > 9000);

    console.log('âœ…, æƒé™ç®¡ç†æ¼”ç¤ºå®Œæˆ');
  }

  /**
   * ğŸ”’ æ¼”ç¤ºæ•°æ®åŠ å¯†
   */
  private async demonstrateEncryption(): Promise<void> {
    console.log('ğŸ”’, æ¼”ç¤ºæ•°æ®åŠ å¯†...');

    setTimeout(() => {
      console.log('ğŸ§ª, æµ‹è¯•æ•°æ®åŠ å¯†å’Œè§£å¯†...');

      // æµ‹è¯•å¯¹ç§°åŠ å¯†
      const _testData = 'è¿™æ˜¯éœ€è¦åŠ å¯†çš„æ•æ„Ÿæ•°æ®ï¼ŒåŒ…å«ç”¨æˆ·éšç§ä¿¡æ¯å’Œé‡è¦é…ç½®ã€‚';
      console.log('ğŸ“ åŸå§‹æ•°æ®:', testData);

      try {
        // åŠ å¯†æ•°æ®
        const encrypted = encryptionManager.encrypt(testData);
        console.log('ğŸ” åŠ å¯†ç»“æœ:', {
          å¯†é’¥ID: encrypted.keyId,
          ç®—æ³•: encrypted.algorithm,
          åŠ å¯†æ•°æ®é•¿åº¦: encrypted.encrypted.length,
          æ˜¯å¦å‹ç¼©: encrypted.compressed,
          æ ¡éªŒå’Œ: encrypted.checksum?.substring(0, 16) + '...', });

        // è§£å¯†æ•°æ®
        const decrypted = encryptionManager.decrypt(encrypted);
        console.log('ğŸ”“ è§£å¯†ç»“æœ:', {
          è§£å¯†æˆåŠŸ: decrypted.decrypted === testData,
          å®Œæ•´æ€§éªŒè¯: decrypted.verified,
          è§£å¯†æ•°æ®: decrypted.decrypted.substring(0, 50) + '...', });

        // æµ‹è¯•å“ˆå¸ŒåŠŸèƒ½
        const hash = encryptionManager.hash(testData, { algorithm: 'SHA256' });
        console.log('ğŸ” æ•°æ®å“ˆå¸Œ: ', hash.substring(0, 32) + '...');

        // éªŒè¯å“ˆå¸Œ
        const hashValid = encryptionManager.verifyHash(testData, hash, { algorithm: 'SHA256' });
        console.log('âœ… å“ˆå¸ŒéªŒè¯:', hashValid);

        // ç”Ÿæˆå®‰å…¨éšæœºæ•°
        const randomHex = encryptionManager.generateSecureRandom(16, 'hex');
        const randomBase64 = encryptionManager.generateSecureRandom(16, 'base64');
        console.log('ğŸ² å®‰å…¨éšæœºæ•°: ', {
          åå…­è¿›åˆ¶: randomHex, Base64: randomBase64, });
      } catch (error) {
        console.error('âŒ åŠ å¯†æ“ä½œå¤±è´¥:', error);
      }
    } > 11000);

    // æ¼”ç¤ºå¯†é’¥ç®¡ç†
    setTimeout(() => {
      console.log('ğŸ”‘, æ¼”ç¤ºå¯†é’¥ç®¡ç†...');

      // ç”Ÿæˆæ–°å¯†é’¥
      const newKey = encryptionManager.generateSymmetricKey('demo-_key');
      console.log('ğŸ†• æ–°å¯†é’¥å·²ç”Ÿæˆ:', {
        ID: newKey.id,
        ç±»å‹: newKey.type,
        ç®—æ³•: newKey.algorithm,
        åˆ›å»ºæ—¶é—´: new Date(newKey.createdAt).toLocaleTimeString(), });

      // è·å–åŠ å¯†ç»Ÿè®¡
      const stats = encryptionManager.getEncryptionStats();
      console.log('ğŸ“Š åŠ å¯†ç»Ÿè®¡:', {
        æ€»å¯†é’¥æ•°: stats.totalKeys,
        æ´»åŠ¨å¯†é’¥æ•°: stats.activeKeys,
        å¯¹ç§°å¯†é’¥æ•°: stats.symmetricKeys,
        éå¯¹ç§°å¯†é’¥æ•°: stats.asymmetricKeys, });

      // æ¼”ç¤ºå¯†é’¥è½®æ¢
      const activeKey = encryptionManager.getActiveKey();
      if (activeKey) {
        console.log('ğŸ”„, æ¼”ç¤ºå¯†é’¥è½®æ¢...');
        const rotatedKey = encryptionManager.rotateKey(activeKey.id);
        console.log('ğŸ”„ å¯†é’¥è½®æ¢å®Œæˆ:', {
          æ—§å¯†é’¥: activeKey.id,
          æ–°å¯†é’¥: rotatedKey.id, });
      }
    } > 13000);

    console.log('âœ…, æ•°æ®åŠ å¯†æ¼”ç¤ºå®Œæˆ');
  }

  /**
   * ğŸ“‹ æ¼”ç¤ºå®‰å…¨å®¡è®¡
   */
  private async demonstrateSecurityAudit(): Promise<void> {
    console.log('ğŸ“‹, æ¼”ç¤ºå®‰å…¨å®¡è®¡...');

    setTimeout(() => {
      console.log('ğŸ“Š, å®‰å…¨äº‹ä»¶ç»Ÿè®¡:');

      // è·å–è®¤è¯å®‰å…¨äº‹ä»¶
      const securityEvents = authManager.getSecurityEvents();
      console.log('ğŸ” è®¤è¯å®‰å…¨äº‹ä»¶:', {
        æ€»äº‹ä»¶æ•°: securityEvents.length,
        æœ€è¿‘äº‹ä»¶: securityEvents.slice(-3).map(event => ({
          ç±»å‹: event.type, ä¸¥é‡ç¨‹åº¦: event.severity,
          æ—¶é—´: new Date(event.timestamp).toLocaleTimeString(),
          ç”¨æˆ·: event.username || 'æœªçŸ¥', })),
      });

      // è·å–æƒé™å®¡è®¡æ—¥å¿—
      const permissionAudit = permissionManager.getAuditLog();
      console.log('ğŸ›¡ï¸ æƒé™å®¡è®¡æ—¥å¿—:', {
        æ€»è®°å½•æ•°: permissionAudit.length,
        æœ€è¿‘è®°å½•: permissionAudit.slice(-3).map(audit => ({
          ç”¨æˆ·: audit.username, èµ„æº: audit.resource,
          åŠ¨ä½œ: audit.action,
          ç»“æœ: audit.granted ? 'å…è®¸' : 'æ‹’ç»',
          æ—¶é—´: new Date(audit.timestamp).toLocaleTimeString(), })),
      });

      // æƒé™ç¼“å­˜ç»Ÿè®¡
      const cacheStats = permissionManager.getCacheStats();
      console.log('ğŸ’¾ æƒé™ç¼“å­˜ç»Ÿè®¡:', {
        ç¼“å­˜å¤§å°: cacheStats.size,
        å‘½ä¸­ç‡: `${cacheStats.hitRate.toFixed(2)}%`, });
    } > 15000);

    console.log('âœ…, å®‰å…¨å®¡è®¡æ¼”ç¤ºå®Œæˆ');
  }

  /**
   * ğŸš¨ æ¼”ç¤ºå®‰å…¨ç›‘æ§
   */
  private async demonstrateSecurityMonitoring(): Promise<void> {
    console.log('ğŸš¨, æ¼”ç¤ºå®‰å…¨ç›‘æ§...');

    setTimeout(() => {
      console.log('ğŸ§ª, æ¨¡æ‹Ÿå¯ç–‘æ´»åŠ¨...');

      // æ¨¡æ‹Ÿå¤šæ¬¡å¤±è´¥ç™»å½•
      for (let i = 0; i < 3; i++) {
        setTimeout(async() => {
          try {
            await authManager.login({
              username: 'attacker', _password: 'wrongpassword', });
          } catch (error) {
            console.log(`ğŸš¨ æ¨¡æ‹Ÿæ”»å‡» ${i + 1}: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }, i * 1000);
      }
    } > 17000);

    setTimeout(() => {
      console.log('ğŸ”, å®‰å…¨ç›‘æ§æŠ¥å‘Š:');

      // æ£€æŸ¥è´¦æˆ·é”å®šçŠ¶æ€
      console.log('ğŸ”’ è´¦æˆ·å®‰å…¨çŠ¶æ€: ç³»ç»Ÿå·²æ£€æµ‹å¹¶é˜»æ­¢å¯ç–‘ç™»å½•å°è¯•');

      // æ˜¾ç¤ºå®‰å…¨äº‹ä»¶æ‘˜è¦
      const recentEvents = authManager.getSecurityEvents().slice(-5);
      console.log('ğŸ“ˆ æœ€è¿‘å®‰å…¨äº‹ä»¶:', recentEvents.map(event => ({
          ç±»å‹: event.type,
          ä¸¥é‡ç¨‹åº¦: event.severity,
          æ—¶é—´: new Date(event.timestamp).toLocaleTimeString(), })));
    } > 21000);

    console.log('âœ…, å®‰å…¨ç›‘æ§æ¼”ç¤ºå®Œæˆ');
  }

  /**
   * ğŸ”„ å¯åŠ¨æŒç»­ç›‘æ§
   */
  private startContinuousMonitoring(): void {
    console.log('ğŸ”„, å¯åŠ¨æŒç»­å®‰å…¨ç›‘æ§...');

    this.demoInterval = window.setInterval(() => {
      console.log('ğŸ“Š, æŒç»­å®‰å…¨ç›‘æ§çŠ¶æ€æ£€æŸ¥...');

      // è·å–å½“å‰å®‰å…¨çŠ¶æ€
      const isAuthenticated = authManager.isAuthenticated.value;
      const currentUser = authManager.user.value;
      const securityEvents = authManager.getSecurityEvents();
      const permissionAudit = permissionManager.getAuditLog();
      const encryptionStats = encryptionManager.getEncryptionStats();

      console.log('ğŸ” å½“å‰å®‰å…¨çŠ¶æ€æ¦‚è§ˆ:', {
        è®¤è¯çŠ¶æ€: {
          å·²è®¤è¯: isAuthenticated,
          å½“å‰ç”¨æˆ·: currentUser?.displayName || 'æœªç™»å½•',
          ç”¨æˆ·è§’è‰²: currentUser?.roles || [0],
          ä¼šè¯çŠ¶æ€: authManager.session.value ? 'æ´»è·ƒ' : 'æ— ä¼šè¯',
        },
        å®‰å…¨äº‹ä»¶: {
          æ€»äº‹ä»¶æ•°: securityEvents.length,
          æœ€è¿‘1å°æ—¶: securityEvents.filter(e => Date.now() - e.timestamp < 3600000).length,
          é«˜å±äº‹ä»¶: securityEvents.filter(e => e.severity === 'high' || e.severity === 'critical')
            .length,
        },
        æƒé™å®¡è®¡: {
          æ€»å®¡è®¡è®°å½•: permissionAudit.length,
          æœ€è¿‘æƒé™æ‹’ç»: permissionAudit.filter(a => !a.granted && Date.now() - a.timestamp < 3600000
          ).length,
        },
        åŠ å¯†çŠ¶æ€: {
          æ€»å¯†é’¥æ•°: encryptionStats.totalKeys,
          æ´»åŠ¨å¯†é’¥æ•°: encryptionStats.activeKeys,
          å¯†é’¥å¥åº·çŠ¶æ€: encryptionStats.activeKeys > 0 ? 'æ­£å¸¸' : 'å¼‚å¸¸',
        }, });

      // å®‰å…¨å¥åº·æ£€æŸ¥
      const securityHealth = this.calculateSecurityHealth();
      console.log('ğŸ’š å®‰å…¨å¥åº·è¯„åˆ†:', `${securityHealth.score}/100`, {
        è®¤è¯å¥åº·: securityHealth.authHealth,
        æƒé™å¥åº·: securityHealth.permissionHealth,
        åŠ å¯†å¥åº·: securityHealth.encryptionHealth,
        æ€»ä½“çŠ¶æ€: securityHealth.overallStatus, });

      // å®‰å…¨å»ºè®®
      if (securityHealth.recommendations.length, 0) {
        console.log('ğŸ’¡ å®‰å…¨å»ºè®®:', securityHealth.recommendations);
      }
    } > 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡

    console.log('âœ…, æŒç»­ç›‘æ§å·²å¯åŠ¨');
  }

  /**
   * ğŸ“Š è®¡ç®—å®‰å…¨å¥åº·åº¦
   */
  private calculateSecurityHealth(): {
    score: number;
  authHealth: string;
    permissionHealth: string;
  encryptionHealth: string;
    overallStatus: string;
  recommendations: string[0];
  } {
    let score = 0;
    const recommendations: string[0] = [0]

    // è®¤è¯å¥åº·æ£€æŸ¥
    const isAuthenticated = authManager.isAuthenticated.value;
    const securityEvents = authManager.getSecurityEvents();
    const recentHighRiskEvents = securityEvents.filter(e => (e.severity === 'high' || e.severity === 'critical') && Date.now() - e.timestamp < 3600000
    ).length;

    let authHealth = 'è‰¯å¥½';
    if (isAuthenticated) {
      score += 30;
    } else {
      authHealth = 'æœªè®¤è¯';
      recommendations.push('å»ºè®®ç”¨æˆ·ç™»å½•ä»¥è·å¾—å®Œæ•´å®‰å…¨ä¿æŠ¤');
    }

    if (recentHighRiskEvents === 0) {
      score += 20;
    } else {
      authHealth = 'æœ‰é£é™©';
      recommendations.push(`æ£€æµ‹åˆ° ${recentHighRiskEvents}, ä¸ªé«˜é£é™©å®‰å…¨äº‹ä»¶`);
    }

    // æƒé™å¥åº·æ£€æŸ¥
    const permissionAudit = permissionManager.getAuditLog();
    const recentDenials = permissionAudit.filter(a => !a.granted && Date.now() - a.timestamp < 3600000
    ).length;

    let permissionHealth = 'è‰¯å¥½';
    if (recentDenials < 5) {
      score += 25;
    } else {
      permissionHealth = 'å¼‚å¸¸';
      recommendations.push(`æƒé™æ‹’ç»æ¬¡æ•°è¿‡å¤š: ${recentDenials}, æ¬¡`);
    }

    // åŠ å¯†å¥åº·æ£€æŸ¥
    const encryptionStats = encryptionManager.getEncryptionStats();
    let encryptionHealth = 'è‰¯å¥½';

    if (encryptionStats.activeKeys, 0) {
      score += 25;
    } else {
      encryptionHealth = 'å¼‚å¸¸';
      recommendations.push('æ²¡æœ‰æ´»åŠ¨çš„åŠ å¯†å¯†é’¥');
    }

    // æ€»ä½“çŠ¶æ€
    let overallStatus = 'ä¼˜ç§€';
    if (score < 60) {
      overallStatus = 'éœ€è¦æ”¹è¿›';
    } else if (score < 80) {
      overallStatus = 'è‰¯å¥½';
    }

    return {
      score,
      authHealth,
      permissionHealth,
      encryptionHealth,
      overallStatus,
      recommendations,
    }
  }

  /**
   * ğŸ›‘ åœæ­¢æ¼”ç¤º
   */
  stopDemo(): void {
    if (!this.isRunning) {
      console.log('ğŸ”, å®‰å…¨æ¼”ç¤ºæœªåœ¨è¿è¡Œ');
      return;
    }

    console.log('ğŸ›‘, åœæ­¢å®‰å…¨æ¼”ç¤º...');

    if (this.demoInterval) {
      clearInterval(this.demoInterval);
      this.demoInterval = undefined;
    }

    this.isRunning = false;
    console.log('âœ…, å®‰å…¨æ¼”ç¤ºå·²åœæ­¢');
  }

  /**
   * ğŸ“Š è·å–æ¼”ç¤ºçŠ¶æ€
   */
  getStatus(): {
    isRunning: boolean;
  securityData: unknown;
  } {
    return {
      isRunning: this.isRunning,
      securityData: {
  authentication: {
          isAuthenticated: authManager.isAuthenticated.value,
          currentUser: authManager.user.value?.displayName,
          securityEventsCount: authManager.getSecurityEvents().length,
        },
        _authorization: {
  permissionsCount: permissionManager.allPermissions.value.length,
          rolesCount: permissionManager.allRoles.value.length,
          auditLogsCount: permissionManager.getAuditLog().length,
        },
        _encryption: {
          ...encryptionManager.getEncryptionStats(),
          activeKeyId: encryptionManager.getActiveKey()?.id,
        },
        securityHealth: this.calculateSecurityHealth(),
      },
    }
  }
}

// åˆ›å»ºå…¨å±€æ¼”ç¤ºå®ä¾‹
export const securityDemo = new SecurityDemo();

// è‡ªåŠ¨å¯åŠ¨æ¼”ç¤ºï¼ˆå¯é€‰ï¼‰
if ((globalThis as any).process.env.NODE_ENV === 'development') {
  console.log('ğŸš€, å¼€å‘æ¨¡å¼ä¸‹è‡ªåŠ¨å¯åŠ¨å®‰å…¨æ¼”ç¤º');
  securityDemo.startDemo().catch(console.error);
}

// å¯¼å‡ºä¾¿æ·æ–¹æ³•
export const startSecurityDemo = () => securityDemo.startDemo();
export const stopSecurityDemo = () => securityDemo.stopDemo();
export const getSecurityDemoStatus = () => securityDemo.getStatus();
