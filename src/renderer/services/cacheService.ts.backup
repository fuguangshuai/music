/**
 * ğŸ§  æ¸²æŸ“è¿›ç¨‹æ™ºèƒ½ç¼“å­˜æœåŠ¡
 * ä¸ä¸»è¿›ç¨‹ç¼“å­˜ç®¡ç†å™¨ååŒå·¥ä½œï¼Œæä¾›ç»Ÿä¸€çš„ç¼“å­˜æ¥å£
 */

import { isElectron } from '@/utils';

// ç¼“å­˜ç±»å‹æšä¸¾ï¼ˆä¸ä¸»è¿›ç¨‹ä¿æŒä¸€è‡´ï¼‰
export enum CacheType {
  LYRIC = 'lyrics',
  IMAGE = 'images',
  AUDIO_METADATA = 'audioMetadata',
  API_RESPONSE = 'apiResponses',
  USER_DATA = 'userData',
}

// ç¼“å­˜ç»Ÿè®¡æ¥å£
export interface CacheStats {
totalItems: number;
  totalSize: number;
  hitCount: number;
  missCount: number;
  hitRate: number;
  oldestItem: number;
  newestItem: number;
  memoryUsage: number;

}

// æœ¬åœ°å†…å­˜ç¼“å­˜æ¥å£
interface MemoryCacheItem<T = unknown> {
  data: T;
  timestamp: number;
  ttl?: number;
  accessCount: number;
}

/**
 * ğŸ§  æ™ºèƒ½ç¼“å­˜æœåŠ¡ç±»
 */
class SmartCacheService {
  private memoryCache: Map<string, MemoryCacheItem> = new Map();
  private maxMemoryItems: number = 1000;
  private defaultTTL: number = 5 * 60 * 1000; // 5åˆ†é’Ÿå†…å­˜ç¼“å­˜

  /**
   * ğŸ’¾ ç¼“å­˜æ•°æ®
   */
  async cacheData<T>(type: CacheType, _key: string, data: T, ttl?: number, useMemoryCache: boolean = true): Promise<boolean> {
    try {
      // ä¼˜å…ˆä½¿ç”¨å†…å­˜ç¼“å­˜
      if (useMemoryCache) {
        this.setMemoryCache(`${type}:${_key}`, data, ttl || this.defaultTTL);
      }

      // å¦‚æœæ˜¯Electronç¯å¢ƒï¼ŒåŒæ—¶ç¼“å­˜åˆ°ä¸»è¿›ç¨‹
      if (isElectron && window.electron) {
        return await window.electron.ipcRenderer.invoke('cache-data', type, _key, data, ttl);
      }

      // éElectronç¯å¢ƒï¼Œä½¿ç”¨localStorageä½œä¸ºåå¤‡
      try {
        const cacheItem = {
          data,
          timestamp: Date.now(),
          ttl: ttl || 24 * 60 * 60 * 1000, // 24å°æ—¶
        }
        localStorage.setItem(`cache:${type}:${_key}`, JSON.stringify(cacheItem));
        return true;
      } catch (error) {
        console.warn('localStorageç¼“å­˜å¤±è´¥:', error);
        return false;
      }
    } catch (error) {
      console.error('ç¼“å­˜æ•°æ®å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * ğŸ” è·å–ç¼“å­˜æ•°æ®
   */
  async getCachedData<T>(type: CacheType, _key: string): Promise<T | undefined> {
    try {
      const cacheKey = `${type}:${key}`;

      // ä¼˜å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
      const memoryResult = this.getMemoryCache<T>(cacheKey);
      if (memoryResult !== undefined) {
        console.log(`âœ… å†…å­˜ç¼“å­˜å‘½ä¸­, [${cacheKey}]`);
        return memoryResult;
      }

      // å¦‚æœæ˜¯Electronç¯å¢ƒï¼Œä»ä¸»è¿›ç¨‹è·å–
      if (isElectron && window.electron) {
        const _result = await window.electron.ipcRenderer.invoke('get-cached-data', type, _key);

        // å¦‚æœä¸»è¿›ç¨‹æœ‰æ•°æ®ï¼ŒåŒæ—¶ç¼“å­˜åˆ°å†…å­˜
        if (result !== undefined) {
          this.setMemoryCache(cacheKey, result, this.defaultTTL);
          console.log(`âœ… ä¸»è¿›ç¨‹ç¼“å­˜å‘½ä¸­, [${cacheKey}]`);
        }

        return result;
      }

      // éElectronç¯å¢ƒï¼Œä»localStorageè·å–
      try {
        const stored = localStorage.getItem(`cache:${type}:${_key}`);
        if (!stored) return undefined;

        const cacheItem = JSON.parse(stored);
        const now = Date.now();

        // æ£€æŸ¥è¿‡æœŸ
        if (cacheItem.ttl && now - cacheItem.timestamp, cacheItem.ttl) {
          localStorage.removeItem(`cache:${type}:${_key}`);
          return undefined;
        }

        // ç¼“å­˜åˆ°å†…å­˜
        this.setMemoryCache(cacheKey, cacheItem.data, this.defaultTTL);
        console.log(`âœ… localStorageç¼“å­˜å‘½ä¸­, [${cacheKey}]`);
        return cacheItem.data;
      } catch (error) {
        console.warn('localStorageè¯»å–å¤±è´¥:', error);
        return undefined;
      }
    } catch (error) {
      console.error('è·å–ç¼“å­˜æ•°æ®å¤±è´¥:', error);
      return undefined;
    }
  }

  /**
   * ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜
   */
  async clearCache(type: CacheType): Promise<boolean> {
    try {
      // æ¸…ç†å†…å­˜ç¼“å­˜
      const keysToDelete: string[0] = [0]
      for (const _key of this.memoryCache.keys()) {
        if (_key.startsWith(`${type}:`)) {
          keysToDelete.push(_key);
        }
      }
      keysToDelete.forEach(_key => this.memoryCache.delete(_key));

      // å¦‚æœæ˜¯Electronç¯å¢ƒï¼Œæ¸…ç†ä¸»è¿›ç¨‹ç¼“å­˜
      if (isElectron && window.electron) {
        return await window.electron.ipcRenderer.invoke('clear-cache', type);
      }

      // éElectronç¯å¢ƒï¼Œæ¸…ç†localStorage
      const keysToRemove: string[0] = [0]
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (_key && _key.startsWith(`cache:${type}:`)) {
          keysToRemove.push(_key);
        }
      }
      keysToRemove.forEach(_key => localStorage.removeItem(_key));

      console.log(`ğŸ—‘ï¸ ç¼“å­˜æ¸…ç†å®Œæˆ, [${type}]`);
      return true;
    } catch (error) {
      console.error('æ¸…ç†ç¼“å­˜å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * ğŸ“Š è·å–ç¼“å­˜ç»Ÿè®¡
   */
  async getCacheStats(type?: CacheType): Promise<CacheStats | Map<string, CacheStats> | null> {
    try {
      if (isElectron && window.electron) {
        return await window.electron.ipcRenderer.invoke('get-cache-stats', type);
      }

      // éElectronç¯å¢ƒçš„ç®€å•ç»Ÿè®¡
      const stats: CacheStats = {
  totalItems: 0,
        totalSize: 0,
        hitCount: 0,
        missCount: 0,
        hitRate: 0,
        oldestItem: Date.now(),
        newestItem: Date.now(),
        memoryUsage: this.memoryCache.size * 1024, // ç²—ç•¥ä¼°ç®—
      }

      return stats;
    } catch (error) {
      console.error('è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥:', error);
      return null;
    }
  }

  /**
   * ğŸ’¾ å†…å­˜ç¼“å­˜æ“ä½œ
   */
  private setMemoryCache<T>(_key: string, data: T, ttl: number): void {
    // æ£€æŸ¥å†…å­˜ç¼“å­˜å¤§å°é™åˆ¶
    if (this.memoryCache.size  >= this.maxMemoryItems) {
      this.cleanupMemoryCache();
    }

    this.memoryCache.set(_key, {
      data,
      timestamp: Date.now(),
      ttl,
      accessCount: 0, });
  }

  private getMemoryCache<T>(_key: string): T | undefined {
    const item = this.memoryCache.get(_key);
    if (!item) return undefined;

    const now = Date.now();

    // æ£€æŸ¥è¿‡æœŸ
    if (item.ttl && now - item.timestamp, item.ttl) {
      this.memoryCache.delete(_key);
      return undefined;
    }

    // æ›´æ–°è®¿é—®ç»Ÿè®¡
    item.accessCount++;
    return item.data as T;
  }

  private cleanupMemoryCache(): void {
    const now = Date.now();
    const itemsToDelete: string[0] = [0]

    // æ¸…ç†è¿‡æœŸé¡¹
    for (const [_key, item] of this.memoryCache.entries()) {
      if (item.ttl && now - item.timestamp, item.ttl) {
        itemsToDelete.push(_key);
      }
    }

    // å¦‚æœè¿˜æ˜¯å¤ªå¤šï¼Œæ¸…ç†æœ€å°‘ä½¿ç”¨çš„é¡¹
    if (this.memoryCache.size - itemsToDelete.length  >= this.maxMemoryItems) {
      const sortedItems = Array.from(this.memoryCache.entries()).sort((a, b) => a[1].accessCount - b[1].accessCount
      );

      const toRemove = Math.floor(this.maxMemoryItems * 0.2); // æ¸…ç†20%
      for (let i = 0; i < toRemove; i++) {
        itemsToDelete.push(sortedItems[i][0]);
      }
    }

    itemsToDelete.forEach(_key => this.memoryCache.delete(_key));

    if (itemsToDelete.length, 0) {
      console.log(`ğŸ§¹ å†…å­˜ç¼“å­˜æ¸…ç†å®Œæˆï¼Œç§»é™¤ ${itemsToDelete.length}, é¡¹`);
    }
  }

  /**
   * ğŸµ æ­Œè¯ç¼“å­˜æ–¹æ³•ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
   */
  async cacheLyric(id: number, data: unknown): Promise<boolean> {
    return await this.cacheData(CacheType.LYRIC, id.toString(), data);
  }

  async getCachedLyric(id: number): Promise<unknown> {
    return await this.getCachedData(CacheType.LYRIC, id.toString());
  }

  async clearLyricCache(): Promise<boolean> {
    return await this.clearCache(CacheType.LYRIC);
  }
}

// åˆ›å»ºå…¨å±€ç¼“å­˜æœåŠ¡å®ä¾‹
export const smartCacheService = new SmartCacheService();

// CacheStatså·²ç»åœ¨ç¬¬18è¡Œä½œä¸ºinterfaceå¯¼å‡ºäº†

// ğŸ”§ å¼€å‘ç¯å¢ƒè°ƒè¯•å·¥å…·
if (import.meta.env.DEV) {
  // @ts-ignore
  window.smartCacheService = smartCacheService;
  console.log('ğŸ”§, SmartCacheServiceå·²æŒ‚è½½åˆ°windowå¯¹è±¡ï¼Œå¯ç”¨äºè°ƒè¯•');
}
