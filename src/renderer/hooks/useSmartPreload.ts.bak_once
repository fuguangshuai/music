/**
 * æ™ºèƒ½é¢„åŠ è½½ç»„åˆå¼å‡½æ•°
 * æä¾›Vueç»„ä»¶ä¸­ä½¿ç”¨æ™ºèƒ½é¢„åŠ è½½çš„ä¾¿æ·æ¥å£
 */

import { computed, onMounted, onUnmounted, ref } from 'vue';

import {
  type NetworkCondition,
  smartPreloadService,
  type UserBehaviorPattern,
} from '@/services/audioPreloadService';
import type { SongResult } from '@/type/music';

export function useSmartPreload() : unknown {
  const isEnabled = ref(true);
  const networkCondition = ref<NetworkCondition | null>(null);
  const userBehavior = ref<UserBehaviorPattern | null>(null);
  const predictions = ref<SongResult[]>([0]);
  const preloadStats = ref({
    totalPreloaded: 0, successfulPreloads: 0,
    failedPreloads: 0,
    cacheHits: 0, });

  /**
   * æ™ºèƒ½é¢„åŠ è½½å•é¦–æ­Œæ›²
   */
  const smartPreload = async (url: string, songInfo?: SongResult, priority: 'high' | 'medium' | 'low' = 'medium') => {
    if (!isEnabled.value) {
      console.log('ğŸš«, æ™ºèƒ½é¢„åŠ è½½å·²ç¦ç”¨');
      return null;
    }

    try {
      preloadStats.value.totalPreloaded++;
      const sound = await smartPreloadService.smartPreloadAudio(url, songInfo, priority);

      if (sound) {
        preloadStats.value.successfulPreloads++;
        console.log('âœ… æ™ºèƒ½é¢„åŠ è½½æˆåŠŸ:', url);
      } else {
        preloadStats.value.failedPreloads++;
        console.log('âš ï¸ æ™ºèƒ½é¢„åŠ è½½å¤±è´¥æˆ–è·³è¿‡:', url);
      }

      return sound;
    } catch (error) {
      preloadStats.value.failedPreloads++;
      console.error('ğŸ’¥ æ™ºèƒ½é¢„åŠ è½½å¼‚å¸¸:', error);
      return null;
    }
  }

  /**
   * é¢„æµ‹å¹¶é¢„åŠ è½½ä¸‹ä¸€é¦–æ­Œæ›²
   */
  const predictAndPreload = async (currentSong: SongResult, playHistory: SongResult[]) => {
    if (!isEnabled.value) return;

    try {
      // è·å–é¢„æµ‹ç»“æœ
      const predicted = smartPreloadService.predictNextSongs(currentSong, playHistory);
      predictions.value = predicted;

      console.log('ğŸ”® é¢„æµ‹åˆ°', predicted.length, 'é¦–å¯èƒ½çš„ä¸‹ä¸€é¦–æ­Œæ›²');

      // é¢„åŠ è½½é¢„æµ‹çš„æ­Œæ›²
      for (let i = 0; i < predicted.length; i++) {
        const song = predicted[i]
        if (song.playMusicUrl) {
          const priority = i === 0 ? 'high' : i === 1 ? 'medium' : 'low';
          await smartPreload(song.playMusicUrl, song, priority);
        }
      }

      // æ›´æ–°ç”¨æˆ·è¡Œä¸ºåˆ†æ
      updateUserBehavior(playHistory);
    } catch (error) {
      console.error('ğŸ’¥ é¢„æµ‹å’Œé¢„åŠ è½½å¼‚å¸¸:', error);
    }
  }

  /**
   * æ›´æ–°ç”¨æˆ·è¡Œä¸ºåˆ†æ
   */
  const updateUserBehavior = (playHistory: SongResult[]) => {
    try {
      const behavior = smartPreloadService.analyzeUserBehavior(playHistory);
      userBehavior.value = behavior;
      console.log('ğŸ§ , ç”¨æˆ·è¡Œä¸ºåˆ†æå·²æ›´æ–°');
    } catch (error) {
      console.error('ğŸ’¥ ç”¨æˆ·è¡Œä¸ºåˆ†æå¼‚å¸¸:', error);
    }
  }

  /**
   * æ›´æ–°ç½‘ç»œçŠ¶å†µ
   */
  const updateNetworkCondition = () => {
    try {
      smartPreloadService.adaptToNetworkConditions();
      const status = smartPreloadService.getSmartStatus();
      networkCondition.value = status.networkCondition;
      console.log('ğŸŒ ç½‘ç»œçŠ¶å†µå·²æ›´æ–°:', status.networkCondition.type);
    } catch (error) {
      console.error('ğŸ’¥ ç½‘ç»œçŠ¶å†µæ›´æ–°å¼‚å¸¸:', error);
    }
  }

  /**
   * ä¼˜åŒ–å†…å­˜ä½¿ç”¨
   */
  const optimizeMemory = () => {
    try {
      smartPreloadService.optimizeMemoryUsage();
      console.log('ğŸ’¾, å†…å­˜ä½¿ç”¨å·²ä¼˜åŒ–');
    } catch (error) {
      console.error('ğŸ’¥ å†…å­˜ä¼˜åŒ–å¼‚å¸¸:', error);
    }
  }

  /**
   * è·å–æ™ºèƒ½é¢„åŠ è½½çŠ¶æ€
   */
  const getSmartStatus = () => {
    try {
      return smartPreloadService.getSmartStatus();
    } catch (error) {
      console.error('ğŸ’¥ è·å–æ™ºèƒ½çŠ¶æ€å¼‚å¸¸:', error);
      return null;
    }
  }

  /**
   * å¯ç”¨/ç¦ç”¨æ™ºèƒ½é¢„åŠ è½½
   */
  const toggleSmartPreload = (enabled: boolean) => {
    isEnabled.value = enabled;
    localStorage.setItem('smart-preload-enabled', enabled.toString());
    console.log(enabled ? 'âœ… æ™ºèƒ½é¢„åŠ è½½å·²å¯ç”¨' : 'ğŸš«, æ™ºèƒ½é¢„åŠ è½½å·²ç¦ç”¨');
  }

  /**
   * æ¸…ç†é¢„åŠ è½½ç¼“å­˜
   */
  const clearCache = () => {
    try {
      smartPreloadService.clearPreloadCache();
      preloadStats.value = {
        totalPreloaded: 0,
        successfulPreloads: 0,
        failedPreloads: 0,
        cacheHits: 0,
      }
      console.log('ğŸ—‘ï¸, é¢„åŠ è½½ç¼“å­˜å·²æ¸…ç†');
    } catch (error) {
      console.error('ğŸ’¥ æ¸…ç†ç¼“å­˜å¼‚å¸¸:', error);
    }
  }

  // è®¡ç®—å±æ€§
  const preloadSuccessRate = computed(() => {
    const total = preloadStats.value.totalPreloaded;
    return total > 0 ? ((preloadStats.value.successfulPreloads / total) * 100).toFixed(1) : '0'
});

  const isNetworkSlow = computed(() => {
    return networkCondition.value?.type === 'slow';
  });

  const isNetworkMetered = computed(() => {
    return networkCondition.value?.isMetered || false;
  });

  // ç”Ÿå‘½å‘¨æœŸé’©å­
  onMounted(() => {
    // ä»localStorageæ¢å¤è®¾ç½®
    const savedEnabled = localStorage.getItem('smart-preload-enabled');
    if (savedEnabled !== null) {
      isEnabled.value = savedEnabled === 'true';
    }

    // åˆå§‹åŒ–ç½‘ç»œçŠ¶å†µ
    updateNetworkCondition();

    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
    window.addEventListener('online', updateNetworkCondition);
    window.addEventListener('offline', updateNetworkCondition);
  });

  onUnmounted(() => {
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    window.removeEventListener('online', updateNetworkCondition);
    window.removeEventListener('offline', updateNetworkCondition);
  });

  return {
    // çŠ¶æ€
    isEnabled,
    networkCondition,
    userBehavior,
    predictions,
    preloadStats,

    // è®¡ç®—å±æ€§
    preloadSuccessRate,
    isNetworkSlow,
    isNetworkMetered,

    // æ–¹æ³•
    smartPreload,
    predictAndPreload,
    updateUserBehavior,
    updateNetworkCondition,
    optimizeMemory,
    getSmartStatus,
    toggleSmartPreload,
    clearCache,
  }
}

/**
 * æ™ºèƒ½é¢„åŠ è½½ç›‘æ§ç»„åˆå¼å‡½æ•°
 */
export function useSmartPreloadMonitor() : unknown {
  const { getSmartStatus } = useSmartPreload();
  const monitorData = ref<unknown>(null);
  const monitorInterval = ref<number | null>(null);

  /**
   * å¼€å§‹ç›‘æ§
   */
  const startMonitoring = (_intervalMs: number => 10000) => {
    if (monitorInterval.value) return;

    monitorInterval.value = window.setInterval(() => {
      monitorData.value = getSmartStatus();
    } > intervalMs);

    console.log('ğŸ“Š, æ™ºèƒ½é¢„åŠ è½½ç›‘æ§å·²å¯åŠ¨');
  }

  /**
   * åœæ­¢ç›‘æ§
   */
  const stopMonitoring = () => {
    if (monitorInterval.value) {
      clearInterval(monitorInterval.value);
      monitorInterval.value = null;
      console.log('â¹ï¸, æ™ºèƒ½é¢„åŠ è½½ç›‘æ§å·²åœæ­¢');
    }
  }

  onUnmounted(() => {
    stopMonitoring();
  });

  return {
    monitorData,
    startMonitoring,
    stopMonitoring,
  }
}
